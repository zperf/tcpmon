// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tcpmon.proto

package tcpmon

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MetricType int32

const (
	MetricType_TCP MetricType = 0
	MetricType_NIC MetricType = 1
	MetricType_NET MetricType = 2
)

var MetricType_name = map[int32]string{
	0: "TCP",
	1: "NIC",
	2: "NET",
}

var MetricType_value = map[string]int32{
	"TCP": 0,
	"NIC": 1,
	"NET": 2,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}

func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{0}
}

// from linux/include/net/tcp_states.h
type SocketState int32

const (
	SocketState_TCP_ESTABLISHED  SocketState = 0
	SocketState_TCP_SYN_SENT     SocketState = 1
	SocketState_TCP_SYN_RECV     SocketState = 2
	SocketState_TCP_FIN_WAIT1    SocketState = 3
	SocketState_TCP_FIN_WAIT2    SocketState = 4
	SocketState_TCP_TIME_WAIT    SocketState = 5
	SocketState_TCP_CLOSE        SocketState = 6
	SocketState_TCP_CLOSE_WAIT   SocketState = 7
	SocketState_TCP_LAST_ACK     SocketState = 8
	SocketState_TCP_LISTEN       SocketState = 9
	SocketState_TCP_CLOSING      SocketState = 10
	SocketState_TCP_NEW_SYN_RECV SocketState = 11
)

var SocketState_name = map[int32]string{
	0:  "TCP_ESTABLISHED",
	1:  "TCP_SYN_SENT",
	2:  "TCP_SYN_RECV",
	3:  "TCP_FIN_WAIT1",
	4:  "TCP_FIN_WAIT2",
	5:  "TCP_TIME_WAIT",
	6:  "TCP_CLOSE",
	7:  "TCP_CLOSE_WAIT",
	8:  "TCP_LAST_ACK",
	9:  "TCP_LISTEN",
	10: "TCP_CLOSING",
	11: "TCP_NEW_SYN_RECV",
}

var SocketState_value = map[string]int32{
	"TCP_ESTABLISHED":  0,
	"TCP_SYN_SENT":     1,
	"TCP_SYN_RECV":     2,
	"TCP_FIN_WAIT1":    3,
	"TCP_FIN_WAIT2":    4,
	"TCP_TIME_WAIT":    5,
	"TCP_CLOSE":        6,
	"TCP_CLOSE_WAIT":   7,
	"TCP_LAST_ACK":     8,
	"TCP_LISTEN":       9,
	"TCP_CLOSING":      10,
	"TCP_NEW_SYN_RECV": 11,
}

func (x SocketState) String() string {
	return proto.EnumName(SocketState_name, int32(x))
}

func (SocketState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{1}
}

type Metric struct {
	// Types that are valid to be assigned to Body:
	//
	//	*Metric_Tcp
	//	*Metric_Nic
	//	*Metric_Net
	Body isMetric_Body `protobuf_oneof:"body"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{0}
}
func (m *Metric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return m.Size()
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

type isMetric_Body interface {
	isMetric_Body()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Metric_Tcp struct {
	Tcp *TcpMetric `protobuf:"bytes,1,opt,name=tcp,proto3,oneof" json:"tcp,omitempty"`
}
type Metric_Nic struct {
	Nic *NicMetric `protobuf:"bytes,2,opt,name=nic,proto3,oneof" json:"nic,omitempty"`
}
type Metric_Net struct {
	Net *NetstatMetric `protobuf:"bytes,3,opt,name=net,proto3,oneof" json:"net,omitempty"`
}

func (*Metric_Tcp) isMetric_Body() {}
func (*Metric_Nic) isMetric_Body() {}
func (*Metric_Net) isMetric_Body() {}

func (m *Metric) GetBody() isMetric_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Metric) GetTcp() *TcpMetric {
	if x, ok := m.GetBody().(*Metric_Tcp); ok {
		return x.Tcp
	}
	return nil
}

func (m *Metric) GetNic() *NicMetric {
	if x, ok := m.GetBody().(*Metric_Nic); ok {
		return x.Nic
	}
	return nil
}

func (m *Metric) GetNet() *NetstatMetric {
	if x, ok := m.GetBody().(*Metric_Net); ok {
		return x.Net
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Metric) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Metric_Tcp)(nil),
		(*Metric_Nic)(nil),
		(*Metric_Net)(nil),
	}
}

// Socket memory usage. aka skmem
// check: https://man7.org/linux/man-pages/man8/ss.8.html
type SocketMemoryUsage struct {
	RmemAlloc  uint32 `protobuf:"varint,1,opt,name=rmem_alloc,json=rmemAlloc,proto3" json:"rmem_alloc,omitempty"`
	RcvBuf     uint32 `protobuf:"varint,2,opt,name=rcv_buf,json=rcvBuf,proto3" json:"rcv_buf,omitempty"`
	WmemAlloc  uint32 `protobuf:"varint,3,opt,name=wmem_alloc,json=wmemAlloc,proto3" json:"wmem_alloc,omitempty"`
	SndBuf     uint32 `protobuf:"varint,4,opt,name=snd_buf,json=sndBuf,proto3" json:"snd_buf,omitempty"`
	FwdAlloc   uint32 `protobuf:"varint,5,opt,name=fwd_alloc,json=fwdAlloc,proto3" json:"fwd_alloc,omitempty"`
	WmemQueued uint32 `protobuf:"varint,6,opt,name=wmem_queued,json=wmemQueued,proto3" json:"wmem_queued,omitempty"`
	OptMem     uint32 `protobuf:"varint,7,opt,name=opt_mem,json=optMem,proto3" json:"opt_mem,omitempty"`
	BackLog    uint32 `protobuf:"varint,8,opt,name=back_log,json=backLog,proto3" json:"back_log,omitempty"`
	SockDrop   uint32 `protobuf:"varint,9,opt,name=sock_drop,json=sockDrop,proto3" json:"sock_drop,omitempty"`
}

func (m *SocketMemoryUsage) Reset()         { *m = SocketMemoryUsage{} }
func (m *SocketMemoryUsage) String() string { return proto.CompactTextString(m) }
func (*SocketMemoryUsage) ProtoMessage()    {}
func (*SocketMemoryUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{1}
}
func (m *SocketMemoryUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocketMemoryUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocketMemoryUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocketMemoryUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocketMemoryUsage.Merge(m, src)
}
func (m *SocketMemoryUsage) XXX_Size() int {
	return m.Size()
}
func (m *SocketMemoryUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_SocketMemoryUsage.DiscardUnknown(m)
}

var xxx_messageInfo_SocketMemoryUsage proto.InternalMessageInfo

func (m *SocketMemoryUsage) GetRmemAlloc() uint32 {
	if m != nil {
		return m.RmemAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetRcvBuf() uint32 {
	if m != nil {
		return m.RcvBuf
	}
	return 0
}

func (m *SocketMemoryUsage) GetWmemAlloc() uint32 {
	if m != nil {
		return m.WmemAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetSndBuf() uint32 {
	if m != nil {
		return m.SndBuf
	}
	return 0
}

func (m *SocketMemoryUsage) GetFwdAlloc() uint32 {
	if m != nil {
		return m.FwdAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetWmemQueued() uint32 {
	if m != nil {
		return m.WmemQueued
	}
	return 0
}

func (m *SocketMemoryUsage) GetOptMem() uint32 {
	if m != nil {
		return m.OptMem
	}
	return 0
}

func (m *SocketMemoryUsage) GetBackLog() uint32 {
	if m != nil {
		return m.BackLog
	}
	return 0
}

func (m *SocketMemoryUsage) GetSockDrop() uint32 {
	if m != nil {
		return m.SockDrop
	}
	return 0
}

type TimerInfo struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ExpireTimeUs uint64 `protobuf:"varint,2,opt,name=expire_time_us,json=expireTimeUs,proto3" json:"expire_time_us,omitempty"`
	Retrans      uint32 `protobuf:"varint,3,opt,name=retrans,proto3" json:"retrans,omitempty"`
}

func (m *TimerInfo) Reset()         { *m = TimerInfo{} }
func (m *TimerInfo) String() string { return proto.CompactTextString(m) }
func (*TimerInfo) ProtoMessage()    {}
func (*TimerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{2}
}
func (m *TimerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimerInfo.Merge(m, src)
}
func (m *TimerInfo) XXX_Size() int {
	return m.Size()
}
func (m *TimerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TimerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TimerInfo proto.InternalMessageInfo

func (m *TimerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TimerInfo) GetExpireTimeUs() uint64 {
	if m != nil {
		return m.ExpireTimeUs
	}
	return 0
}

func (m *TimerInfo) GetRetrans() uint32 {
	if m != nil {
		return m.Retrans
	}
	return 0
}

type ProcessInfo struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Pid  uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Fd   uint32 `protobuf:"varint,3,opt,name=fd,proto3" json:"fd,omitempty"`
}

func (m *ProcessInfo) Reset()         { *m = ProcessInfo{} }
func (m *ProcessInfo) String() string { return proto.CompactTextString(m) }
func (*ProcessInfo) ProtoMessage()    {}
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{3}
}
func (m *ProcessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInfo.Merge(m, src)
}
func (m *ProcessInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProcessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInfo proto.InternalMessageInfo

func (m *ProcessInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProcessInfo) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ProcessInfo) GetFd() uint32 {
	if m != nil {
		return m.Fd
	}
	return 0
}

type SocketMetric struct {
	State         SocketState        `protobuf:"varint,3,opt,name=state,proto3,enum=SocketState" json:"state,omitempty"`
	RecvQ         uint32             `protobuf:"varint,4,opt,name=recv_q,json=recvQ,proto3" json:"recv_q,omitempty"`
	SendQ         int64              `protobuf:"varint,5,opt,name=send_q,json=sendQ,proto3" json:"send_q,omitempty"`
	LocalAddr     string             `protobuf:"bytes,6,opt,name=local_addr,json=localAddr,proto3" json:"local_addr,omitempty"`
	PeerAddr      string             `protobuf:"bytes,7,opt,name=peer_addr,json=peerAddr,proto3" json:"peer_addr,omitempty"`
	Processes     []*ProcessInfo     `protobuf:"bytes,8,rep,name=processes,proto3" json:"processes,omitempty"`
	Timers        []*TimerInfo       `protobuf:"bytes,9,rep,name=timers,proto3" json:"timers,omitempty"`
	Skmem         *SocketMemoryUsage `protobuf:"bytes,10,opt,name=skmem,proto3" json:"skmem,omitempty"`
	Ts            bool               `protobuf:"varint,11,opt,name=ts,proto3" json:"ts,omitempty"`
	Sack          bool               `protobuf:"varint,12,opt,name=sack,proto3" json:"sack,omitempty"`
	Cubic         bool               `protobuf:"varint,13,opt,name=cubic,proto3" json:"cubic,omitempty"`
	AppLimited    bool               `protobuf:"varint,14,opt,name=app_limited,json=appLimited,proto3" json:"app_limited,omitempty"`
	PacingRate    float64            `protobuf:"fixed64,15,opt,name=pacing_rate,json=pacingRate,proto3" json:"pacing_rate,omitempty"`
	DeliveryRate  float64            `protobuf:"fixed64,16,opt,name=delivery_rate,json=deliveryRate,proto3" json:"delivery_rate,omitempty"`
	Send          float64            `protobuf:"fixed64,17,opt,name=send,proto3" json:"send,omitempty"`
	SndWscale     uint32             `protobuf:"varint,18,opt,name=snd_wscale,json=sndWscale,proto3" json:"snd_wscale,omitempty"`
	RcvWscale     uint32             `protobuf:"varint,19,opt,name=rcv_wscale,json=rcvWscale,proto3" json:"rcv_wscale,omitempty"`
	Rto           float64            `protobuf:"fixed64,20,opt,name=rto,proto3" json:"rto,omitempty"`
	Rtt           float64            `protobuf:"fixed64,21,opt,name=rtt,proto3" json:"rtt,omitempty"`
	Rttvar        float64            `protobuf:"fixed64,22,opt,name=rttvar,proto3" json:"rttvar,omitempty"`
	Minrtt        float64            `protobuf:"fixed64,23,opt,name=minrtt,proto3" json:"minrtt,omitempty"`
	RcvRtt        float64            `protobuf:"fixed64,24,opt,name=rcv_rtt,json=rcvRtt,proto3" json:"rcv_rtt,omitempty"`
	RetransNow    uint32             `protobuf:"varint,25,opt,name=retrans_now,json=retransNow,proto3" json:"retrans_now,omitempty"`
	RetransTotal  uint32             `protobuf:"varint,26,opt,name=retrans_total,json=retransTotal,proto3" json:"retrans_total,omitempty"`
	Ato           float64            `protobuf:"fixed64,30,opt,name=ato,proto3" json:"ato,omitempty"`
	Mss           uint32             `protobuf:"varint,31,opt,name=mss,proto3" json:"mss,omitempty"`
	Pmtu          uint32             `protobuf:"varint,32,opt,name=pmtu,proto3" json:"pmtu,omitempty"`
	Rcvmss        uint32             `protobuf:"varint,33,opt,name=rcvmss,proto3" json:"rcvmss,omitempty"`
	Advmss        uint32             `protobuf:"varint,34,opt,name=advmss,proto3" json:"advmss,omitempty"`
	Cwnd          uint32             `protobuf:"varint,35,opt,name=cwnd,proto3" json:"cwnd,omitempty"`
	SndWnd        uint32             `protobuf:"varint,36,opt,name=snd_wnd,json=sndWnd,proto3" json:"snd_wnd,omitempty"`
	BytesSent     uint32             `protobuf:"varint,37,opt,name=bytes_sent,json=bytesSent,proto3" json:"bytes_sent,omitempty"`
	BytesAcked    uint64             `protobuf:"varint,38,opt,name=bytes_acked,json=bytesAcked,proto3" json:"bytes_acked,omitempty"`
	BytesReceived uint64             `protobuf:"varint,39,opt,name=bytes_received,json=bytesReceived,proto3" json:"bytes_received,omitempty"`
	SegsOut       uint32             `protobuf:"varint,40,opt,name=segs_out,json=segsOut,proto3" json:"segs_out,omitempty"`
	SegsIn        uint32             `protobuf:"varint,41,opt,name=segs_in,json=segsIn,proto3" json:"segs_in,omitempty"`
	Lastsnd       uint32             `protobuf:"varint,42,opt,name=lastsnd,proto3" json:"lastsnd,omitempty"`
	Lastrcv       uint32             `protobuf:"varint,43,opt,name=lastrcv,proto3" json:"lastrcv,omitempty"`
	Lastack       uint32             `protobuf:"varint,44,opt,name=lastack,proto3" json:"lastack,omitempty"`
	Delivered     uint32             `protobuf:"varint,45,opt,name=delivered,proto3" json:"delivered,omitempty"`
	BusyMs        uint32             `protobuf:"varint,46,opt,name=busy_ms,json=busyMs,proto3" json:"busy_ms,omitempty"`
	RcvSpace      uint32             `protobuf:"varint,47,opt,name=rcv_space,json=rcvSpace,proto3" json:"rcv_space,omitempty"`
	RcvSsthresh   uint32             `protobuf:"varint,48,opt,name=rcv_ssthresh,json=rcvSsthresh,proto3" json:"rcv_ssthresh,omitempty"`
	DataSegsOut   uint32             `protobuf:"varint,49,opt,name=data_segs_out,json=dataSegsOut,proto3" json:"data_segs_out,omitempty"`
	DataSegsIn    uint32             `protobuf:"varint,50,opt,name=data_segs_in,json=dataSegsIn,proto3" json:"data_segs_in,omitempty"`
	RwndLimited   uint32             `protobuf:"varint,51,opt,name=rwnd_limited,json=rwndLimited,proto3" json:"rwnd_limited,omitempty"`
	SndbufLimited uint32             `protobuf:"varint,52,opt,name=sndbuf_limited,json=sndbufLimited,proto3" json:"sndbuf_limited,omitempty"`
	Ecn           bool               `protobuf:"varint,53,opt,name=ecn,proto3" json:"ecn,omitempty"`
	Ecnseen       bool               `protobuf:"varint,54,opt,name=ecnseen,proto3" json:"ecnseen,omitempty"`
}

func (m *SocketMetric) Reset()         { *m = SocketMetric{} }
func (m *SocketMetric) String() string { return proto.CompactTextString(m) }
func (*SocketMetric) ProtoMessage()    {}
func (*SocketMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{4}
}
func (m *SocketMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocketMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocketMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocketMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocketMetric.Merge(m, src)
}
func (m *SocketMetric) XXX_Size() int {
	return m.Size()
}
func (m *SocketMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_SocketMetric.DiscardUnknown(m)
}

var xxx_messageInfo_SocketMetric proto.InternalMessageInfo

func (m *SocketMetric) GetState() SocketState {
	if m != nil {
		return m.State
	}
	return SocketState_TCP_ESTABLISHED
}

func (m *SocketMetric) GetRecvQ() uint32 {
	if m != nil {
		return m.RecvQ
	}
	return 0
}

func (m *SocketMetric) GetSendQ() int64 {
	if m != nil {
		return m.SendQ
	}
	return 0
}

func (m *SocketMetric) GetLocalAddr() string {
	if m != nil {
		return m.LocalAddr
	}
	return ""
}

func (m *SocketMetric) GetPeerAddr() string {
	if m != nil {
		return m.PeerAddr
	}
	return ""
}

func (m *SocketMetric) GetProcesses() []*ProcessInfo {
	if m != nil {
		return m.Processes
	}
	return nil
}

func (m *SocketMetric) GetTimers() []*TimerInfo {
	if m != nil {
		return m.Timers
	}
	return nil
}

func (m *SocketMetric) GetSkmem() *SocketMemoryUsage {
	if m != nil {
		return m.Skmem
	}
	return nil
}

func (m *SocketMetric) GetTs() bool {
	if m != nil {
		return m.Ts
	}
	return false
}

func (m *SocketMetric) GetSack() bool {
	if m != nil {
		return m.Sack
	}
	return false
}

func (m *SocketMetric) GetCubic() bool {
	if m != nil {
		return m.Cubic
	}
	return false
}

func (m *SocketMetric) GetAppLimited() bool {
	if m != nil {
		return m.AppLimited
	}
	return false
}

func (m *SocketMetric) GetPacingRate() float64 {
	if m != nil {
		return m.PacingRate
	}
	return 0
}

func (m *SocketMetric) GetDeliveryRate() float64 {
	if m != nil {
		return m.DeliveryRate
	}
	return 0
}

func (m *SocketMetric) GetSend() float64 {
	if m != nil {
		return m.Send
	}
	return 0
}

func (m *SocketMetric) GetSndWscale() uint32 {
	if m != nil {
		return m.SndWscale
	}
	return 0
}

func (m *SocketMetric) GetRcvWscale() uint32 {
	if m != nil {
		return m.RcvWscale
	}
	return 0
}

func (m *SocketMetric) GetRto() float64 {
	if m != nil {
		return m.Rto
	}
	return 0
}

func (m *SocketMetric) GetRtt() float64 {
	if m != nil {
		return m.Rtt
	}
	return 0
}

func (m *SocketMetric) GetRttvar() float64 {
	if m != nil {
		return m.Rttvar
	}
	return 0
}

func (m *SocketMetric) GetMinrtt() float64 {
	if m != nil {
		return m.Minrtt
	}
	return 0
}

func (m *SocketMetric) GetRcvRtt() float64 {
	if m != nil {
		return m.RcvRtt
	}
	return 0
}

func (m *SocketMetric) GetRetransNow() uint32 {
	if m != nil {
		return m.RetransNow
	}
	return 0
}

func (m *SocketMetric) GetRetransTotal() uint32 {
	if m != nil {
		return m.RetransTotal
	}
	return 0
}

func (m *SocketMetric) GetAto() float64 {
	if m != nil {
		return m.Ato
	}
	return 0
}

func (m *SocketMetric) GetMss() uint32 {
	if m != nil {
		return m.Mss
	}
	return 0
}

func (m *SocketMetric) GetPmtu() uint32 {
	if m != nil {
		return m.Pmtu
	}
	return 0
}

func (m *SocketMetric) GetRcvmss() uint32 {
	if m != nil {
		return m.Rcvmss
	}
	return 0
}

func (m *SocketMetric) GetAdvmss() uint32 {
	if m != nil {
		return m.Advmss
	}
	return 0
}

func (m *SocketMetric) GetCwnd() uint32 {
	if m != nil {
		return m.Cwnd
	}
	return 0
}

func (m *SocketMetric) GetSndWnd() uint32 {
	if m != nil {
		return m.SndWnd
	}
	return 0
}

func (m *SocketMetric) GetBytesSent() uint32 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *SocketMetric) GetBytesAcked() uint64 {
	if m != nil {
		return m.BytesAcked
	}
	return 0
}

func (m *SocketMetric) GetBytesReceived() uint64 {
	if m != nil {
		return m.BytesReceived
	}
	return 0
}

func (m *SocketMetric) GetSegsOut() uint32 {
	if m != nil {
		return m.SegsOut
	}
	return 0
}

func (m *SocketMetric) GetSegsIn() uint32 {
	if m != nil {
		return m.SegsIn
	}
	return 0
}

func (m *SocketMetric) GetLastsnd() uint32 {
	if m != nil {
		return m.Lastsnd
	}
	return 0
}

func (m *SocketMetric) GetLastrcv() uint32 {
	if m != nil {
		return m.Lastrcv
	}
	return 0
}

func (m *SocketMetric) GetLastack() uint32 {
	if m != nil {
		return m.Lastack
	}
	return 0
}

func (m *SocketMetric) GetDelivered() uint32 {
	if m != nil {
		return m.Delivered
	}
	return 0
}

func (m *SocketMetric) GetBusyMs() uint32 {
	if m != nil {
		return m.BusyMs
	}
	return 0
}

func (m *SocketMetric) GetRcvSpace() uint32 {
	if m != nil {
		return m.RcvSpace
	}
	return 0
}

func (m *SocketMetric) GetRcvSsthresh() uint32 {
	if m != nil {
		return m.RcvSsthresh
	}
	return 0
}

func (m *SocketMetric) GetDataSegsOut() uint32 {
	if m != nil {
		return m.DataSegsOut
	}
	return 0
}

func (m *SocketMetric) GetDataSegsIn() uint32 {
	if m != nil {
		return m.DataSegsIn
	}
	return 0
}

func (m *SocketMetric) GetRwndLimited() uint32 {
	if m != nil {
		return m.RwndLimited
	}
	return 0
}

func (m *SocketMetric) GetSndbufLimited() uint32 {
	if m != nil {
		return m.SndbufLimited
	}
	return 0
}

func (m *SocketMetric) GetEcn() bool {
	if m != nil {
		return m.Ecn
	}
	return false
}

func (m *SocketMetric) GetEcnseen() bool {
	if m != nil {
		return m.Ecnseen
	}
	return false
}

type TcpMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	Sockets []*SocketMetric `protobuf:"bytes,3,rep,name=sockets,proto3" json:"sockets,omitempty"`
}

func (m *TcpMetric) Reset()         { *m = TcpMetric{} }
func (m *TcpMetric) String() string { return proto.CompactTextString(m) }
func (*TcpMetric) ProtoMessage()    {}
func (*TcpMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{5}
}
func (m *TcpMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpMetric.Merge(m, src)
}
func (m *TcpMetric) XXX_Size() int {
	return m.Size()
}
func (m *TcpMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpMetric.DiscardUnknown(m)
}

var xxx_messageInfo_TcpMetric proto.InternalMessageInfo

func (m *TcpMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TcpMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *TcpMetric) GetSockets() []*SocketMetric {
	if m != nil {
		return m.Sockets
	}
	return nil
}

type IfaceMetric struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RxErrors     uint64 `protobuf:"varint,2,opt,name=rx_errors,json=rxErrors,proto3" json:"rx_errors,omitempty"`
	RxDropped    uint64 `protobuf:"varint,3,opt,name=rx_dropped,json=rxDropped,proto3" json:"rx_dropped,omitempty"`
	RxOverruns   uint64 `protobuf:"varint,4,opt,name=rx_overruns,json=rxOverruns,proto3" json:"rx_overruns,omitempty"`
	RxFrame      uint64 `protobuf:"varint,5,opt,name=rx_frame,json=rxFrame,proto3" json:"rx_frame,omitempty"`
	TxErrors     uint64 `protobuf:"varint,6,opt,name=tx_errors,json=txErrors,proto3" json:"tx_errors,omitempty"`
	TxDropped    uint64 `protobuf:"varint,7,opt,name=tx_dropped,json=txDropped,proto3" json:"tx_dropped,omitempty"`
	TxOverruns   uint64 `protobuf:"varint,8,opt,name=tx_overruns,json=txOverruns,proto3" json:"tx_overruns,omitempty"`
	TxCarrier    uint64 `protobuf:"varint,9,opt,name=tx_carrier,json=txCarrier,proto3" json:"tx_carrier,omitempty"`
	TxCollisions uint64 `protobuf:"varint,10,opt,name=tx_collisions,json=txCollisions,proto3" json:"tx_collisions,omitempty"`
}

func (m *IfaceMetric) Reset()         { *m = IfaceMetric{} }
func (m *IfaceMetric) String() string { return proto.CompactTextString(m) }
func (*IfaceMetric) ProtoMessage()    {}
func (*IfaceMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{6}
}
func (m *IfaceMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IfaceMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IfaceMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IfaceMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IfaceMetric.Merge(m, src)
}
func (m *IfaceMetric) XXX_Size() int {
	return m.Size()
}
func (m *IfaceMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_IfaceMetric.DiscardUnknown(m)
}

var xxx_messageInfo_IfaceMetric proto.InternalMessageInfo

func (m *IfaceMetric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IfaceMetric) GetRxErrors() uint64 {
	if m != nil {
		return m.RxErrors
	}
	return 0
}

func (m *IfaceMetric) GetRxDropped() uint64 {
	if m != nil {
		return m.RxDropped
	}
	return 0
}

func (m *IfaceMetric) GetRxOverruns() uint64 {
	if m != nil {
		return m.RxOverruns
	}
	return 0
}

func (m *IfaceMetric) GetRxFrame() uint64 {
	if m != nil {
		return m.RxFrame
	}
	return 0
}

func (m *IfaceMetric) GetTxErrors() uint64 {
	if m != nil {
		return m.TxErrors
	}
	return 0
}

func (m *IfaceMetric) GetTxDropped() uint64 {
	if m != nil {
		return m.TxDropped
	}
	return 0
}

func (m *IfaceMetric) GetTxOverruns() uint64 {
	if m != nil {
		return m.TxOverruns
	}
	return 0
}

func (m *IfaceMetric) GetTxCarrier() uint64 {
	if m != nil {
		return m.TxCarrier
	}
	return 0
}

func (m *IfaceMetric) GetTxCollisions() uint64 {
	if m != nil {
		return m.TxCollisions
	}
	return 0
}

type NicMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	Ifaces []*IfaceMetric `protobuf:"bytes,3,rep,name=ifaces,proto3" json:"ifaces,omitempty"`
}

func (m *NicMetric) Reset()         { *m = NicMetric{} }
func (m *NicMetric) String() string { return proto.CompactTextString(m) }
func (*NicMetric) ProtoMessage()    {}
func (*NicMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{7}
}
func (m *NicMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NicMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NicMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NicMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NicMetric.Merge(m, src)
}
func (m *NicMetric) XXX_Size() int {
	return m.Size()
}
func (m *NicMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_NicMetric.DiscardUnknown(m)
}

var xxx_messageInfo_NicMetric proto.InternalMessageInfo

func (m *NicMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NicMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *NicMetric) GetIfaces() []*IfaceMetric {
	if m != nil {
		return m.Ifaces
	}
	return nil
}

type NetstatMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	IpTotalPacketsReceived          uint64 `protobuf:"varint,3,opt,name=ip_total_packets_received,json=ipTotalPacketsReceived,proto3" json:"ip_total_packets_received,omitempty"`
	IpForwarded                     uint64 `protobuf:"varint,4,opt,name=ip_forwarded,json=ipForwarded,proto3" json:"ip_forwarded,omitempty"`
	IpIncomingPacketsDiscarded      uint64 `protobuf:"varint,5,opt,name=ip_incoming_packets_discarded,json=ipIncomingPacketsDiscarded,proto3" json:"ip_incoming_packets_discarded,omitempty"`
	IpIncomingPacketsDelivered      uint64 `protobuf:"varint,6,opt,name=ip_incoming_packets_delivered,json=ipIncomingPacketsDelivered,proto3" json:"ip_incoming_packets_delivered,omitempty"`
	IpRequestsSentOut               uint64 `protobuf:"varint,7,opt,name=ip_requests_sent_out,json=ipRequestsSentOut,proto3" json:"ip_requests_sent_out,omitempty"`
	IpOutgoingPacketsDropped        uint64 `protobuf:"varint,8,opt,name=ip_outgoing_packets_dropped,json=ipOutgoingPacketsDropped,proto3" json:"ip_outgoing_packets_dropped,omitempty"`
	TcpActiveConnectionsOpenings    uint64 `protobuf:"varint,9,opt,name=tcp_active_connections_openings,json=tcpActiveConnectionsOpenings,proto3" json:"tcp_active_connections_openings,omitempty"`
	TcpPassiveConnectionOpenings    uint64 `protobuf:"varint,10,opt,name=tcp_passive_connection_openings,json=tcpPassiveConnectionOpenings,proto3" json:"tcp_passive_connection_openings,omitempty"`
	TcpFailedConnectionAttempts     uint64 `protobuf:"varint,11,opt,name=tcp_failed_connection_attempts,json=tcpFailedConnectionAttempts,proto3" json:"tcp_failed_connection_attempts,omitempty"`
	TcpConnectionResetsReceived     uint64 `protobuf:"varint,12,opt,name=tcp_connection_resets_received,json=tcpConnectionResetsReceived,proto3" json:"tcp_connection_resets_received,omitempty"`
	TcpConnectionsEstablished       uint64 `protobuf:"varint,13,opt,name=tcp_connections_established,json=tcpConnectionsEstablished,proto3" json:"tcp_connections_established,omitempty"`
	TcpSegmentsReceived             uint64 `protobuf:"varint,14,opt,name=tcp_segments_received,json=tcpSegmentsReceived,proto3" json:"tcp_segments_received,omitempty"`
	TcpSegmentsSendOut              uint64 `protobuf:"varint,15,opt,name=tcp_segments_send_out,json=tcpSegmentsSendOut,proto3" json:"tcp_segments_send_out,omitempty"`
	TcpSegmentsRetransmitted        uint64 `protobuf:"varint,16,opt,name=tcp_segments_retransmitted,json=tcpSegmentsRetransmitted,proto3" json:"tcp_segments_retransmitted,omitempty"`
	TcpBadSegmentsReceived          uint64 `protobuf:"varint,17,opt,name=tcp_bad_segments_received,json=tcpBadSegmentsReceived,proto3" json:"tcp_bad_segments_received,omitempty"`
	TcpResetsSent                   uint64 `protobuf:"varint,18,opt,name=tcp_resets_sent,json=tcpResetsSent,proto3" json:"tcp_resets_sent,omitempty"`
	UdpPacketsReceived              uint64 `protobuf:"varint,19,opt,name=udp_packets_received,json=udpPacketsReceived,proto3" json:"udp_packets_received,omitempty"`
	UdpPacketsToUnknownPortReceived uint64 `protobuf:"varint,20,opt,name=udp_packets_to_unknown_port_received,json=udpPacketsToUnknownPortReceived,proto3" json:"udp_packets_to_unknown_port_received,omitempty"`
	UdpPacketReceiveErrors          uint64 `protobuf:"varint,21,opt,name=udp_packet_receive_errors,json=udpPacketReceiveErrors,proto3" json:"udp_packet_receive_errors,omitempty"`
	UdpPacketsSent                  uint64 `protobuf:"varint,22,opt,name=udp_packets_sent,json=udpPacketsSent,proto3" json:"udp_packets_sent,omitempty"`
	UdpReceiveBufferErrors          uint64 `protobuf:"varint,23,opt,name=udp_receive_buffer_errors,json=udpReceiveBufferErrors,proto3" json:"udp_receive_buffer_errors,omitempty"`
	UdpSendBufferErrors             uint64 `protobuf:"varint,24,opt,name=udp_send_buffer_errors,json=udpSendBufferErrors,proto3" json:"udp_send_buffer_errors,omitempty"`
}

func (m *NetstatMetric) Reset()         { *m = NetstatMetric{} }
func (m *NetstatMetric) String() string { return proto.CompactTextString(m) }
func (*NetstatMetric) ProtoMessage()    {}
func (*NetstatMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{8}
}
func (m *NetstatMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetstatMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetstatMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetstatMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetstatMetric.Merge(m, src)
}
func (m *NetstatMetric) XXX_Size() int {
	return m.Size()
}
func (m *NetstatMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_NetstatMetric.DiscardUnknown(m)
}

var xxx_messageInfo_NetstatMetric proto.InternalMessageInfo

func (m *NetstatMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NetstatMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *NetstatMetric) GetIpTotalPacketsReceived() uint64 {
	if m != nil {
		return m.IpTotalPacketsReceived
	}
	return 0
}

func (m *NetstatMetric) GetIpForwarded() uint64 {
	if m != nil {
		return m.IpForwarded
	}
	return 0
}

func (m *NetstatMetric) GetIpIncomingPacketsDiscarded() uint64 {
	if m != nil {
		return m.IpIncomingPacketsDiscarded
	}
	return 0
}

func (m *NetstatMetric) GetIpIncomingPacketsDelivered() uint64 {
	if m != nil {
		return m.IpIncomingPacketsDelivered
	}
	return 0
}

func (m *NetstatMetric) GetIpRequestsSentOut() uint64 {
	if m != nil {
		return m.IpRequestsSentOut
	}
	return 0
}

func (m *NetstatMetric) GetIpOutgoingPacketsDropped() uint64 {
	if m != nil {
		return m.IpOutgoingPacketsDropped
	}
	return 0
}

func (m *NetstatMetric) GetTcpActiveConnectionsOpenings() uint64 {
	if m != nil {
		return m.TcpActiveConnectionsOpenings
	}
	return 0
}

func (m *NetstatMetric) GetTcpPassiveConnectionOpenings() uint64 {
	if m != nil {
		return m.TcpPassiveConnectionOpenings
	}
	return 0
}

func (m *NetstatMetric) GetTcpFailedConnectionAttempts() uint64 {
	if m != nil {
		return m.TcpFailedConnectionAttempts
	}
	return 0
}

func (m *NetstatMetric) GetTcpConnectionResetsReceived() uint64 {
	if m != nil {
		return m.TcpConnectionResetsReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpConnectionsEstablished() uint64 {
	if m != nil {
		return m.TcpConnectionsEstablished
	}
	return 0
}

func (m *NetstatMetric) GetTcpSegmentsReceived() uint64 {
	if m != nil {
		return m.TcpSegmentsReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpSegmentsSendOut() uint64 {
	if m != nil {
		return m.TcpSegmentsSendOut
	}
	return 0
}

func (m *NetstatMetric) GetTcpSegmentsRetransmitted() uint64 {
	if m != nil {
		return m.TcpSegmentsRetransmitted
	}
	return 0
}

func (m *NetstatMetric) GetTcpBadSegmentsReceived() uint64 {
	if m != nil {
		return m.TcpBadSegmentsReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpResetsSent() uint64 {
	if m != nil {
		return m.TcpResetsSent
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketsReceived() uint64 {
	if m != nil {
		return m.UdpPacketsReceived
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketsToUnknownPortReceived() uint64 {
	if m != nil {
		return m.UdpPacketsToUnknownPortReceived
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketReceiveErrors() uint64 {
	if m != nil {
		return m.UdpPacketReceiveErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketsSent() uint64 {
	if m != nil {
		return m.UdpPacketsSent
	}
	return 0
}

func (m *NetstatMetric) GetUdpReceiveBufferErrors() uint64 {
	if m != nil {
		return m.UdpReceiveBufferErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpSendBufferErrors() uint64 {
	if m != nil {
		return m.UdpSendBufferErrors
	}
	return 0
}

func init() {
	proto.RegisterEnum("MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("SocketState", SocketState_name, SocketState_value)
	proto.RegisterType((*Metric)(nil), "Metric")
	proto.RegisterType((*SocketMemoryUsage)(nil), "SocketMemoryUsage")
	proto.RegisterType((*TimerInfo)(nil), "TimerInfo")
	proto.RegisterType((*ProcessInfo)(nil), "ProcessInfo")
	proto.RegisterType((*SocketMetric)(nil), "SocketMetric")
	proto.RegisterType((*TcpMetric)(nil), "TcpMetric")
	proto.RegisterType((*IfaceMetric)(nil), "IfaceMetric")
	proto.RegisterType((*NicMetric)(nil), "NicMetric")
	proto.RegisterType((*NetstatMetric)(nil), "NetstatMetric")
}

func init() { proto.RegisterFile("tcpmon.proto", fileDescriptor_59f30c3258032903) }

var fileDescriptor_59f30c3258032903 = []byte{
	// 1929 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xdd, 0x72, 0x13, 0xc9,
	0x15, 0xb6, 0x2c, 0x59, 0xb6, 0x8e, 0x7e, 0x18, 0x06, 0xc3, 0x36, 0xcb, 0xae, 0xf1, 0x6a, 0x61,
	0x71, 0x48, 0xa2, 0x5d, 0x4c, 0x92, 0xaa, 0xad, 0x4a, 0x52, 0x65, 0x0b, 0x91, 0x55, 0x05, 0x8c,
	0x19, 0x89, 0x50, 0xb9, 0x9a, 0x1a, 0xf5, 0xb4, 0xcc, 0x94, 0xa5, 0x99, 0xa6, 0xbb, 0x25, 0xd9,
	0x6f, 0x91, 0xca, 0xe3, 0xe4, 0x09, 0x72, 0xb9, 0x97, 0x7b, 0x99, 0x82, 0xcb, 0x54, 0xde, 0x21,
	0x75, 0x4e, 0xf7, 0xcc, 0xc8, 0xb0, 0x5c, 0xed, 0x5d, 0xf7, 0xf7, 0x9d, 0x9f, 0xee, 0xf3, 0xd7,
	0x23, 0x41, 0xcb, 0x70, 0x39, 0xcf, 0xd2, 0x9e, 0x54, 0x99, 0xc9, 0xba, 0x06, 0xea, 0xcf, 0x85,
	0x51, 0x09, 0xf7, 0xf7, 0xa0, 0x6a, 0xb8, 0x64, 0x95, 0xfd, 0xca, 0x41, 0xf3, 0x10, 0x7a, 0x63,
	0x2e, 0x2d, 0xf1, 0xc3, 0x46, 0x80, 0x04, 0xf2, 0x69, 0xc2, 0xd9, 0xa6, 0xe3, 0x4f, 0x12, 0x5e,
	0xf2, 0x69, 0xc2, 0xfd, 0x2e, 0x54, 0x53, 0x61, 0x58, 0x95, 0xf8, 0x4e, 0xef, 0x44, 0x18, 0x6d,
	0x22, 0xb3, 0x26, 0x23, 0xcc, 0x71, 0x1d, 0x6a, 0x93, 0x2c, 0xbe, 0xec, 0xfe, 0x73, 0x13, 0xae,
	0x8f, 0x32, 0x7e, 0x2e, 0xcc, 0x73, 0x31, 0xcf, 0xd4, 0xe5, 0x2b, 0x1d, 0x9d, 0x09, 0xff, 0x4b,
	0x00, 0x35, 0x17, 0xf3, 0x30, 0x9a, 0xcd, 0x32, 0x4e, 0x07, 0x69, 0x07, 0x0d, 0x44, 0x8e, 0x10,
	0xf0, 0x3f, 0x83, 0x6d, 0xc5, 0x97, 0xe1, 0x64, 0x31, 0xa5, 0x43, 0xb4, 0x83, 0xba, 0xe2, 0xcb,
	0xe3, 0xc5, 0x14, 0xf5, 0x56, 0xa5, 0x5e, 0xd5, 0xea, 0xad, 0xd6, 0xf5, 0x74, 0x1a, 0x93, 0x5e,
	0xcd, 0xea, 0xe9, 0x34, 0x46, 0xbd, 0x3b, 0xd0, 0x98, 0xae, 0x62, 0xa7, 0xb6, 0x45, 0xd4, 0xce,
	0x74, 0x15, 0x5b, 0xad, 0xbb, 0xd0, 0x24, 0xa3, 0x6f, 0x17, 0x62, 0x21, 0x62, 0x56, 0x27, 0x9a,
	0xfc, 0xbc, 0x24, 0x04, 0xcd, 0x66, 0xd2, 0x84, 0x73, 0x31, 0x67, 0xdb, 0xd6, 0x6c, 0x26, 0xf1,
	0x3a, 0xfe, 0x6d, 0xd8, 0x99, 0x44, 0xfc, 0x3c, 0x9c, 0x65, 0x67, 0x6c, 0x87, 0x98, 0x6d, 0xdc,
	0x3f, 0xcb, 0xce, 0xd0, 0xa3, 0xce, 0xf8, 0x79, 0x18, 0xab, 0x4c, 0xb2, 0x86, 0xf5, 0x88, 0xc0,
	0x13, 0x95, 0xc9, 0x6e, 0x08, 0x8d, 0x71, 0x32, 0x17, 0x6a, 0x98, 0x4e, 0x33, 0xdf, 0x87, 0x5a,
	0x1a, 0xcd, 0x05, 0x45, 0xa1, 0x11, 0xd0, 0xda, 0xbf, 0x07, 0x1d, 0x71, 0x21, 0x13, 0x25, 0x42,
	0x93, 0xcc, 0x45, 0xb8, 0xd0, 0x14, 0x87, 0x5a, 0xd0, 0xb2, 0x28, 0x2a, 0xbf, 0xd2, 0x3e, 0x83,
	0x6d, 0x25, 0x8c, 0x8a, 0x52, 0xed, 0x42, 0x91, 0x6f, 0xbb, 0x7d, 0x68, 0x9e, 0xaa, 0x8c, 0x0b,
	0xad, 0x3f, 0xe9, 0xc2, 0x83, 0xaa, 0x4c, 0x62, 0x17, 0x5f, 0x5c, 0xfa, 0x1d, 0xd8, 0x9c, 0xc6,
	0xce, 0xd2, 0xe6, 0x34, 0xee, 0xfe, 0x0f, 0xa0, 0x95, 0xa7, 0x8e, 0xea, 0xa6, 0x0b, 0x5b, 0x98,
	0x68, 0x41, 0x32, 0x9d, 0xc3, 0x56, 0xcf, 0xb2, 0x23, 0xc4, 0x02, 0x4b, 0xf9, 0x37, 0xa1, 0xae,
	0x04, 0x5f, 0x86, 0x6f, 0x5d, 0x06, 0xb6, 0x70, 0xf7, 0x12, 0x61, 0x2d, 0xd2, 0x38, 0x7c, 0x4b,
	0xd1, 0xaf, 0x06, 0x5b, 0xb8, 0x7b, 0x89, 0xf9, 0x9c, 0x65, 0x3c, 0x9a, 0x85, 0x51, 0x1c, 0x2b,
	0x8a, 0x7c, 0x23, 0x68, 0x10, 0x72, 0x14, 0xc7, 0x0a, 0x83, 0x28, 0x85, 0x50, 0x96, 0xdd, 0x26,
	0x76, 0x07, 0x01, 0x22, 0x1f, 0x42, 0x43, 0xda, 0x3b, 0x0a, 0xcd, 0x76, 0xf6, 0xab, 0x07, 0xcd,
	0xc3, 0x56, 0x6f, 0xed, 0xd6, 0x41, 0x49, 0xfb, 0x5d, 0xa8, 0x63, 0x20, 0x95, 0x66, 0x0d, 0x12,
	0x84, 0x5e, 0x11, 0xff, 0xc0, 0x31, 0xfe, 0x01, 0x6c, 0xe9, 0x73, 0xcc, 0x31, 0x50, 0x5d, 0xfb,
	0xbd, 0x8f, 0xca, 0x36, 0xb0, 0x02, 0x18, 0x28, 0xa3, 0x59, 0x73, 0xbf, 0x72, 0xb0, 0x13, 0x6c,
	0x1a, 0x8d, 0xe1, 0xd5, 0x11, 0x3f, 0x67, 0x2d, 0x42, 0x68, 0xed, 0xef, 0xc2, 0x16, 0x5f, 0x4c,
	0x12, 0xce, 0xda, 0x04, 0xda, 0x0d, 0x96, 0x5a, 0x24, 0x65, 0x38, 0x4b, 0xe6, 0x89, 0x11, 0x31,
	0xeb, 0x10, 0x07, 0x91, 0x94, 0xcf, 0x2c, 0x82, 0x02, 0x32, 0xe2, 0x49, 0x7a, 0x16, 0x2a, 0x0c,
	0xf4, 0xb5, 0xfd, 0xca, 0x41, 0x25, 0x00, 0x0b, 0x05, 0x18, 0xdf, 0xaf, 0xa1, 0x1d, 0x8b, 0x59,
	0xb2, 0x14, 0xea, 0xd2, 0x8a, 0x78, 0x24, 0xd2, 0xca, 0x41, 0x12, 0xc2, 0x03, 0x89, 0x34, 0x66,
	0xd7, 0x89, 0xa3, 0x35, 0x86, 0x1a, 0x7b, 0x63, 0xa5, 0x79, 0x34, 0x13, 0xcc, 0xb7, 0xad, 0xa3,
	0xd3, 0xf8, 0x35, 0x01, 0xd4, 0x91, 0x7c, 0x99, 0xd3, 0x37, 0x5c, 0x47, 0xf2, 0xa5, 0xa3, 0x3d,
	0xa8, 0x2a, 0x93, 0xb1, 0x5d, 0x32, 0x88, 0x4b, 0x8b, 0x18, 0x76, 0x33, 0x47, 0x8c, 0x7f, 0x0b,
	0xea, 0xca, 0x98, 0x65, 0xa4, 0xd8, 0x2d, 0x02, 0xdd, 0x0e, 0xf1, 0x79, 0x92, 0xa2, 0xf0, 0x67,
	0x16, 0xb7, 0xbb, 0xbc, 0xcb, 0x91, 0x60, 0x4e, 0x81, 0x2f, 0x03, 0x63, 0x30, 0x08, 0xae, 0x90,
	0xc3, 0x34, 0x5b, 0xb1, 0xdb, 0xb6, 0x21, 0x1d, 0x74, 0x92, 0xad, 0x30, 0x08, 0xb9, 0x80, 0xc9,
	0x4c, 0x34, 0x63, 0x9f, 0x93, 0x48, 0xcb, 0x81, 0x63, 0xc4, 0xf0, 0x80, 0x91, 0xc9, 0xd8, 0x9e,
	0x3d, 0x60, 0x64, 0x8f, 0x3c, 0xd7, 0x9a, 0xdd, 0xb5, 0x25, 0x3f, 0xd7, 0x94, 0x39, 0x39, 0x37,
	0x0b, 0xb6, 0x4f, 0x10, 0xad, 0xe9, 0x1a, 0x7c, 0x89, 0x82, 0x5f, 0x15, 0xb3, 0x07, 0x65, 0x6f,
	0x41, 0x3d, 0x8a, 0x09, 0xef, 0x5a, 0xdc, 0xee, 0xd0, 0x06, 0x5f, 0xa5, 0x31, 0xfb, 0xda, 0xda,
	0xc0, 0x75, 0x3e, 0x88, 0x10, 0xbe, 0x57, 0x0c, 0xa2, 0xd7, 0x36, 0x0b, 0x93, 0x4b, 0x23, 0x74,
	0xa8, 0x45, 0x6a, 0xd8, 0x7d, 0x1b, 0x66, 0x42, 0x46, 0x22, 0xa5, 0x9b, 0x5b, 0x3a, 0xe2, 0xe7,
	0x22, 0x66, 0xdf, 0x50, 0xd3, 0x5b, 0x8d, 0x23, 0x44, 0xfc, 0xfb, 0xd0, 0xb1, 0x02, 0x4a, 0x70,
	0x91, 0x2c, 0x45, 0xcc, 0x1e, 0x90, 0x4c, 0x9b, 0xd0, 0xc0, 0x81, 0x38, 0x98, 0xb4, 0x38, 0xd3,
	0x61, 0xb6, 0x30, 0xec, 0xc0, 0x8e, 0x06, 0xdc, 0xbf, 0x58, 0x50, 0xd4, 0x89, 0x4a, 0x52, 0xf6,
	0x2b, 0x77, 0x34, 0x71, 0xa6, 0x87, 0x29, 0x4e, 0x93, 0x59, 0xa4, 0x8d, 0x4e, 0x63, 0xf6, 0xd0,
	0xaa, 0xb8, 0x6d, 0xce, 0x28, 0xbe, 0x64, 0xbf, 0x2e, 0x19, 0xc5, 0x97, 0x39, 0x83, 0xc5, 0xff,
	0x9b, 0x92, 0xc1, 0xfa, 0xff, 0x02, 0x1a, 0xae, 0x24, 0x45, 0xcc, 0x7e, 0x6b, 0xef, 0x59, 0x00,
	0x78, 0x88, 0xc9, 0x42, 0x5f, 0x86, 0x73, 0xcd, 0x7a, 0xf6, 0x10, 0xb8, 0x7d, 0xae, 0xb1, 0xe3,
	0xb1, 0x26, 0xb4, 0x8c, 0xb8, 0x60, 0xdf, 0xda, 0xb1, 0xa9, 0xf8, 0x72, 0x84, 0x7b, 0xff, 0x2b,
	0x68, 0x11, 0xa9, 0xcd, 0x1b, 0x25, 0xf4, 0x1b, 0xf6, 0x1d, 0xf1, 0x4d, 0xe4, 0x1d, 0xe4, 0x77,
	0xa1, 0x1d, 0x47, 0x26, 0x0a, 0x8b, 0xdb, 0x3f, 0xb2, 0x32, 0x08, 0x8e, 0x5c, 0x04, 0xf6, 0xa1,
	0x55, 0xca, 0x24, 0x29, 0x3b, 0xb4, 0xf5, 0x95, 0x8b, 0x0c, 0x53, 0x72, 0xb4, 0x4a, 0xe3, 0xa2,
	0x4f, 0x1f, 0x3b, 0x47, 0xab, 0x34, 0xce, 0x1b, 0xf5, 0x3e, 0x74, 0x74, 0x1a, 0x4f, 0x16, 0xd3,
	0x42, 0xe8, 0x77, 0x24, 0xd4, 0xb6, 0x68, 0x2e, 0xe6, 0x41, 0x55, 0xf0, 0x94, 0xfd, 0x9e, 0x1a,
	0x1d, 0x97, 0x18, 0x32, 0xc1, 0x53, 0x2d, 0x44, 0xca, 0xfe, 0x40, 0x68, 0xbe, 0xed, 0x6a, 0x68,
	0x14, 0x4f, 0x31, 0xc6, 0x0f, 0xe7, 0x92, 0x36, 0xd1, 0xdc, 0xbe, 0xd4, 0xd5, 0xa0, 0x04, 0xfc,
	0xbb, 0x50, 0x33, 0x97, 0x52, 0xd0, 0xf4, 0xee, 0x1c, 0x36, 0x7b, 0x56, 0x69, 0x7c, 0x29, 0x45,
	0x40, 0x84, 0xff, 0x00, 0xb6, 0x35, 0x8d, 0x2f, 0x7c, 0x1a, 0x70, 0xe2, 0xb5, 0x7b, 0xeb, 0xa3,
	0x3c, 0xc8, 0xd9, 0xee, 0xbf, 0x36, 0xa1, 0x39, 0x9c, 0x46, 0x5c, 0x38, 0xbf, 0x3f, 0xf7, 0x54,
	0x60, 0x52, 0x2e, 0x42, 0xa1, 0x54, 0xa6, 0xf2, 0x87, 0x68, 0x47, 0x5d, 0x0c, 0x68, 0x4f, 0x83,
	0xe3, 0x82, 0x9e, 0x39, 0x29, 0xec, 0xeb, 0x51, 0x0b, 0x1a, 0xea, 0xe2, 0x89, 0x05, 0xa8, 0x97,
	0x2f, 0xc2, 0x6c, 0x29, 0x94, 0x5a, 0xa4, 0x9a, 0x1e, 0x85, 0x5a, 0x00, 0xea, 0xe2, 0x85, 0x43,
	0xb0, 0x54, 0xd5, 0x45, 0x38, 0x55, 0xe8, 0x74, 0x8b, 0xd8, 0x6d, 0x75, 0xf1, 0x54, 0x39, 0xbf,
	0xa6, 0xf0, 0x5b, 0xb7, 0x7e, 0xcd, 0x9a, 0x5f, 0x53, 0xfa, 0xdd, 0xb6, 0x7e, 0xcd, 0xba, 0x5f,
	0xb3, 0xe6, 0x77, 0xc7, 0xfa, 0x35, 0xa5, 0x5f, 0xab, 0xcf, 0x23, 0xa5, 0x12, 0xa1, 0xe8, 0x85,
	0x26, 0xfd, 0xbe, 0x05, 0x70, 0xc4, 0x20, 0x9d, 0xcd, 0x66, 0x89, 0x4e, 0xb2, 0x54, 0xd3, 0xab,
	0x50, 0x0b, 0x5a, 0xe6, 0xa2, 0x5f, 0x60, 0x5d, 0x09, 0x8d, 0xe2, 0xe3, 0xe8, 0x97, 0x66, 0xec,
	0x1e, 0xd4, 0x13, 0xcc, 0x43, 0x9e, 0xb0, 0x56, 0x6f, 0x2d, 0x2d, 0x81, 0xe3, 0xba, 0x3f, 0x01,
	0xb4, 0xaf, 0x7c, 0x6f, 0xfd, 0x52, 0xb7, 0xdf, 0xc3, 0xed, 0x44, 0xda, 0x29, 0x1a, 0xca, 0x88,
	0x6a, 0xa2, 0x9c, 0x2d, 0x36, 0x9b, 0xb7, 0x12, 0x49, 0x13, 0xf5, 0xd4, 0xd2, 0xc5, 0x90, 0xf9,
	0x0a, 0x5a, 0x89, 0x0c, 0xa7, 0x99, 0x5a, 0x45, 0x2a, 0x16, 0xb1, 0xcb, 0x6d, 0x33, 0x91, 0x4f,
	0x73, 0xc8, 0x3f, 0x82, 0x2f, 0x13, 0x19, 0x26, 0x29, 0xcf, 0xe6, 0xf8, 0xa6, 0xe5, 0x0e, 0xe2,
	0x44, 0x73, 0xab, 0x63, 0x33, 0xfe, 0x79, 0x22, 0x87, 0x4e, 0xc6, 0x39, 0x79, 0x92, 0x4b, 0x7c,
	0xd2, 0x44, 0x31, 0x5c, 0xea, 0x9f, 0x32, 0x51, 0x4c, 0x9b, 0x6f, 0x61, 0x37, 0x91, 0xa1, 0x12,
	0x6f, 0x17, 0x42, 0x1b, 0x3b, 0x7a, 0x69, 0x36, 0xd8, 0xa2, 0xb9, 0x9e, 0xc8, 0xc0, 0x51, 0x38,
	0x83, 0x71, 0x42, 0xfc, 0x09, 0xee, 0x24, 0x12, 0x45, 0xce, 0xb2, 0x2b, 0x3e, 0x5d, 0xb1, 0xd9,
	0x62, 0x62, 0x89, 0x7c, 0xe1, 0x24, 0x72, 0x8f, 0xae, 0xf6, 0x06, 0x70, 0xd7, 0x70, 0x19, 0x46,
	0xdc, 0x24, 0x4b, 0x11, 0xf2, 0x2c, 0x4d, 0x05, 0x37, 0x58, 0x30, 0x61, 0x26, 0x45, 0x9a, 0xa4,
	0x67, 0xda, 0xd5, 0xdb, 0x17, 0x86, 0xcb, 0x23, 0x92, 0xea, 0x97, 0x42, 0x2f, 0x9c, 0x4c, 0x6e,
	0x46, 0x46, 0x5a, 0x5f, 0xb5, 0x53, 0x9a, 0x81, 0xc2, 0xcc, 0xa9, 0x95, 0x2a, 0xed, 0x14, 0x66,
	0xfa, 0xb0, 0x87, 0x66, 0xa6, 0x51, 0x32, 0x13, 0xf1, 0xba, 0x95, 0xc8, 0x18, 0x31, 0x97, 0xee,
	0x4b, 0xa6, 0x16, 0xdc, 0x31, 0x5c, 0x3e, 0x25, 0xa1, 0xd2, 0xc8, 0x91, 0x13, 0xc9, 0x8d, 0xac,
	0x69, 0x2b, 0xa1, 0xaf, 0xd4, 0x4a, 0xab, 0x30, 0x52, 0xaa, 0x07, 0x24, 0x53, 0x14, 0xcc, 0x9f,
	0xe1, 0xce, 0x55, 0x23, 0x3a, 0xc4, 0x32, 0x9d, 0xcc, 0x12, 0xfd, 0x46, 0xc4, 0xf4, 0xa5, 0x54,
	0x0b, 0x6e, 0x5f, 0xb1, 0xa0, 0x07, 0xa5, 0x80, 0x7f, 0x08, 0x37, 0x51, 0x5f, 0x8b, 0xb3, 0xb9,
	0x48, 0xd7, 0x7d, 0x77, 0x48, 0xf3, 0x86, 0xe1, 0x72, 0xe4, 0xb8, 0xc2, 0xe7, 0xa3, 0x0f, 0x74,
	0xe8, 0x2b, 0x14, 0x93, 0x7f, 0x8d, 0x74, 0xfc, 0x35, 0x9d, 0x91, 0x48, 0x63, 0xcc, 0xfe, 0x1f,
	0xe1, 0xf3, 0x0f, 0xdc, 0xd0, 0x57, 0xc5, 0x3c, 0x31, 0x38, 0xe6, 0x3d, 0x9b, 0xfc, 0x2b, 0xbe,
	0xd6, 0x78, 0x6c, 0x28, 0xd4, 0x9e, 0x44, 0xf1, 0xcf, 0x1c, 0xf4, 0xba, 0x6d, 0x28, 0xc3, 0xe5,
	0x71, 0x14, 0x7f, 0x74, 0xd6, 0x6f, 0xe0, 0x1a, 0xaa, 0xba, 0xc8, 0xd2, 0x17, 0x82, 0x6f, 0x5f,
	0x77, 0xc3, 0xa5, 0x8d, 0x25, 0x7d, 0x25, 0x7c, 0x07, 0xbb, 0x8b, 0x58, 0x7e, 0xdc, 0xae, 0x37,
	0xec, 0x95, 0x16, 0xb1, 0xfc, 0xb0, 0x55, 0x9f, 0xc3, 0xbd, 0x75, 0x0d, 0x93, 0x85, 0x8b, 0xf4,
	0x3c, 0xcd, 0x56, 0x69, 0x28, 0x33, 0x65, 0x4a, 0x0b, 0xbb, 0x64, 0xe1, 0x6e, 0x69, 0x61, 0x9c,
	0xbd, 0xb2, 0x82, 0xa7, 0x99, 0x32, 0x85, 0xb9, 0xef, 0xe1, 0x76, 0x69, 0x2e, 0xd7, 0xce, 0x07,
	0xf5, 0x4d, 0x7b, 0xc7, 0xc2, 0x86, 0xd3, 0x72, 0x63, 0xfb, 0x00, 0xbc, 0xf5, 0x93, 0xd0, 0x25,
	0x6f, 0x91, 0x46, 0xa7, 0xf4, 0x4a, 0xb7, 0x74, 0x4e, 0x72, 0xeb, 0x93, 0xc5, 0x74, 0x2a, 0x54,
	0xee, 0xe4, 0xb3, 0xc2, 0x89, 0x33, 0x7f, 0x4c, 0xb4, 0x73, 0xf2, 0x18, 0x90, 0xb1, 0xb9, 0xbe,
	0xaa, 0xc7, 0x6c, 0xa5, 0x2c, 0x62, 0x89, 0xd9, 0x5e, 0x57, 0x7a, 0xf8, 0x00, 0xa0, 0x9c, 0x8e,
	0xfe, 0x36, 0x54, 0xc7, 0xfd, 0x53, 0x6f, 0x03, 0x17, 0x27, 0xc3, 0xbe, 0x57, 0xa1, 0xc5, 0x60,
	0xec, 0x6d, 0x3e, 0xfc, 0x6f, 0x05, 0x9a, 0x6b, 0xbf, 0x7c, 0xfc, 0x1b, 0x70, 0x6d, 0xdc, 0x3f,
	0x0d, 0x07, 0xa3, 0xf1, 0xd1, 0xf1, 0xb3, 0xe1, 0xe8, 0x87, 0xc1, 0x13, 0x6f, 0xc3, 0xf7, 0xa0,
	0x85, 0xe0, 0xe8, 0xef, 0x27, 0xe1, 0x68, 0x70, 0x32, 0xf6, 0x2a, 0xeb, 0x48, 0x30, 0xe8, 0xff,
	0xcd, 0xdb, 0xf4, 0xaf, 0x43, 0x1b, 0x91, 0xa7, 0xc3, 0x93, 0xf0, 0xf5, 0xd1, 0x70, 0xfc, 0xc8,
	0xab, 0x7e, 0x08, 0x1d, 0x7a, 0xb5, 0x1c, 0x1a, 0x0f, 0x9f, 0x0f, 0x08, 0xf3, 0xb6, 0xfc, 0x36,
	0x34, 0x10, 0xea, 0x3f, 0x7b, 0x31, 0x1a, 0x78, 0x75, 0xdf, 0x87, 0x4e, 0xb1, 0xb5, 0x22, 0xdb,
	0xb9, 0xb7, 0x67, 0x47, 0xa3, 0x71, 0x78, 0xd4, 0xff, 0xab, 0xb7, 0xe3, 0x77, 0x00, 0x08, 0x19,
	0x8e, 0xc6, 0x83, 0x13, 0xaf, 0xe1, 0x5f, 0x83, 0x66, 0xae, 0x35, 0x3c, 0xf9, 0x8b, 0x07, 0xfe,
	0x2e, 0x78, 0x08, 0x9c, 0x0c, 0x5e, 0x97, 0x87, 0x6c, 0x1e, 0xb3, 0x7f, 0xbf, 0xdb, 0xab, 0xfc,
	0xf8, 0x6e, 0xaf, 0xf2, 0x9f, 0x77, 0x7b, 0x95, 0x7f, 0xbc, 0xdf, 0xdb, 0xf8, 0xf1, 0xfd, 0xde,
	0xc6, 0x4f, 0xef, 0xf7, 0x36, 0x26, 0x75, 0xfa, 0x5f, 0xe1, 0xf1, 0xff, 0x03, 0x00, 0x00, 0xff,
	0xff, 0xf4, 0xde, 0xe8, 0x15, 0x67, 0x10, 0x00, 0x00,
}

func (m *Metric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size := m.Body.Size()
			i -= size
			if _, err := m.Body.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Metric_Tcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Tcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcp != nil {
		{
			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Metric_Nic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Nic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Nic != nil {
		{
			size, err := m.Nic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Metric_Net) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Net) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Net != nil {
		{
			size, err := m.Net.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SocketMemoryUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocketMemoryUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocketMemoryUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SockDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SockDrop))
		i--
		dAtA[i] = 0x48
	}
	if m.BackLog != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BackLog))
		i--
		dAtA[i] = 0x40
	}
	if m.OptMem != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.OptMem))
		i--
		dAtA[i] = 0x38
	}
	if m.WmemQueued != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.WmemQueued))
		i--
		dAtA[i] = 0x30
	}
	if m.FwdAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.FwdAlloc))
		i--
		dAtA[i] = 0x28
	}
	if m.SndBuf != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndBuf))
		i--
		dAtA[i] = 0x20
	}
	if m.WmemAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.WmemAlloc))
		i--
		dAtA[i] = 0x18
	}
	if m.RcvBuf != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvBuf))
		i--
		dAtA[i] = 0x10
	}
	if m.RmemAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RmemAlloc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retrans != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Retrans))
		i--
		dAtA[i] = 0x18
	}
	if m.ExpireTimeUs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.ExpireTimeUs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Fd))
		i--
		dAtA[i] = 0x18
	}
	if m.Pid != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SocketMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocketMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocketMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecnseen {
		i--
		if m.Ecnseen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.Ecn {
		i--
		if m.Ecn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.SndbufLimited != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndbufLimited))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.RwndLimited != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RwndLimited))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.DataSegsIn != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.DataSegsIn))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DataSegsOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.DataSegsOut))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.RcvSsthresh != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvSsthresh))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.RcvSpace != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.BusyMs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BusyMs))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.Delivered != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Delivered))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.Lastack != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastack))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.Lastrcv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastrcv))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.Lastsnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastsnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.SegsIn != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SegsIn))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.SegsOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SegsOut))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.BytesReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesReceived))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.BytesAcked != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesAcked))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.BytesSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesSent))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.SndWnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndWnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.Cwnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Cwnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.Advmss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Advmss))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.Rcvmss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Rcvmss))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.Pmtu != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Pmtu))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.Mss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Mss))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.Ato != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ato))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf1
	}
	if m.RetransTotal != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RetransTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.RetransNow != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RetransNow))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.RcvRtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RcvRtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if m.Minrtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minrtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb9
	}
	if m.Rttvar != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rttvar))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb1
	}
	if m.Rtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if m.Rto != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rto))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.RcvWscale != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvWscale))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SndWscale != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndWscale))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Send != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Send))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.DeliveryRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeliveryRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.PacingRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PacingRate))))
		i--
		dAtA[i] = 0x79
	}
	if m.AppLimited {
		i--
		if m.AppLimited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Cubic {
		i--
		if m.Cubic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Sack {
		i--
		if m.Sack {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Ts {
		i--
		if m.Ts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Skmem != nil {
		{
			size, err := m.Skmem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Timers) > 0 {
		for iNdEx := len(m.Timers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Timers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Processes) > 0 {
		for iNdEx := len(m.Processes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PeerAddr) > 0 {
		i -= len(m.PeerAddr)
		copy(dAtA[i:], m.PeerAddr)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.PeerAddr)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LocalAddr) > 0 {
		i -= len(m.LocalAddr)
		copy(dAtA[i:], m.LocalAddr)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.LocalAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.SendQ != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SendQ))
		i--
		dAtA[i] = 0x28
	}
	if m.RecvQ != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RecvQ))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *TcpMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sockets) > 0 {
		for iNdEx := len(m.Sockets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sockets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IfaceMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IfaceMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IfaceMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxCollisions != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxCollisions))
		i--
		dAtA[i] = 0x50
	}
	if m.TxCarrier != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxCarrier))
		i--
		dAtA[i] = 0x48
	}
	if m.TxOverruns != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxOverruns))
		i--
		dAtA[i] = 0x40
	}
	if m.TxDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxDropped))
		i--
		dAtA[i] = 0x38
	}
	if m.TxErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxErrors))
		i--
		dAtA[i] = 0x30
	}
	if m.RxFrame != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxFrame))
		i--
		dAtA[i] = 0x28
	}
	if m.RxOverruns != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxOverruns))
		i--
		dAtA[i] = 0x20
	}
	if m.RxDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxDropped))
		i--
		dAtA[i] = 0x18
	}
	if m.RxErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxErrors))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NicMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NicMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NicMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ifaces) > 0 {
		for iNdEx := len(m.Ifaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ifaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetstatMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetstatMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetstatMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UdpSendBufferErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpSendBufferErrors))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.UdpReceiveBufferErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpReceiveBufferErrors))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.UdpPacketsSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketsSent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.UdpPacketReceiveErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketReceiveErrors))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.UdpPacketsToUnknownPortReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketsToUnknownPortReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.UdpPacketsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketsReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TcpResetsSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpResetsSent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.TcpBadSegmentsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpBadSegmentsReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TcpSegmentsRetransmitted != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSegmentsRetransmitted))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TcpSegmentsSendOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSegmentsSendOut))
		i--
		dAtA[i] = 0x78
	}
	if m.TcpSegmentsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSegmentsReceived))
		i--
		dAtA[i] = 0x70
	}
	if m.TcpConnectionsEstablished != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpConnectionsEstablished))
		i--
		dAtA[i] = 0x68
	}
	if m.TcpConnectionResetsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpConnectionResetsReceived))
		i--
		dAtA[i] = 0x60
	}
	if m.TcpFailedConnectionAttempts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFailedConnectionAttempts))
		i--
		dAtA[i] = 0x58
	}
	if m.TcpPassiveConnectionOpenings != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPassiveConnectionOpenings))
		i--
		dAtA[i] = 0x50
	}
	if m.TcpActiveConnectionsOpenings != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpActiveConnectionsOpenings))
		i--
		dAtA[i] = 0x48
	}
	if m.IpOutgoingPacketsDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutgoingPacketsDropped))
		i--
		dAtA[i] = 0x40
	}
	if m.IpRequestsSentOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpRequestsSentOut))
		i--
		dAtA[i] = 0x38
	}
	if m.IpIncomingPacketsDelivered != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpIncomingPacketsDelivered))
		i--
		dAtA[i] = 0x30
	}
	if m.IpIncomingPacketsDiscarded != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpIncomingPacketsDiscarded))
		i--
		dAtA[i] = 0x28
	}
	if m.IpForwarded != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpForwarded))
		i--
		dAtA[i] = 0x20
	}
	if m.IpTotalPacketsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpTotalPacketsReceived))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTcpmon(dAtA []byte, offset int, v uint64) int {
	offset -= sovTcpmon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	return n
}

func (m *Metric_Tcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *Metric_Nic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nic != nil {
		l = m.Nic.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *Metric_Net) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Net != nil {
		l = m.Net.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *SocketMemoryUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RmemAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.RmemAlloc))
	}
	if m.RcvBuf != 0 {
		n += 1 + sovTcpmon(uint64(m.RcvBuf))
	}
	if m.WmemAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.WmemAlloc))
	}
	if m.SndBuf != 0 {
		n += 1 + sovTcpmon(uint64(m.SndBuf))
	}
	if m.FwdAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.FwdAlloc))
	}
	if m.WmemQueued != 0 {
		n += 1 + sovTcpmon(uint64(m.WmemQueued))
	}
	if m.OptMem != 0 {
		n += 1 + sovTcpmon(uint64(m.OptMem))
	}
	if m.BackLog != 0 {
		n += 1 + sovTcpmon(uint64(m.BackLog))
	}
	if m.SockDrop != 0 {
		n += 1 + sovTcpmon(uint64(m.SockDrop))
	}
	return n
}

func (m *TimerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.ExpireTimeUs != 0 {
		n += 1 + sovTcpmon(uint64(m.ExpireTimeUs))
	}
	if m.Retrans != 0 {
		n += 1 + sovTcpmon(uint64(m.Retrans))
	}
	return n
}

func (m *ProcessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovTcpmon(uint64(m.Pid))
	}
	if m.Fd != 0 {
		n += 1 + sovTcpmon(uint64(m.Fd))
	}
	return n
}

func (m *SocketMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovTcpmon(uint64(m.State))
	}
	if m.RecvQ != 0 {
		n += 1 + sovTcpmon(uint64(m.RecvQ))
	}
	if m.SendQ != 0 {
		n += 1 + sovTcpmon(uint64(m.SendQ))
	}
	l = len(m.LocalAddr)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	l = len(m.PeerAddr)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	if len(m.Timers) > 0 {
		for _, e := range m.Timers {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	if m.Skmem != nil {
		l = m.Skmem.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.Ts {
		n += 2
	}
	if m.Sack {
		n += 2
	}
	if m.Cubic {
		n += 2
	}
	if m.AppLimited {
		n += 2
	}
	if m.PacingRate != 0 {
		n += 9
	}
	if m.DeliveryRate != 0 {
		n += 10
	}
	if m.Send != 0 {
		n += 10
	}
	if m.SndWscale != 0 {
		n += 2 + sovTcpmon(uint64(m.SndWscale))
	}
	if m.RcvWscale != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvWscale))
	}
	if m.Rto != 0 {
		n += 10
	}
	if m.Rtt != 0 {
		n += 10
	}
	if m.Rttvar != 0 {
		n += 10
	}
	if m.Minrtt != 0 {
		n += 10
	}
	if m.RcvRtt != 0 {
		n += 10
	}
	if m.RetransNow != 0 {
		n += 2 + sovTcpmon(uint64(m.RetransNow))
	}
	if m.RetransTotal != 0 {
		n += 2 + sovTcpmon(uint64(m.RetransTotal))
	}
	if m.Ato != 0 {
		n += 10
	}
	if m.Mss != 0 {
		n += 2 + sovTcpmon(uint64(m.Mss))
	}
	if m.Pmtu != 0 {
		n += 2 + sovTcpmon(uint64(m.Pmtu))
	}
	if m.Rcvmss != 0 {
		n += 2 + sovTcpmon(uint64(m.Rcvmss))
	}
	if m.Advmss != 0 {
		n += 2 + sovTcpmon(uint64(m.Advmss))
	}
	if m.Cwnd != 0 {
		n += 2 + sovTcpmon(uint64(m.Cwnd))
	}
	if m.SndWnd != 0 {
		n += 2 + sovTcpmon(uint64(m.SndWnd))
	}
	if m.BytesSent != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesSent))
	}
	if m.BytesAcked != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesAcked))
	}
	if m.BytesReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesReceived))
	}
	if m.SegsOut != 0 {
		n += 2 + sovTcpmon(uint64(m.SegsOut))
	}
	if m.SegsIn != 0 {
		n += 2 + sovTcpmon(uint64(m.SegsIn))
	}
	if m.Lastsnd != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastsnd))
	}
	if m.Lastrcv != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastrcv))
	}
	if m.Lastack != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastack))
	}
	if m.Delivered != 0 {
		n += 2 + sovTcpmon(uint64(m.Delivered))
	}
	if m.BusyMs != 0 {
		n += 2 + sovTcpmon(uint64(m.BusyMs))
	}
	if m.RcvSpace != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvSpace))
	}
	if m.RcvSsthresh != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvSsthresh))
	}
	if m.DataSegsOut != 0 {
		n += 2 + sovTcpmon(uint64(m.DataSegsOut))
	}
	if m.DataSegsIn != 0 {
		n += 2 + sovTcpmon(uint64(m.DataSegsIn))
	}
	if m.RwndLimited != 0 {
		n += 2 + sovTcpmon(uint64(m.RwndLimited))
	}
	if m.SndbufLimited != 0 {
		n += 2 + sovTcpmon(uint64(m.SndbufLimited))
	}
	if m.Ecn {
		n += 3
	}
	if m.Ecnseen {
		n += 3
	}
	return n
}

func (m *TcpMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if len(m.Sockets) > 0 {
		for _, e := range m.Sockets {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	return n
}

func (m *IfaceMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.RxErrors != 0 {
		n += 1 + sovTcpmon(uint64(m.RxErrors))
	}
	if m.RxDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.RxDropped))
	}
	if m.RxOverruns != 0 {
		n += 1 + sovTcpmon(uint64(m.RxOverruns))
	}
	if m.RxFrame != 0 {
		n += 1 + sovTcpmon(uint64(m.RxFrame))
	}
	if m.TxErrors != 0 {
		n += 1 + sovTcpmon(uint64(m.TxErrors))
	}
	if m.TxDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.TxDropped))
	}
	if m.TxOverruns != 0 {
		n += 1 + sovTcpmon(uint64(m.TxOverruns))
	}
	if m.TxCarrier != 0 {
		n += 1 + sovTcpmon(uint64(m.TxCarrier))
	}
	if m.TxCollisions != 0 {
		n += 1 + sovTcpmon(uint64(m.TxCollisions))
	}
	return n
}

func (m *NicMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if len(m.Ifaces) > 0 {
		for _, e := range m.Ifaces {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	return n
}

func (m *NetstatMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if m.IpTotalPacketsReceived != 0 {
		n += 1 + sovTcpmon(uint64(m.IpTotalPacketsReceived))
	}
	if m.IpForwarded != 0 {
		n += 1 + sovTcpmon(uint64(m.IpForwarded))
	}
	if m.IpIncomingPacketsDiscarded != 0 {
		n += 1 + sovTcpmon(uint64(m.IpIncomingPacketsDiscarded))
	}
	if m.IpIncomingPacketsDelivered != 0 {
		n += 1 + sovTcpmon(uint64(m.IpIncomingPacketsDelivered))
	}
	if m.IpRequestsSentOut != 0 {
		n += 1 + sovTcpmon(uint64(m.IpRequestsSentOut))
	}
	if m.IpOutgoingPacketsDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.IpOutgoingPacketsDropped))
	}
	if m.TcpActiveConnectionsOpenings != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpActiveConnectionsOpenings))
	}
	if m.TcpPassiveConnectionOpenings != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpPassiveConnectionOpenings))
	}
	if m.TcpFailedConnectionAttempts != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpFailedConnectionAttempts))
	}
	if m.TcpConnectionResetsReceived != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpConnectionResetsReceived))
	}
	if m.TcpConnectionsEstablished != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpConnectionsEstablished))
	}
	if m.TcpSegmentsReceived != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpSegmentsReceived))
	}
	if m.TcpSegmentsSendOut != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpSegmentsSendOut))
	}
	if m.TcpSegmentsRetransmitted != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSegmentsRetransmitted))
	}
	if m.TcpBadSegmentsReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpBadSegmentsReceived))
	}
	if m.TcpResetsSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpResetsSent))
	}
	if m.UdpPacketsReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketsReceived))
	}
	if m.UdpPacketsToUnknownPortReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketsToUnknownPortReceived))
	}
	if m.UdpPacketReceiveErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketReceiveErrors))
	}
	if m.UdpPacketsSent != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketsSent))
	}
	if m.UdpReceiveBufferErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpReceiveBufferErrors))
	}
	if m.UdpSendBufferErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpSendBufferErrors))
	}
	return n
}

func sovTcpmon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTcpmon(x uint64) (n int) {
	return sovTcpmon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Tcp{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NicMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Nic{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetstatMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Net{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocketMemoryUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocketMemoryUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocketMemoryUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RmemAlloc", wireType)
			}
			m.RmemAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RmemAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvBuf", wireType)
			}
			m.RcvBuf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvBuf |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WmemAlloc", wireType)
			}
			m.WmemAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WmemAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndBuf", wireType)
			}
			m.SndBuf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndBuf |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdAlloc", wireType)
			}
			m.FwdAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WmemQueued", wireType)
			}
			m.WmemQueued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WmemQueued |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptMem", wireType)
			}
			m.OptMem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptMem |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackLog", wireType)
			}
			m.BackLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackLog |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SockDrop", wireType)
			}
			m.SockDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SockDrop |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTimeUs", wireType)
			}
			m.ExpireTimeUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTimeUs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retrans", wireType)
			}
			m.Retrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retrans |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fd", wireType)
			}
			m.Fd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocketMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocketMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocketMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SocketState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvQ", wireType)
			}
			m.RecvQ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvQ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendQ", wireType)
			}
			m.SendQ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendQ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &ProcessInfo{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timers = append(m.Timers, &TimerInfo{})
			if err := m.Timers[len(m.Timers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skmem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skmem == nil {
				m.Skmem = &SocketMemoryUsage{}
			}
			if err := m.Skmem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ts = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sack = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cubic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cubic = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppLimited = bool(v != 0)
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacingRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PacingRate = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeliveryRate = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Send = float64(math.Float64frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWscale", wireType)
			}
			m.SndWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWscale", wireType)
			}
			m.RcvWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rto", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rto = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rtt = float64(math.Float64frombits(v))
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rttvar", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rttvar = float64(math.Float64frombits(v))
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minrtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minrtt = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvRtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RcvRtt = float64(math.Float64frombits(v))
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransNow", wireType)
			}
			m.RetransNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransNow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransTotal", wireType)
			}
			m.RetransTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransTotal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ato", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ato = float64(math.Float64frombits(v))
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mss", wireType)
			}
			m.Mss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmtu", wireType)
			}
			m.Pmtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rcvmss", wireType)
			}
			m.Rcvmss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rcvmss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advmss", wireType)
			}
			m.Advmss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Advmss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwnd", wireType)
			}
			m.Cwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cwnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWnd", wireType)
			}
			m.SndWnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSent", wireType)
			}
			m.BytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesSent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesAcked", wireType)
			}
			m.BytesAcked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesAcked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesReceived", wireType)
			}
			m.BytesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegsOut", wireType)
			}
			m.SegsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegsIn", wireType)
			}
			m.SegsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegsIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastsnd", wireType)
			}
			m.Lastsnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastsnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastrcv", wireType)
			}
			m.Lastrcv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastrcv |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastack", wireType)
			}
			m.Lastack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastack |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delivered", wireType)
			}
			m.Delivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delivered |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusyMs", wireType)
			}
			m.BusyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusyMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvSpace", wireType)
			}
			m.RcvSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvSpace |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvSsthresh", wireType)
			}
			m.RcvSsthresh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvSsthresh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSegsOut", wireType)
			}
			m.DataSegsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSegsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSegsIn", wireType)
			}
			m.DataSegsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSegsIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwndLimited", wireType)
			}
			m.RwndLimited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RwndLimited |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndbufLimited", wireType)
			}
			m.SndbufLimited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndbufLimited |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ecn = bool(v != 0)
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecnseen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ecnseen = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sockets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sockets = append(m.Sockets, &SocketMetric{})
			if err := m.Sockets[len(m.Sockets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IfaceMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IfaceMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IfaceMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxErrors", wireType)
			}
			m.RxErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDropped", wireType)
			}
			m.RxDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOverruns", wireType)
			}
			m.RxOverruns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOverruns |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxFrame", wireType)
			}
			m.RxFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxFrame |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxErrors", wireType)
			}
			m.TxErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDropped", wireType)
			}
			m.TxDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOverruns", wireType)
			}
			m.TxOverruns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOverruns |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCarrier", wireType)
			}
			m.TxCarrier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCarrier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCollisions", wireType)
			}
			m.TxCollisions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCollisions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NicMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NicMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NicMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifaces = append(m.Ifaces, &IfaceMetric{})
			if err := m.Ifaces[len(m.Ifaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetstatMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetstatMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetstatMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTotalPacketsReceived", wireType)
			}
			m.IpTotalPacketsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpTotalPacketsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpForwarded", wireType)
			}
			m.IpForwarded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpForwarded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpIncomingPacketsDiscarded", wireType)
			}
			m.IpIncomingPacketsDiscarded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpIncomingPacketsDiscarded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpIncomingPacketsDelivered", wireType)
			}
			m.IpIncomingPacketsDelivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpIncomingPacketsDelivered |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRequestsSentOut", wireType)
			}
			m.IpRequestsSentOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpRequestsSentOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutgoingPacketsDropped", wireType)
			}
			m.IpOutgoingPacketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutgoingPacketsDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpActiveConnectionsOpenings", wireType)
			}
			m.TcpActiveConnectionsOpenings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpActiveConnectionsOpenings |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPassiveConnectionOpenings", wireType)
			}
			m.TcpPassiveConnectionOpenings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPassiveConnectionOpenings |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFailedConnectionAttempts", wireType)
			}
			m.TcpFailedConnectionAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFailedConnectionAttempts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpConnectionResetsReceived", wireType)
			}
			m.TcpConnectionResetsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpConnectionResetsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpConnectionsEstablished", wireType)
			}
			m.TcpConnectionsEstablished = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpConnectionsEstablished |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSegmentsReceived", wireType)
			}
			m.TcpSegmentsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSegmentsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSegmentsSendOut", wireType)
			}
			m.TcpSegmentsSendOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSegmentsSendOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSegmentsRetransmitted", wireType)
			}
			m.TcpSegmentsRetransmitted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSegmentsRetransmitted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpBadSegmentsReceived", wireType)
			}
			m.TcpBadSegmentsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpBadSegmentsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpResetsSent", wireType)
			}
			m.TcpResetsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpResetsSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketsReceived", wireType)
			}
			m.UdpPacketsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketsToUnknownPortReceived", wireType)
			}
			m.UdpPacketsToUnknownPortReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketsToUnknownPortReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketReceiveErrors", wireType)
			}
			m.UdpPacketReceiveErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketReceiveErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketsSent", wireType)
			}
			m.UdpPacketsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketsSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpReceiveBufferErrors", wireType)
			}
			m.UdpReceiveBufferErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpReceiveBufferErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSendBufferErrors", wireType)
			}
			m.UdpSendBufferErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpSendBufferErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTcpmon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTcpmon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTcpmon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTcpmon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTcpmon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTcpmon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTcpmon = fmt.Errorf("proto: unexpected end of group")
)
