// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tcpmon.proto

package tcpmon

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MetricType int32

const (
	MetricType_TCP MetricType = 0
	MetricType_NIC MetricType = 1
	MetricType_NET MetricType = 2
)

var MetricType_name = map[int32]string{
	0: "TCP",
	1: "NIC",
	2: "NET",
}

var MetricType_value = map[string]int32{
	"TCP": 0,
	"NIC": 1,
	"NET": 2,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}

func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{0}
}

// from linux/include/net/tcp_states.h
type SocketState int32

const (
	SocketState_TCP_ESTABLISHED  SocketState = 0
	SocketState_TCP_SYN_SENT     SocketState = 1
	SocketState_TCP_SYN_RECV     SocketState = 2
	SocketState_TCP_FIN_WAIT1    SocketState = 3
	SocketState_TCP_FIN_WAIT2    SocketState = 4
	SocketState_TCP_TIME_WAIT    SocketState = 5
	SocketState_TCP_CLOSE        SocketState = 6
	SocketState_TCP_CLOSE_WAIT   SocketState = 7
	SocketState_TCP_LAST_ACK     SocketState = 8
	SocketState_TCP_LISTEN       SocketState = 9
	SocketState_TCP_CLOSING      SocketState = 10
	SocketState_TCP_NEW_SYN_RECV SocketState = 11
)

var SocketState_name = map[int32]string{
	0:  "TCP_ESTABLISHED",
	1:  "TCP_SYN_SENT",
	2:  "TCP_SYN_RECV",
	3:  "TCP_FIN_WAIT1",
	4:  "TCP_FIN_WAIT2",
	5:  "TCP_TIME_WAIT",
	6:  "TCP_CLOSE",
	7:  "TCP_CLOSE_WAIT",
	8:  "TCP_LAST_ACK",
	9:  "TCP_LISTEN",
	10: "TCP_CLOSING",
	11: "TCP_NEW_SYN_RECV",
}

var SocketState_value = map[string]int32{
	"TCP_ESTABLISHED":  0,
	"TCP_SYN_SENT":     1,
	"TCP_SYN_RECV":     2,
	"TCP_FIN_WAIT1":    3,
	"TCP_FIN_WAIT2":    4,
	"TCP_TIME_WAIT":    5,
	"TCP_CLOSE":        6,
	"TCP_CLOSE_WAIT":   7,
	"TCP_LAST_ACK":     8,
	"TCP_LISTEN":       9,
	"TCP_CLOSING":      10,
	"TCP_NEW_SYN_RECV": 11,
}

func (x SocketState) String() string {
	return proto.EnumName(SocketState_name, int32(x))
}

func (SocketState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{1}
}

type Metric struct {
	// Types that are valid to be assigned to Body:
	//
	//	*Metric_Tcp
	//	*Metric_Nic
	//	*Metric_Net
	Body isMetric_Body `protobuf_oneof:"body"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{0}
}
func (m *Metric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return m.Size()
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

type isMetric_Body interface {
	isMetric_Body()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Metric_Tcp struct {
	Tcp *TcpMetric `protobuf:"bytes,1,opt,name=tcp,proto3,oneof" json:"tcp,omitempty"`
}
type Metric_Nic struct {
	Nic *NicMetric `protobuf:"bytes,2,opt,name=nic,proto3,oneof" json:"nic,omitempty"`
}
type Metric_Net struct {
	Net *NetstatMetric `protobuf:"bytes,3,opt,name=net,proto3,oneof" json:"net,omitempty"`
}

func (*Metric_Tcp) isMetric_Body() {}
func (*Metric_Nic) isMetric_Body() {}
func (*Metric_Net) isMetric_Body() {}

func (m *Metric) GetBody() isMetric_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Metric) GetTcp() *TcpMetric {
	if x, ok := m.GetBody().(*Metric_Tcp); ok {
		return x.Tcp
	}
	return nil
}

func (m *Metric) GetNic() *NicMetric {
	if x, ok := m.GetBody().(*Metric_Nic); ok {
		return x.Nic
	}
	return nil
}

func (m *Metric) GetNet() *NetstatMetric {
	if x, ok := m.GetBody().(*Metric_Net); ok {
		return x.Net
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Metric) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Metric_Tcp)(nil),
		(*Metric_Nic)(nil),
		(*Metric_Net)(nil),
	}
}

// Socket memory usage. aka skmem
// check: https://man7.org/linux/man-pages/man8/ss.8.html
type SocketMemoryUsage struct {
	RmemAlloc  uint32 `protobuf:"varint,1,opt,name=rmem_alloc,json=rmemAlloc,proto3" json:"rmem_alloc,omitempty"`
	RcvBuf     uint32 `protobuf:"varint,2,opt,name=rcv_buf,json=rcvBuf,proto3" json:"rcv_buf,omitempty"`
	WmemAlloc  uint32 `protobuf:"varint,3,opt,name=wmem_alloc,json=wmemAlloc,proto3" json:"wmem_alloc,omitempty"`
	SndBuf     uint32 `protobuf:"varint,4,opt,name=snd_buf,json=sndBuf,proto3" json:"snd_buf,omitempty"`
	FwdAlloc   uint32 `protobuf:"varint,5,opt,name=fwd_alloc,json=fwdAlloc,proto3" json:"fwd_alloc,omitempty"`
	WmemQueued uint32 `protobuf:"varint,6,opt,name=wmem_queued,json=wmemQueued,proto3" json:"wmem_queued,omitempty"`
	OptMem     uint32 `protobuf:"varint,7,opt,name=opt_mem,json=optMem,proto3" json:"opt_mem,omitempty"`
	BackLog    uint32 `protobuf:"varint,8,opt,name=back_log,json=backLog,proto3" json:"back_log,omitempty"`
	SockDrop   uint32 `protobuf:"varint,9,opt,name=sock_drop,json=sockDrop,proto3" json:"sock_drop,omitempty"`
}

func (m *SocketMemoryUsage) Reset()         { *m = SocketMemoryUsage{} }
func (m *SocketMemoryUsage) String() string { return proto.CompactTextString(m) }
func (*SocketMemoryUsage) ProtoMessage()    {}
func (*SocketMemoryUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{1}
}
func (m *SocketMemoryUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocketMemoryUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocketMemoryUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocketMemoryUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocketMemoryUsage.Merge(m, src)
}
func (m *SocketMemoryUsage) XXX_Size() int {
	return m.Size()
}
func (m *SocketMemoryUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_SocketMemoryUsage.DiscardUnknown(m)
}

var xxx_messageInfo_SocketMemoryUsage proto.InternalMessageInfo

func (m *SocketMemoryUsage) GetRmemAlloc() uint32 {
	if m != nil {
		return m.RmemAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetRcvBuf() uint32 {
	if m != nil {
		return m.RcvBuf
	}
	return 0
}

func (m *SocketMemoryUsage) GetWmemAlloc() uint32 {
	if m != nil {
		return m.WmemAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetSndBuf() uint32 {
	if m != nil {
		return m.SndBuf
	}
	return 0
}

func (m *SocketMemoryUsage) GetFwdAlloc() uint32 {
	if m != nil {
		return m.FwdAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetWmemQueued() uint32 {
	if m != nil {
		return m.WmemQueued
	}
	return 0
}

func (m *SocketMemoryUsage) GetOptMem() uint32 {
	if m != nil {
		return m.OptMem
	}
	return 0
}

func (m *SocketMemoryUsage) GetBackLog() uint32 {
	if m != nil {
		return m.BackLog
	}
	return 0
}

func (m *SocketMemoryUsage) GetSockDrop() uint32 {
	if m != nil {
		return m.SockDrop
	}
	return 0
}

type TimerInfo struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ExpireTimeUs uint64 `protobuf:"varint,2,opt,name=expire_time_us,json=expireTimeUs,proto3" json:"expire_time_us,omitempty"`
	Retrans      uint32 `protobuf:"varint,3,opt,name=retrans,proto3" json:"retrans,omitempty"`
}

func (m *TimerInfo) Reset()         { *m = TimerInfo{} }
func (m *TimerInfo) String() string { return proto.CompactTextString(m) }
func (*TimerInfo) ProtoMessage()    {}
func (*TimerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{2}
}
func (m *TimerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimerInfo.Merge(m, src)
}
func (m *TimerInfo) XXX_Size() int {
	return m.Size()
}
func (m *TimerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TimerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TimerInfo proto.InternalMessageInfo

func (m *TimerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TimerInfo) GetExpireTimeUs() uint64 {
	if m != nil {
		return m.ExpireTimeUs
	}
	return 0
}

func (m *TimerInfo) GetRetrans() uint32 {
	if m != nil {
		return m.Retrans
	}
	return 0
}

type ProcessInfo struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Pid  uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Fd   uint32 `protobuf:"varint,3,opt,name=fd,proto3" json:"fd,omitempty"`
}

func (m *ProcessInfo) Reset()         { *m = ProcessInfo{} }
func (m *ProcessInfo) String() string { return proto.CompactTextString(m) }
func (*ProcessInfo) ProtoMessage()    {}
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{3}
}
func (m *ProcessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInfo.Merge(m, src)
}
func (m *ProcessInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProcessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInfo proto.InternalMessageInfo

func (m *ProcessInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProcessInfo) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ProcessInfo) GetFd() uint32 {
	if m != nil {
		return m.Fd
	}
	return 0
}

type SocketMetric struct {
	State         SocketState        `protobuf:"varint,3,opt,name=state,proto3,enum=SocketState" json:"state,omitempty"`
	RecvQ         uint32             `protobuf:"varint,4,opt,name=recv_q,json=recvQ,proto3" json:"recv_q,omitempty"`
	SendQ         int64              `protobuf:"varint,5,opt,name=send_q,json=sendQ,proto3" json:"send_q,omitempty"`
	LocalAddr     string             `protobuf:"bytes,6,opt,name=local_addr,json=localAddr,proto3" json:"local_addr,omitempty"`
	PeerAddr      string             `protobuf:"bytes,7,opt,name=peer_addr,json=peerAddr,proto3" json:"peer_addr,omitempty"`
	Processes     []*ProcessInfo     `protobuf:"bytes,8,rep,name=processes,proto3" json:"processes,omitempty"`
	Timers        []*TimerInfo       `protobuf:"bytes,9,rep,name=timers,proto3" json:"timers,omitempty"`
	Skmem         *SocketMemoryUsage `protobuf:"bytes,10,opt,name=skmem,proto3" json:"skmem,omitempty"`
	Ts            bool               `protobuf:"varint,11,opt,name=ts,proto3" json:"ts,omitempty"`
	Sack          bool               `protobuf:"varint,12,opt,name=sack,proto3" json:"sack,omitempty"`
	Cubic         bool               `protobuf:"varint,13,opt,name=cubic,proto3" json:"cubic,omitempty"`
	AppLimited    bool               `protobuf:"varint,14,opt,name=app_limited,json=appLimited,proto3" json:"app_limited,omitempty"`
	PacingRate    float64            `protobuf:"fixed64,15,opt,name=pacing_rate,json=pacingRate,proto3" json:"pacing_rate,omitempty"`
	DeliveryRate  float64            `protobuf:"fixed64,16,opt,name=delivery_rate,json=deliveryRate,proto3" json:"delivery_rate,omitempty"`
	Send          float64            `protobuf:"fixed64,17,opt,name=send,proto3" json:"send,omitempty"`
	SndWscale     uint32             `protobuf:"varint,18,opt,name=snd_wscale,json=sndWscale,proto3" json:"snd_wscale,omitempty"`
	RcvWscale     uint32             `protobuf:"varint,19,opt,name=rcv_wscale,json=rcvWscale,proto3" json:"rcv_wscale,omitempty"`
	Rto           float64            `protobuf:"fixed64,20,opt,name=rto,proto3" json:"rto,omitempty"`
	Rtt           float64            `protobuf:"fixed64,21,opt,name=rtt,proto3" json:"rtt,omitempty"`
	Rttvar        float64            `protobuf:"fixed64,22,opt,name=rttvar,proto3" json:"rttvar,omitempty"`
	Minrtt        float64            `protobuf:"fixed64,23,opt,name=minrtt,proto3" json:"minrtt,omitempty"`
	RcvRtt        float64            `protobuf:"fixed64,24,opt,name=rcv_rtt,json=rcvRtt,proto3" json:"rcv_rtt,omitempty"`
	RetransNow    uint32             `protobuf:"varint,25,opt,name=retrans_now,json=retransNow,proto3" json:"retrans_now,omitempty"`
	RetransTotal  uint32             `protobuf:"varint,26,opt,name=retrans_total,json=retransTotal,proto3" json:"retrans_total,omitempty"`
	Ato           float64            `protobuf:"fixed64,30,opt,name=ato,proto3" json:"ato,omitempty"`
	Mss           uint32             `protobuf:"varint,31,opt,name=mss,proto3" json:"mss,omitempty"`
	Pmtu          uint32             `protobuf:"varint,32,opt,name=pmtu,proto3" json:"pmtu,omitempty"`
	Rcvmss        uint32             `protobuf:"varint,33,opt,name=rcvmss,proto3" json:"rcvmss,omitempty"`
	Advmss        uint32             `protobuf:"varint,34,opt,name=advmss,proto3" json:"advmss,omitempty"`
	Cwnd          uint32             `protobuf:"varint,35,opt,name=cwnd,proto3" json:"cwnd,omitempty"`
	SndWnd        uint32             `protobuf:"varint,36,opt,name=snd_wnd,json=sndWnd,proto3" json:"snd_wnd,omitempty"`
	BytesSent     uint32             `protobuf:"varint,37,opt,name=bytes_sent,json=bytesSent,proto3" json:"bytes_sent,omitempty"`
	BytesAcked    uint64             `protobuf:"varint,38,opt,name=bytes_acked,json=bytesAcked,proto3" json:"bytes_acked,omitempty"`
	BytesReceived uint64             `protobuf:"varint,39,opt,name=bytes_received,json=bytesReceived,proto3" json:"bytes_received,omitempty"`
	SegsOut       uint32             `protobuf:"varint,40,opt,name=segs_out,json=segsOut,proto3" json:"segs_out,omitempty"`
	SegsIn        uint32             `protobuf:"varint,41,opt,name=segs_in,json=segsIn,proto3" json:"segs_in,omitempty"`
	Lastsnd       uint32             `protobuf:"varint,42,opt,name=lastsnd,proto3" json:"lastsnd,omitempty"`
	Lastrcv       uint32             `protobuf:"varint,43,opt,name=lastrcv,proto3" json:"lastrcv,omitempty"`
	Lastack       uint32             `protobuf:"varint,44,opt,name=lastack,proto3" json:"lastack,omitempty"`
	Delivered     uint32             `protobuf:"varint,45,opt,name=delivered,proto3" json:"delivered,omitempty"`
	BusyMs        uint32             `protobuf:"varint,46,opt,name=busy_ms,json=busyMs,proto3" json:"busy_ms,omitempty"`
	RcvSpace      uint32             `protobuf:"varint,47,opt,name=rcv_space,json=rcvSpace,proto3" json:"rcv_space,omitempty"`
	RcvSsthresh   uint32             `protobuf:"varint,48,opt,name=rcv_ssthresh,json=rcvSsthresh,proto3" json:"rcv_ssthresh,omitempty"`
	DataSegsOut   uint32             `protobuf:"varint,49,opt,name=data_segs_out,json=dataSegsOut,proto3" json:"data_segs_out,omitempty"`
	DataSegsIn    uint32             `protobuf:"varint,50,opt,name=data_segs_in,json=dataSegsIn,proto3" json:"data_segs_in,omitempty"`
	RwndLimited   uint32             `protobuf:"varint,51,opt,name=rwnd_limited,json=rwndLimited,proto3" json:"rwnd_limited,omitempty"`
	SndbufLimited uint32             `protobuf:"varint,52,opt,name=sndbuf_limited,json=sndbufLimited,proto3" json:"sndbuf_limited,omitempty"`
	Ecn           bool               `protobuf:"varint,53,opt,name=ecn,proto3" json:"ecn,omitempty"`
	Ecnseen       bool               `protobuf:"varint,54,opt,name=ecnseen,proto3" json:"ecnseen,omitempty"`
}

func (m *SocketMetric) Reset()         { *m = SocketMetric{} }
func (m *SocketMetric) String() string { return proto.CompactTextString(m) }
func (*SocketMetric) ProtoMessage()    {}
func (*SocketMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{4}
}
func (m *SocketMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocketMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocketMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocketMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocketMetric.Merge(m, src)
}
func (m *SocketMetric) XXX_Size() int {
	return m.Size()
}
func (m *SocketMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_SocketMetric.DiscardUnknown(m)
}

var xxx_messageInfo_SocketMetric proto.InternalMessageInfo

func (m *SocketMetric) GetState() SocketState {
	if m != nil {
		return m.State
	}
	return SocketState_TCP_ESTABLISHED
}

func (m *SocketMetric) GetRecvQ() uint32 {
	if m != nil {
		return m.RecvQ
	}
	return 0
}

func (m *SocketMetric) GetSendQ() int64 {
	if m != nil {
		return m.SendQ
	}
	return 0
}

func (m *SocketMetric) GetLocalAddr() string {
	if m != nil {
		return m.LocalAddr
	}
	return ""
}

func (m *SocketMetric) GetPeerAddr() string {
	if m != nil {
		return m.PeerAddr
	}
	return ""
}

func (m *SocketMetric) GetProcesses() []*ProcessInfo {
	if m != nil {
		return m.Processes
	}
	return nil
}

func (m *SocketMetric) GetTimers() []*TimerInfo {
	if m != nil {
		return m.Timers
	}
	return nil
}

func (m *SocketMetric) GetSkmem() *SocketMemoryUsage {
	if m != nil {
		return m.Skmem
	}
	return nil
}

func (m *SocketMetric) GetTs() bool {
	if m != nil {
		return m.Ts
	}
	return false
}

func (m *SocketMetric) GetSack() bool {
	if m != nil {
		return m.Sack
	}
	return false
}

func (m *SocketMetric) GetCubic() bool {
	if m != nil {
		return m.Cubic
	}
	return false
}

func (m *SocketMetric) GetAppLimited() bool {
	if m != nil {
		return m.AppLimited
	}
	return false
}

func (m *SocketMetric) GetPacingRate() float64 {
	if m != nil {
		return m.PacingRate
	}
	return 0
}

func (m *SocketMetric) GetDeliveryRate() float64 {
	if m != nil {
		return m.DeliveryRate
	}
	return 0
}

func (m *SocketMetric) GetSend() float64 {
	if m != nil {
		return m.Send
	}
	return 0
}

func (m *SocketMetric) GetSndWscale() uint32 {
	if m != nil {
		return m.SndWscale
	}
	return 0
}

func (m *SocketMetric) GetRcvWscale() uint32 {
	if m != nil {
		return m.RcvWscale
	}
	return 0
}

func (m *SocketMetric) GetRto() float64 {
	if m != nil {
		return m.Rto
	}
	return 0
}

func (m *SocketMetric) GetRtt() float64 {
	if m != nil {
		return m.Rtt
	}
	return 0
}

func (m *SocketMetric) GetRttvar() float64 {
	if m != nil {
		return m.Rttvar
	}
	return 0
}

func (m *SocketMetric) GetMinrtt() float64 {
	if m != nil {
		return m.Minrtt
	}
	return 0
}

func (m *SocketMetric) GetRcvRtt() float64 {
	if m != nil {
		return m.RcvRtt
	}
	return 0
}

func (m *SocketMetric) GetRetransNow() uint32 {
	if m != nil {
		return m.RetransNow
	}
	return 0
}

func (m *SocketMetric) GetRetransTotal() uint32 {
	if m != nil {
		return m.RetransTotal
	}
	return 0
}

func (m *SocketMetric) GetAto() float64 {
	if m != nil {
		return m.Ato
	}
	return 0
}

func (m *SocketMetric) GetMss() uint32 {
	if m != nil {
		return m.Mss
	}
	return 0
}

func (m *SocketMetric) GetPmtu() uint32 {
	if m != nil {
		return m.Pmtu
	}
	return 0
}

func (m *SocketMetric) GetRcvmss() uint32 {
	if m != nil {
		return m.Rcvmss
	}
	return 0
}

func (m *SocketMetric) GetAdvmss() uint32 {
	if m != nil {
		return m.Advmss
	}
	return 0
}

func (m *SocketMetric) GetCwnd() uint32 {
	if m != nil {
		return m.Cwnd
	}
	return 0
}

func (m *SocketMetric) GetSndWnd() uint32 {
	if m != nil {
		return m.SndWnd
	}
	return 0
}

func (m *SocketMetric) GetBytesSent() uint32 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *SocketMetric) GetBytesAcked() uint64 {
	if m != nil {
		return m.BytesAcked
	}
	return 0
}

func (m *SocketMetric) GetBytesReceived() uint64 {
	if m != nil {
		return m.BytesReceived
	}
	return 0
}

func (m *SocketMetric) GetSegsOut() uint32 {
	if m != nil {
		return m.SegsOut
	}
	return 0
}

func (m *SocketMetric) GetSegsIn() uint32 {
	if m != nil {
		return m.SegsIn
	}
	return 0
}

func (m *SocketMetric) GetLastsnd() uint32 {
	if m != nil {
		return m.Lastsnd
	}
	return 0
}

func (m *SocketMetric) GetLastrcv() uint32 {
	if m != nil {
		return m.Lastrcv
	}
	return 0
}

func (m *SocketMetric) GetLastack() uint32 {
	if m != nil {
		return m.Lastack
	}
	return 0
}

func (m *SocketMetric) GetDelivered() uint32 {
	if m != nil {
		return m.Delivered
	}
	return 0
}

func (m *SocketMetric) GetBusyMs() uint32 {
	if m != nil {
		return m.BusyMs
	}
	return 0
}

func (m *SocketMetric) GetRcvSpace() uint32 {
	if m != nil {
		return m.RcvSpace
	}
	return 0
}

func (m *SocketMetric) GetRcvSsthresh() uint32 {
	if m != nil {
		return m.RcvSsthresh
	}
	return 0
}

func (m *SocketMetric) GetDataSegsOut() uint32 {
	if m != nil {
		return m.DataSegsOut
	}
	return 0
}

func (m *SocketMetric) GetDataSegsIn() uint32 {
	if m != nil {
		return m.DataSegsIn
	}
	return 0
}

func (m *SocketMetric) GetRwndLimited() uint32 {
	if m != nil {
		return m.RwndLimited
	}
	return 0
}

func (m *SocketMetric) GetSndbufLimited() uint32 {
	if m != nil {
		return m.SndbufLimited
	}
	return 0
}

func (m *SocketMetric) GetEcn() bool {
	if m != nil {
		return m.Ecn
	}
	return false
}

func (m *SocketMetric) GetEcnseen() bool {
	if m != nil {
		return m.Ecnseen
	}
	return false
}

type TcpMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	Sockets []*SocketMetric `protobuf:"bytes,3,rep,name=sockets,proto3" json:"sockets,omitempty"`
}

func (m *TcpMetric) Reset()         { *m = TcpMetric{} }
func (m *TcpMetric) String() string { return proto.CompactTextString(m) }
func (*TcpMetric) ProtoMessage()    {}
func (*TcpMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{5}
}
func (m *TcpMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpMetric.Merge(m, src)
}
func (m *TcpMetric) XXX_Size() int {
	return m.Size()
}
func (m *TcpMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpMetric.DiscardUnknown(m)
}

var xxx_messageInfo_TcpMetric proto.InternalMessageInfo

func (m *TcpMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TcpMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *TcpMetric) GetSockets() []*SocketMetric {
	if m != nil {
		return m.Sockets
	}
	return nil
}

type IfaceMetric struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RxErrors     uint64 `protobuf:"varint,2,opt,name=rx_errors,json=rxErrors,proto3" json:"rx_errors,omitempty"`
	RxDropped    uint64 `protobuf:"varint,3,opt,name=rx_dropped,json=rxDropped,proto3" json:"rx_dropped,omitempty"`
	RxOverruns   uint64 `protobuf:"varint,4,opt,name=rx_overruns,json=rxOverruns,proto3" json:"rx_overruns,omitempty"`
	RxFrame      uint64 `protobuf:"varint,5,opt,name=rx_frame,json=rxFrame,proto3" json:"rx_frame,omitempty"`
	TxErrors     uint64 `protobuf:"varint,6,opt,name=tx_errors,json=txErrors,proto3" json:"tx_errors,omitempty"`
	TxDropped    uint64 `protobuf:"varint,7,opt,name=tx_dropped,json=txDropped,proto3" json:"tx_dropped,omitempty"`
	TxOverruns   uint64 `protobuf:"varint,8,opt,name=tx_overruns,json=txOverruns,proto3" json:"tx_overruns,omitempty"`
	TxCarrier    uint64 `protobuf:"varint,9,opt,name=tx_carrier,json=txCarrier,proto3" json:"tx_carrier,omitempty"`
	TxCollisions uint64 `protobuf:"varint,10,opt,name=tx_collisions,json=txCollisions,proto3" json:"tx_collisions,omitempty"`
}

func (m *IfaceMetric) Reset()         { *m = IfaceMetric{} }
func (m *IfaceMetric) String() string { return proto.CompactTextString(m) }
func (*IfaceMetric) ProtoMessage()    {}
func (*IfaceMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{6}
}
func (m *IfaceMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IfaceMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IfaceMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IfaceMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IfaceMetric.Merge(m, src)
}
func (m *IfaceMetric) XXX_Size() int {
	return m.Size()
}
func (m *IfaceMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_IfaceMetric.DiscardUnknown(m)
}

var xxx_messageInfo_IfaceMetric proto.InternalMessageInfo

func (m *IfaceMetric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IfaceMetric) GetRxErrors() uint64 {
	if m != nil {
		return m.RxErrors
	}
	return 0
}

func (m *IfaceMetric) GetRxDropped() uint64 {
	if m != nil {
		return m.RxDropped
	}
	return 0
}

func (m *IfaceMetric) GetRxOverruns() uint64 {
	if m != nil {
		return m.RxOverruns
	}
	return 0
}

func (m *IfaceMetric) GetRxFrame() uint64 {
	if m != nil {
		return m.RxFrame
	}
	return 0
}

func (m *IfaceMetric) GetTxErrors() uint64 {
	if m != nil {
		return m.TxErrors
	}
	return 0
}

func (m *IfaceMetric) GetTxDropped() uint64 {
	if m != nil {
		return m.TxDropped
	}
	return 0
}

func (m *IfaceMetric) GetTxOverruns() uint64 {
	if m != nil {
		return m.TxOverruns
	}
	return 0
}

func (m *IfaceMetric) GetTxCarrier() uint64 {
	if m != nil {
		return m.TxCarrier
	}
	return 0
}

func (m *IfaceMetric) GetTxCollisions() uint64 {
	if m != nil {
		return m.TxCollisions
	}
	return 0
}

type NicMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	Ifaces []*IfaceMetric `protobuf:"bytes,3,rep,name=ifaces,proto3" json:"ifaces,omitempty"`
}

func (m *NicMetric) Reset()         { *m = NicMetric{} }
func (m *NicMetric) String() string { return proto.CompactTextString(m) }
func (*NicMetric) ProtoMessage()    {}
func (*NicMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{7}
}
func (m *NicMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NicMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NicMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NicMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NicMetric.Merge(m, src)
}
func (m *NicMetric) XXX_Size() int {
	return m.Size()
}
func (m *NicMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_NicMetric.DiscardUnknown(m)
}

var xxx_messageInfo_NicMetric proto.InternalMessageInfo

func (m *NicMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NicMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *NicMetric) GetIfaces() []*IfaceMetric {
	if m != nil {
		return m.Ifaces
	}
	return nil
}

type NetstatMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	// Ip
	IpTotalPacketsReceived         uint64 `protobuf:"varint,3,opt,name=ip_total_packets_received,json=ipTotalPacketsReceived,proto3" json:"ip_total_packets_received,omitempty"`
	IpForwarded                    uint64 `protobuf:"varint,4,opt,name=ip_forwarded,json=ipForwarded,proto3" json:"ip_forwarded,omitempty"`
	IpIncomingPacketsDiscarded     uint64 `protobuf:"varint,5,opt,name=ip_incoming_packets_discarded,json=ipIncomingPacketsDiscarded,proto3" json:"ip_incoming_packets_discarded,omitempty"`
	IpIncomingPacketsDelivered     uint64 `protobuf:"varint,6,opt,name=ip_incoming_packets_delivered,json=ipIncomingPacketsDelivered,proto3" json:"ip_incoming_packets_delivered,omitempty"`
	IpRequestsSentOut              uint64 `protobuf:"varint,7,opt,name=ip_requests_sent_out,json=ipRequestsSentOut,proto3" json:"ip_requests_sent_out,omitempty"`
	IpOutgoingPacketsDropped       uint64 `protobuf:"varint,8,opt,name=ip_outgoing_packets_dropped,json=ipOutgoingPacketsDropped,proto3" json:"ip_outgoing_packets_dropped,omitempty"`
	IpDroppedBecauseOfMissingRoute uint64 `protobuf:"varint,9,opt,name=ip_dropped_because_of_missing_route,json=ipDroppedBecauseOfMissingRoute,proto3" json:"ip_dropped_because_of_missing_route,omitempty"`
	IpFragmentsDroppedAfterTimeout uint64 `protobuf:"varint,10,opt,name=ip_fragments_dropped_after_timeout,json=ipFragmentsDroppedAfterTimeout,proto3" json:"ip_fragments_dropped_after_timeout,omitempty"`
	IpReassembliesRequired         uint64 `protobuf:"varint,11,opt,name=ip_reassemblies_required,json=ipReassembliesRequired,proto3" json:"ip_reassemblies_required,omitempty"`
	IpPacketsReassembledOk         uint64 `protobuf:"varint,12,opt,name=ip_packets_reassembled_ok,json=ipPacketsReassembledOk,proto3" json:"ip_packets_reassembled_ok,omitempty"`
	IpPacketReassemblesFailed      uint64 `protobuf:"varint,13,opt,name=ip_packet_reassembles_failed,json=ipPacketReassemblesFailed,proto3" json:"ip_packet_reassembles_failed,omitempty"`
	// Tcp
	TcpActiveConnectionsOpenings uint64 `protobuf:"varint,14,opt,name=tcp_active_connections_openings,json=tcpActiveConnectionsOpenings,proto3" json:"tcp_active_connections_openings,omitempty"`
	TcpPassiveConnectionOpenings uint64 `protobuf:"varint,15,opt,name=tcp_passive_connection_openings,json=tcpPassiveConnectionOpenings,proto3" json:"tcp_passive_connection_openings,omitempty"`
	TcpFailedConnectionAttempts  uint64 `protobuf:"varint,16,opt,name=tcp_failed_connection_attempts,json=tcpFailedConnectionAttempts,proto3" json:"tcp_failed_connection_attempts,omitempty"`
	TcpConnectionResetsReceived  uint64 `protobuf:"varint,17,opt,name=tcp_connection_resets_received,json=tcpConnectionResetsReceived,proto3" json:"tcp_connection_resets_received,omitempty"`
	TcpConnectionsEstablished    uint64 `protobuf:"varint,18,opt,name=tcp_connections_established,json=tcpConnectionsEstablished,proto3" json:"tcp_connections_established,omitempty"`
	TcpSegmentsReceived          uint64 `protobuf:"varint,19,opt,name=tcp_segments_received,json=tcpSegmentsReceived,proto3" json:"tcp_segments_received,omitempty"`
	TcpSegmentsSendOut           uint64 `protobuf:"varint,20,opt,name=tcp_segments_send_out,json=tcpSegmentsSendOut,proto3" json:"tcp_segments_send_out,omitempty"`
	TcpSegmentsRetransmitted     uint64 `protobuf:"varint,21,opt,name=tcp_segments_retransmitted,json=tcpSegmentsRetransmitted,proto3" json:"tcp_segments_retransmitted,omitempty"`
	TcpBadSegmentsReceived       uint64 `protobuf:"varint,22,opt,name=tcp_bad_segments_received,json=tcpBadSegmentsReceived,proto3" json:"tcp_bad_segments_received,omitempty"`
	TcpResetsSent                uint64 `protobuf:"varint,23,opt,name=tcp_resets_sent,json=tcpResetsSent,proto3" json:"tcp_resets_sent,omitempty"`
	// Udp
	UdpPacketsReceived              uint64 `protobuf:"varint,24,opt,name=udp_packets_received,json=udpPacketsReceived,proto3" json:"udp_packets_received,omitempty"`
	UdpPacketsToUnknownPortReceived uint64 `protobuf:"varint,25,opt,name=udp_packets_to_unknown_port_received,json=udpPacketsToUnknownPortReceived,proto3" json:"udp_packets_to_unknown_port_received,omitempty"`
	UdpPacketReceiveErrors          uint64 `protobuf:"varint,26,opt,name=udp_packet_receive_errors,json=udpPacketReceiveErrors,proto3" json:"udp_packet_receive_errors,omitempty"`
	UdpPacketsSent                  uint64 `protobuf:"varint,27,opt,name=udp_packets_sent,json=udpPacketsSent,proto3" json:"udp_packets_sent,omitempty"`
	UdpReceiveBufferErrors          uint64 `protobuf:"varint,28,opt,name=udp_receive_buffer_errors,json=udpReceiveBufferErrors,proto3" json:"udp_receive_buffer_errors,omitempty"`
	UdpSendBufferErrors             uint64 `protobuf:"varint,29,opt,name=udp_send_buffer_errors,json=udpSendBufferErrors,proto3" json:"udp_send_buffer_errors,omitempty"`
	UdpIgnoredMulti                 uint64 `protobuf:"varint,30,opt,name=udp_ignored_multi,json=udpIgnoredMulti,proto3" json:"udp_ignored_multi,omitempty"`
	// TcpExt
	TcpextInvalidSynCookiesReceived                                 uint64 `protobuf:"varint,31,opt,name=tcpext_invalid_syn_cookies_received,json=tcpextInvalidSynCookiesReceived,proto3" json:"tcpext_invalid_syn_cookies_received,omitempty"`
	TcpextResetsReceivedForEmbryonicSynRecvSockets                  uint64 `protobuf:"varint,32,opt,name=tcpext_resets_received_for_embryonic_syn_recv_sockets,json=tcpextResetsReceivedForEmbryonicSynRecvSockets,proto3" json:"tcpext_resets_received_for_embryonic_syn_recv_sockets,omitempty"`
	TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow              uint64 `protobuf:"varint,33,opt,name=tcpext_icmp_packets_dropped_because_they_were_out_of_window,json=tcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow,proto3" json:"tcpext_icmp_packets_dropped_because_they_were_out_of_window,omitempty"`
	TcpextIcmpPacketsDroppedBecauseSocketWasLocked                  uint64 `protobuf:"varint,34,opt,name=tcpext_icmp_packets_dropped_because_socket_was_locked,json=tcpextIcmpPacketsDroppedBecauseSocketWasLocked,proto3" json:"tcpext_icmp_packets_dropped_because_socket_was_locked,omitempty"`
	TcpextTcpSocketsFinishedTimeWaitInFastTimer                     uint64 `protobuf:"varint,35,opt,name=tcpext_tcp_sockets_finished_time_wait_in_fast_timer,json=tcpextTcpSocketsFinishedTimeWaitInFastTimer,proto3" json:"tcpext_tcp_sockets_finished_time_wait_in_fast_timer,omitempty"`
	TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp  uint64 `protobuf:"varint,36,opt,name=tcpext_packets_rejects_in_established_connections_because_of_timestamp,json=tcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp,proto3" json:"tcpext_packets_rejects_in_established_connections_because_of_timestamp,omitempty"`
	TcpextDelayedAcksSent                                           uint64 `protobuf:"varint,37,opt,name=tcpext_delayed_acks_sent,json=tcpextDelayedAcksSent,proto3" json:"tcpext_delayed_acks_sent,omitempty"`
	TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket            uint64 `protobuf:"varint,38,opt,name=tcpext_delayed_acks_further_delayed_because_of_locked_socket,json=tcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket,proto3" json:"tcpext_delayed_acks_further_delayed_because_of_locked_socket,omitempty"`
	TcpextQuickAckModeWasActivatedTimes                             uint64 `protobuf:"varint,39,opt,name=tcpext_quick_ack_mode_was_activated_times,json=tcpextQuickAckModeWasActivatedTimes,proto3" json:"tcpext_quick_ack_mode_was_activated_times,omitempty"`
	TcpextTimesTheListenQueueOfASocketOverflowed                    uint64 `protobuf:"varint,40,opt,name=tcpext_times_the_listen_queue_of_a_socket_overflowed,json=tcpextTimesTheListenQueueOfASocketOverflowed,proto3" json:"tcpext_times_the_listen_queue_of_a_socket_overflowed,omitempty"`
	TcpextSynsToListenSocketsDropped                                uint64 `protobuf:"varint,41,opt,name=tcpext_syns_to_listen_sockets_dropped,json=tcpextSynsToListenSocketsDropped,proto3" json:"tcpext_syns_to_listen_sockets_dropped,omitempty"`
	TcpextPacketHeadersPredicted                                    uint64 `protobuf:"varint,42,opt,name=tcpext_packet_headers_predicted,json=tcpextPacketHeadersPredicted,proto3" json:"tcpext_packet_headers_predicted,omitempty"`
	TcpextAcknowledgmentsNotContainingDataPayloadReceived           uint64 `protobuf:"varint,43,opt,name=tcpext_acknowledgments_not_containing_data_payload_received,json=tcpextAcknowledgmentsNotContainingDataPayloadReceived,proto3" json:"tcpext_acknowledgments_not_containing_data_payload_received,omitempty"`
	TcpextPredictedAcknowledgments                                  uint64 `protobuf:"varint,44,opt,name=tcpext_predicted_acknowledgments,json=tcpextPredictedAcknowledgments,proto3" json:"tcpext_predicted_acknowledgments,omitempty"`
	TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements   uint64 `protobuf:"varint,45,opt,name=tcpext_times_recovered_from_packet_loss_by_selective_acknowledgements,json=tcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements,proto3" json:"tcpext_times_recovered_from_packet_loss_by_selective_acknowledgements,omitempty"`
	TcpextDetectedReorderingTimesUsingSack                          uint64 `protobuf:"varint,46,opt,name=tcpext_detected_reordering_times_using_sack,json=tcpextDetectedReorderingTimesUsingSack,proto3" json:"tcpext_detected_reordering_times_using_sack,omitempty"`
	TcpextCongestionWindowsFullyRecoveredWithoutSlowStart           uint64 `protobuf:"varint,47,opt,name=tcpext_congestion_windows_fully_recovered_without_slow_start,json=tcpextCongestionWindowsFullyRecoveredWithoutSlowStart,proto3" json:"tcpext_congestion_windows_fully_recovered_without_slow_start,omitempty"`
	TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack         uint64 `protobuf:"varint,48,opt,name=tcpext_congestion_windows_recovered_without_slow_start_by_dsack,json=tcpextCongestionWindowsRecoveredWithoutSlowStartByDsack,proto3" json:"tcpext_congestion_windows_recovered_without_slow_start_by_dsack,omitempty"`
	TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck uint64 `protobuf:"varint,49,opt,name=tcpext_congestion_windows_recovered_without_slow_start_after_partial_ack,json=tcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck,proto3" json:"tcpext_congestion_windows_recovered_without_slow_start_after_partial_ack,omitempty"`
	TcpextTcpLostRetransmit                                         uint64 `protobuf:"varint,50,opt,name=tcpext_tcp_lost_retransmit,json=tcpextTcpLostRetransmit,proto3" json:"tcpext_tcp_lost_retransmit,omitempty"`
	TcpextTimeoutsAfterSackRecovery                                 uint64 `protobuf:"varint,51,opt,name=tcpext_timeouts_after_sack_recovery,json=tcpextTimeoutsAfterSackRecovery,proto3" json:"tcpext_timeouts_after_sack_recovery,omitempty"`
	TcpextTimeoutsInLossState                                       uint64 `protobuf:"varint,52,opt,name=tcpext_timeouts_in_loss_state,json=tcpextTimeoutsInLossState,proto3" json:"tcpext_timeouts_in_loss_state,omitempty"`
	TcpextFastRetransmits                                           uint64 `protobuf:"varint,53,opt,name=tcpext_fast_retransmits,json=tcpextFastRetransmits,proto3" json:"tcpext_fast_retransmits,omitempty"`
	TcpextRetransmitsInSlowStart                                    uint64 `protobuf:"varint,54,opt,name=tcpext_retransmits_in_slow_start,json=tcpextRetransmitsInSlowStart,proto3" json:"tcpext_retransmits_in_slow_start,omitempty"`
	TcpextOtherTcpTimeouts                                          uint64 `protobuf:"varint,55,opt,name=tcpext_other_tcp_timeouts,json=tcpextOtherTcpTimeouts,proto3" json:"tcpext_other_tcp_timeouts,omitempty"`
	TcpextTcpLossProbes                                             uint64 `protobuf:"varint,56,opt,name=tcpext_tcp_loss_probes,json=tcpextTcpLossProbes,proto3" json:"tcpext_tcp_loss_probes,omitempty"`
	TcpextTcpLossProbeRecovery                                      uint64 `protobuf:"varint,57,opt,name=tcpext_tcp_loss_probe_recovery,json=tcpextTcpLossProbeRecovery,proto3" json:"tcpext_tcp_loss_probe_recovery,omitempty"`
	TcpextSackRetransmitsFailed                                     uint64 `protobuf:"varint,58,opt,name=tcpext_sack_retransmits_failed,json=tcpextSackRetransmitsFailed,proto3" json:"tcpext_sack_retransmits_failed,omitempty"`
	TcpextTcpBacklogCoalesce                                        uint64 `protobuf:"varint,59,opt,name=tcpext_tcp_backlog_coalesce,json=tcpextTcpBacklogCoalesce,proto3" json:"tcpext_tcp_backlog_coalesce,omitempty"`
	TcpextDsacksSentForOldPackets                                   uint64 `protobuf:"varint,60,opt,name=tcpext_dsacks_sent_for_old_packets,json=tcpextDsacksSentForOldPackets,proto3" json:"tcpext_dsacks_sent_for_old_packets,omitempty"`
	TcpextDsacksSentForOutOfOrderPackets                            uint64 `protobuf:"varint,61,opt,name=tcpext_dsacks_sent_for_out_of_order_packets,json=tcpextDsacksSentForOutOfOrderPackets,proto3" json:"tcpext_dsacks_sent_for_out_of_order_packets,omitempty"`
	TcpextDsacksReceived                                            uint64 `protobuf:"varint,62,opt,name=tcpext_dsacks_received,json=tcpextDsacksReceived,proto3" json:"tcpext_dsacks_received,omitempty"`
	TcpextDsacksForOutOfOrderPacketsReceived                        uint64 `protobuf:"varint,63,opt,name=tcpext_dsacks_for_out_of_order_packets_received,json=tcpextDsacksForOutOfOrderPacketsReceived,proto3" json:"tcpext_dsacks_for_out_of_order_packets_received,omitempty"`
	TcpextConnectionsResetDueToUnexpectedData                       uint64 `protobuf:"varint,64,opt,name=tcpext_connections_reset_due_to_unexpected_data,json=tcpextConnectionsResetDueToUnexpectedData,proto3" json:"tcpext_connections_reset_due_to_unexpected_data,omitempty"`
	TcpextConnectionsResetDueToEarlyUserClose                       uint64 `protobuf:"varint,65,opt,name=tcpext_connections_reset_due_to_early_user_close,json=tcpextConnectionsResetDueToEarlyUserClose,proto3" json:"tcpext_connections_reset_due_to_early_user_close,omitempty"`
	TcpextConnectionsAbortedDueToTimeout                            uint64 `protobuf:"varint,66,opt,name=tcpext_connections_aborted_due_to_timeout,json=tcpextConnectionsAbortedDueToTimeout,proto3" json:"tcpext_connections_aborted_due_to_timeout,omitempty"`
	TcpextTcpDsackIgnoredOld                                        uint64 `protobuf:"varint,67,opt,name=tcpext_tcp_dsack_ignored_old,json=tcpextTcpDsackIgnoredOld,proto3" json:"tcpext_tcp_dsack_ignored_old,omitempty"`
	TcpextTcpDsackIgnoredNoUndo                                     uint64 `protobuf:"varint,68,opt,name=tcpext_tcp_dsack_ignored_no_undo,json=tcpextTcpDsackIgnoredNoUndo,proto3" json:"tcpext_tcp_dsack_ignored_no_undo,omitempty"`
	TcpextTcpSpuriousRtos                                           uint64 `protobuf:"varint,69,opt,name=tcpext_tcp_spurious_rtos,json=tcpextTcpSpuriousRtos,proto3" json:"tcpext_tcp_spurious_rtos,omitempty"`
	TcpextTcpSackMerged                                             uint64 `protobuf:"varint,70,opt,name=tcpext_tcp_sack_merged,json=tcpextTcpSackMerged,proto3" json:"tcpext_tcp_sack_merged,omitempty"`
	TcpextTcpSackShiftFallback                                      uint64 `protobuf:"varint,71,opt,name=tcpext_tcp_sack_shift_fallback,json=tcpextTcpSackShiftFallback,proto3" json:"tcpext_tcp_sack_shift_fallback,omitempty"`
	TcpextIpReversePathFilter                                       uint64 `protobuf:"varint,72,opt,name=tcpext_ip_reverse_path_filter,json=tcpextIpReversePathFilter,proto3" json:"tcpext_ip_reverse_path_filter,omitempty"`
	TcpextTcpRetransFail                                            uint64 `protobuf:"varint,73,opt,name=tcpext_tcp_retrans_fail,json=tcpextTcpRetransFail,proto3" json:"tcpext_tcp_retrans_fail,omitempty"`
	TcpextTcpRcvCoalesce                                            uint64 `protobuf:"varint,74,opt,name=tcpext_tcp_rcv_coalesce,json=tcpextTcpRcvCoalesce,proto3" json:"tcpext_tcp_rcv_coalesce,omitempty"`
	TcpextTcpOfoQueue                                               uint64 `protobuf:"varint,75,opt,name=tcpext_tcp_ofo_queue,json=tcpextTcpOfoQueue,proto3" json:"tcpext_tcp_ofo_queue,omitempty"`
	TcpextTcpOfoMerge                                               uint64 `protobuf:"varint,76,opt,name=tcpext_tcp_ofo_merge,json=tcpextTcpOfoMerge,proto3" json:"tcpext_tcp_ofo_merge,omitempty"`
	TcpextTcpChallengeAck                                           uint64 `protobuf:"varint,77,opt,name=tcpext_tcp_challenge_ack,json=tcpextTcpChallengeAck,proto3" json:"tcpext_tcp_challenge_ack,omitempty"`
	TcpextTcpSynChallenge                                           uint64 `protobuf:"varint,78,opt,name=tcpext_tcp_syn_challenge,json=tcpextTcpSynChallenge,proto3" json:"tcpext_tcp_syn_challenge,omitempty"`
	TcpextTcpFastOpenActiveFail                                     uint64 `protobuf:"varint,79,opt,name=tcpext_tcp_fast_open_active_fail,json=tcpextTcpFastOpenActiveFail,proto3" json:"tcpext_tcp_fast_open_active_fail,omitempty"`
	TcpextTcpFastOpenCookieReqd                                     uint64 `protobuf:"varint,80,opt,name=tcpext_tcp_fast_open_cookie_reqd,json=tcpextTcpFastOpenCookieReqd,proto3" json:"tcpext_tcp_fast_open_cookie_reqd,omitempty"`
	TcpextTcpFastOpenBlackhole                                      uint64 `protobuf:"varint,81,opt,name=tcpext_tcp_fast_open_blackhole,json=tcpextTcpFastOpenBlackhole,proto3" json:"tcpext_tcp_fast_open_blackhole,omitempty"`
	TcpextTcpSpuriousRtxHostQueues                                  uint64 `protobuf:"varint,82,opt,name=tcpext_tcp_spurious_rtx_host_queues,json=tcpextTcpSpuriousRtxHostQueues,proto3" json:"tcpext_tcp_spurious_rtx_host_queues,omitempty"`
	TcpextTcpAutoCorking                                            uint64 `protobuf:"varint,83,opt,name=tcpext_tcp_auto_corking,json=tcpextTcpAutoCorking,proto3" json:"tcpext_tcp_auto_corking,omitempty"`
	TcpextTcpSynRetrans                                             uint64 `protobuf:"varint,84,opt,name=tcpext_tcp_syn_retrans,json=tcpextTcpSynRetrans,proto3" json:"tcpext_tcp_syn_retrans,omitempty"`
	TcpextTcpOrigDataSent                                           uint64 `protobuf:"varint,85,opt,name=tcpext_tcp_orig_data_sent,json=tcpextTcpOrigDataSent,proto3" json:"tcpext_tcp_orig_data_sent,omitempty"`
	TcpextTcpHystartTrainDetect                                     uint64 `protobuf:"varint,86,opt,name=tcpext_tcp_hystart_train_detect,json=tcpextTcpHystartTrainDetect,proto3" json:"tcpext_tcp_hystart_train_detect,omitempty"`
	TcpextTcpHystartTrainCwnd                                       uint64 `protobuf:"varint,87,opt,name=tcpext_tcp_hystart_train_cwnd,json=tcpextTcpHystartTrainCwnd,proto3" json:"tcpext_tcp_hystart_train_cwnd,omitempty"`
	TcpextTcpHystartDelayDetect                                     uint64 `protobuf:"varint,88,opt,name=tcpext_tcp_hystart_delay_detect,json=tcpextTcpHystartDelayDetect,proto3" json:"tcpext_tcp_hystart_delay_detect,omitempty"`
	TcpextTcpHystartDelayCwnd                                       uint64 `protobuf:"varint,89,opt,name=tcpext_tcp_hystart_delay_cwnd,json=tcpextTcpHystartDelayCwnd,proto3" json:"tcpext_tcp_hystart_delay_cwnd,omitempty"`
	TcpextTcpAckSkippedSeq                                          uint64 `protobuf:"varint,90,opt,name=tcpext_tcp_ack_skipped_seq,json=tcpextTcpAckSkippedSeq,proto3" json:"tcpext_tcp_ack_skipped_seq,omitempty"`
	TcpextTcpAckSkippedChallenge                                    uint64 `protobuf:"varint,91,opt,name=tcpext_tcp_ack_skipped_challenge,json=tcpextTcpAckSkippedChallenge,proto3" json:"tcpext_tcp_ack_skipped_challenge,omitempty"`
	TcpextTcpKeepAlive                                              uint64 `protobuf:"varint,92,opt,name=tcpext_tcp_keep_alive,json=tcpextTcpKeepAlive,proto3" json:"tcpext_tcp_keep_alive,omitempty"`
	TcpextTcpDelivered                                              uint64 `protobuf:"varint,93,opt,name=tcpext_tcp_delivered,json=tcpextTcpDelivered,proto3" json:"tcpext_tcp_delivered,omitempty"`
	TcpextTcpAckCompressed                                          uint64 `protobuf:"varint,94,opt,name=tcpext_tcp_ack_compressed,json=tcpextTcpAckCompressed,proto3" json:"tcpext_tcp_ack_compressed,omitempty"`
	// IpExt
	IpextInBcastPkts   uint64 `protobuf:"varint,95,opt,name=ipext_in_bcast_pkts,json=ipextInBcastPkts,proto3" json:"ipext_in_bcast_pkts,omitempty"`
	IpextInOctets      uint64 `protobuf:"varint,96,opt,name=ipext_in_octets,json=ipextInOctets,proto3" json:"ipext_in_octets,omitempty"`
	IpextOutOctets     uint64 `protobuf:"varint,97,opt,name=ipext_out_octets,json=ipextOutOctets,proto3" json:"ipext_out_octets,omitempty"`
	IpextInBcastOctets uint64 `protobuf:"varint,98,opt,name=ipext_in_bcast_octets,json=ipextInBcastOctets,proto3" json:"ipext_in_bcast_octets,omitempty"`
	IpextInNoEctPkts   uint64 `protobuf:"varint,99,opt,name=ipext_in_no_ect_pkts,json=ipextInNoEctPkts,proto3" json:"ipext_in_no_ect_pkts,omitempty"`
	IpextInEct0Pkts    uint64 `protobuf:"varint,100,opt,name=ipext_in_ect0_pkts,json=ipextInEct0Pkts,proto3" json:"ipext_in_ect0_pkts,omitempty"`
}

func (m *NetstatMetric) Reset()         { *m = NetstatMetric{} }
func (m *NetstatMetric) String() string { return proto.CompactTextString(m) }
func (*NetstatMetric) ProtoMessage()    {}
func (*NetstatMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{8}
}
func (m *NetstatMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetstatMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetstatMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetstatMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetstatMetric.Merge(m, src)
}
func (m *NetstatMetric) XXX_Size() int {
	return m.Size()
}
func (m *NetstatMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_NetstatMetric.DiscardUnknown(m)
}

var xxx_messageInfo_NetstatMetric proto.InternalMessageInfo

func (m *NetstatMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NetstatMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *NetstatMetric) GetIpTotalPacketsReceived() uint64 {
	if m != nil {
		return m.IpTotalPacketsReceived
	}
	return 0
}

func (m *NetstatMetric) GetIpForwarded() uint64 {
	if m != nil {
		return m.IpForwarded
	}
	return 0
}

func (m *NetstatMetric) GetIpIncomingPacketsDiscarded() uint64 {
	if m != nil {
		return m.IpIncomingPacketsDiscarded
	}
	return 0
}

func (m *NetstatMetric) GetIpIncomingPacketsDelivered() uint64 {
	if m != nil {
		return m.IpIncomingPacketsDelivered
	}
	return 0
}

func (m *NetstatMetric) GetIpRequestsSentOut() uint64 {
	if m != nil {
		return m.IpRequestsSentOut
	}
	return 0
}

func (m *NetstatMetric) GetIpOutgoingPacketsDropped() uint64 {
	if m != nil {
		return m.IpOutgoingPacketsDropped
	}
	return 0
}

func (m *NetstatMetric) GetIpDroppedBecauseOfMissingRoute() uint64 {
	if m != nil {
		return m.IpDroppedBecauseOfMissingRoute
	}
	return 0
}

func (m *NetstatMetric) GetIpFragmentsDroppedAfterTimeout() uint64 {
	if m != nil {
		return m.IpFragmentsDroppedAfterTimeout
	}
	return 0
}

func (m *NetstatMetric) GetIpReassembliesRequired() uint64 {
	if m != nil {
		return m.IpReassembliesRequired
	}
	return 0
}

func (m *NetstatMetric) GetIpPacketsReassembledOk() uint64 {
	if m != nil {
		return m.IpPacketsReassembledOk
	}
	return 0
}

func (m *NetstatMetric) GetIpPacketReassemblesFailed() uint64 {
	if m != nil {
		return m.IpPacketReassemblesFailed
	}
	return 0
}

func (m *NetstatMetric) GetTcpActiveConnectionsOpenings() uint64 {
	if m != nil {
		return m.TcpActiveConnectionsOpenings
	}
	return 0
}

func (m *NetstatMetric) GetTcpPassiveConnectionOpenings() uint64 {
	if m != nil {
		return m.TcpPassiveConnectionOpenings
	}
	return 0
}

func (m *NetstatMetric) GetTcpFailedConnectionAttempts() uint64 {
	if m != nil {
		return m.TcpFailedConnectionAttempts
	}
	return 0
}

func (m *NetstatMetric) GetTcpConnectionResetsReceived() uint64 {
	if m != nil {
		return m.TcpConnectionResetsReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpConnectionsEstablished() uint64 {
	if m != nil {
		return m.TcpConnectionsEstablished
	}
	return 0
}

func (m *NetstatMetric) GetTcpSegmentsReceived() uint64 {
	if m != nil {
		return m.TcpSegmentsReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpSegmentsSendOut() uint64 {
	if m != nil {
		return m.TcpSegmentsSendOut
	}
	return 0
}

func (m *NetstatMetric) GetTcpSegmentsRetransmitted() uint64 {
	if m != nil {
		return m.TcpSegmentsRetransmitted
	}
	return 0
}

func (m *NetstatMetric) GetTcpBadSegmentsReceived() uint64 {
	if m != nil {
		return m.TcpBadSegmentsReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpResetsSent() uint64 {
	if m != nil {
		return m.TcpResetsSent
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketsReceived() uint64 {
	if m != nil {
		return m.UdpPacketsReceived
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketsToUnknownPortReceived() uint64 {
	if m != nil {
		return m.UdpPacketsToUnknownPortReceived
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketReceiveErrors() uint64 {
	if m != nil {
		return m.UdpPacketReceiveErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpPacketsSent() uint64 {
	if m != nil {
		return m.UdpPacketsSent
	}
	return 0
}

func (m *NetstatMetric) GetUdpReceiveBufferErrors() uint64 {
	if m != nil {
		return m.UdpReceiveBufferErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpSendBufferErrors() uint64 {
	if m != nil {
		return m.UdpSendBufferErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpIgnoredMulti() uint64 {
	if m != nil {
		return m.UdpIgnoredMulti
	}
	return 0
}

func (m *NetstatMetric) GetTcpextInvalidSynCookiesReceived() uint64 {
	if m != nil {
		return m.TcpextInvalidSynCookiesReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpextResetsReceivedForEmbryonicSynRecvSockets() uint64 {
	if m != nil {
		return m.TcpextResetsReceivedForEmbryonicSynRecvSockets
	}
	return 0
}

func (m *NetstatMetric) GetTcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow() uint64 {
	if m != nil {
		return m.TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow
	}
	return 0
}

func (m *NetstatMetric) GetTcpextIcmpPacketsDroppedBecauseSocketWasLocked() uint64 {
	if m != nil {
		return m.TcpextIcmpPacketsDroppedBecauseSocketWasLocked
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpSocketsFinishedTimeWaitInFastTimer() uint64 {
	if m != nil {
		return m.TcpextTcpSocketsFinishedTimeWaitInFastTimer
	}
	return 0
}

func (m *NetstatMetric) GetTcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp() uint64 {
	if m != nil {
		return m.TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp
	}
	return 0
}

func (m *NetstatMetric) GetTcpextDelayedAcksSent() uint64 {
	if m != nil {
		return m.TcpextDelayedAcksSent
	}
	return 0
}

func (m *NetstatMetric) GetTcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket() uint64 {
	if m != nil {
		return m.TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket
	}
	return 0
}

func (m *NetstatMetric) GetTcpextQuickAckModeWasActivatedTimes() uint64 {
	if m != nil {
		return m.TcpextQuickAckModeWasActivatedTimes
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTimesTheListenQueueOfASocketOverflowed() uint64 {
	if m != nil {
		return m.TcpextTimesTheListenQueueOfASocketOverflowed
	}
	return 0
}

func (m *NetstatMetric) GetTcpextSynsToListenSocketsDropped() uint64 {
	if m != nil {
		return m.TcpextSynsToListenSocketsDropped
	}
	return 0
}

func (m *NetstatMetric) GetTcpextPacketHeadersPredicted() uint64 {
	if m != nil {
		return m.TcpextPacketHeadersPredicted
	}
	return 0
}

func (m *NetstatMetric) GetTcpextAcknowledgmentsNotContainingDataPayloadReceived() uint64 {
	if m != nil {
		return m.TcpextAcknowledgmentsNotContainingDataPayloadReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpextPredictedAcknowledgments() uint64 {
	if m != nil {
		return m.TcpextPredictedAcknowledgments
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements() uint64 {
	if m != nil {
		return m.TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements
	}
	return 0
}

func (m *NetstatMetric) GetTcpextDetectedReorderingTimesUsingSack() uint64 {
	if m != nil {
		return m.TcpextDetectedReorderingTimesUsingSack
	}
	return 0
}

func (m *NetstatMetric) GetTcpextCongestionWindowsFullyRecoveredWithoutSlowStart() uint64 {
	if m != nil {
		return m.TcpextCongestionWindowsFullyRecoveredWithoutSlowStart
	}
	return 0
}

func (m *NetstatMetric) GetTcpextCongestionWindowsRecoveredWithoutSlowStartByDsack() uint64 {
	if m != nil {
		return m.TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack
	}
	return 0
}

func (m *NetstatMetric) GetTcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck() uint64 {
	if m != nil {
		return m.TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpLostRetransmit() uint64 {
	if m != nil {
		return m.TcpextTcpLostRetransmit
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTimeoutsAfterSackRecovery() uint64 {
	if m != nil {
		return m.TcpextTimeoutsAfterSackRecovery
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTimeoutsInLossState() uint64 {
	if m != nil {
		return m.TcpextTimeoutsInLossState
	}
	return 0
}

func (m *NetstatMetric) GetTcpextFastRetransmits() uint64 {
	if m != nil {
		return m.TcpextFastRetransmits
	}
	return 0
}

func (m *NetstatMetric) GetTcpextRetransmitsInSlowStart() uint64 {
	if m != nil {
		return m.TcpextRetransmitsInSlowStart
	}
	return 0
}

func (m *NetstatMetric) GetTcpextOtherTcpTimeouts() uint64 {
	if m != nil {
		return m.TcpextOtherTcpTimeouts
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpLossProbes() uint64 {
	if m != nil {
		return m.TcpextTcpLossProbes
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpLossProbeRecovery() uint64 {
	if m != nil {
		return m.TcpextTcpLossProbeRecovery
	}
	return 0
}

func (m *NetstatMetric) GetTcpextSackRetransmitsFailed() uint64 {
	if m != nil {
		return m.TcpextSackRetransmitsFailed
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpBacklogCoalesce() uint64 {
	if m != nil {
		return m.TcpextTcpBacklogCoalesce
	}
	return 0
}

func (m *NetstatMetric) GetTcpextDsacksSentForOldPackets() uint64 {
	if m != nil {
		return m.TcpextDsacksSentForOldPackets
	}
	return 0
}

func (m *NetstatMetric) GetTcpextDsacksSentForOutOfOrderPackets() uint64 {
	if m != nil {
		return m.TcpextDsacksSentForOutOfOrderPackets
	}
	return 0
}

func (m *NetstatMetric) GetTcpextDsacksReceived() uint64 {
	if m != nil {
		return m.TcpextDsacksReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpextDsacksForOutOfOrderPacketsReceived() uint64 {
	if m != nil {
		return m.TcpextDsacksForOutOfOrderPacketsReceived
	}
	return 0
}

func (m *NetstatMetric) GetTcpextConnectionsResetDueToUnexpectedData() uint64 {
	if m != nil {
		return m.TcpextConnectionsResetDueToUnexpectedData
	}
	return 0
}

func (m *NetstatMetric) GetTcpextConnectionsResetDueToEarlyUserClose() uint64 {
	if m != nil {
		return m.TcpextConnectionsResetDueToEarlyUserClose
	}
	return 0
}

func (m *NetstatMetric) GetTcpextConnectionsAbortedDueToTimeout() uint64 {
	if m != nil {
		return m.TcpextConnectionsAbortedDueToTimeout
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpDsackIgnoredOld() uint64 {
	if m != nil {
		return m.TcpextTcpDsackIgnoredOld
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpDsackIgnoredNoUndo() uint64 {
	if m != nil {
		return m.TcpextTcpDsackIgnoredNoUndo
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpSpuriousRtos() uint64 {
	if m != nil {
		return m.TcpextTcpSpuriousRtos
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpSackMerged() uint64 {
	if m != nil {
		return m.TcpextTcpSackMerged
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpSackShiftFallback() uint64 {
	if m != nil {
		return m.TcpextTcpSackShiftFallback
	}
	return 0
}

func (m *NetstatMetric) GetTcpextIpReversePathFilter() uint64 {
	if m != nil {
		return m.TcpextIpReversePathFilter
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpRetransFail() uint64 {
	if m != nil {
		return m.TcpextTcpRetransFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpRcvCoalesce() uint64 {
	if m != nil {
		return m.TcpextTcpRcvCoalesce
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpOfoQueue() uint64 {
	if m != nil {
		return m.TcpextTcpOfoQueue
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpOfoMerge() uint64 {
	if m != nil {
		return m.TcpextTcpOfoMerge
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpChallengeAck() uint64 {
	if m != nil {
		return m.TcpextTcpChallengeAck
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpSynChallenge() uint64 {
	if m != nil {
		return m.TcpextTcpSynChallenge
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpFastOpenActiveFail() uint64 {
	if m != nil {
		return m.TcpextTcpFastOpenActiveFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpFastOpenCookieReqd() uint64 {
	if m != nil {
		return m.TcpextTcpFastOpenCookieReqd
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpFastOpenBlackhole() uint64 {
	if m != nil {
		return m.TcpextTcpFastOpenBlackhole
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpSpuriousRtxHostQueues() uint64 {
	if m != nil {
		return m.TcpextTcpSpuriousRtxHostQueues
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpAutoCorking() uint64 {
	if m != nil {
		return m.TcpextTcpAutoCorking
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpSynRetrans() uint64 {
	if m != nil {
		return m.TcpextTcpSynRetrans
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpOrigDataSent() uint64 {
	if m != nil {
		return m.TcpextTcpOrigDataSent
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpHystartTrainDetect() uint64 {
	if m != nil {
		return m.TcpextTcpHystartTrainDetect
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpHystartTrainCwnd() uint64 {
	if m != nil {
		return m.TcpextTcpHystartTrainCwnd
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpHystartDelayDetect() uint64 {
	if m != nil {
		return m.TcpextTcpHystartDelayDetect
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpHystartDelayCwnd() uint64 {
	if m != nil {
		return m.TcpextTcpHystartDelayCwnd
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpAckSkippedSeq() uint64 {
	if m != nil {
		return m.TcpextTcpAckSkippedSeq
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpAckSkippedChallenge() uint64 {
	if m != nil {
		return m.TcpextTcpAckSkippedChallenge
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpKeepAlive() uint64 {
	if m != nil {
		return m.TcpextTcpKeepAlive
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpDelivered() uint64 {
	if m != nil {
		return m.TcpextTcpDelivered
	}
	return 0
}

func (m *NetstatMetric) GetTcpextTcpAckCompressed() uint64 {
	if m != nil {
		return m.TcpextTcpAckCompressed
	}
	return 0
}

func (m *NetstatMetric) GetIpextInBcastPkts() uint64 {
	if m != nil {
		return m.IpextInBcastPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpextInOctets() uint64 {
	if m != nil {
		return m.IpextInOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpextOutOctets() uint64 {
	if m != nil {
		return m.IpextOutOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpextInBcastOctets() uint64 {
	if m != nil {
		return m.IpextInBcastOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpextInNoEctPkts() uint64 {
	if m != nil {
		return m.IpextInNoEctPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpextInEct0Pkts() uint64 {
	if m != nil {
		return m.IpextInEct0Pkts
	}
	return 0
}

func init() {
	proto.RegisterEnum("MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("SocketState", SocketState_name, SocketState_value)
	proto.RegisterType((*Metric)(nil), "Metric")
	proto.RegisterType((*SocketMemoryUsage)(nil), "SocketMemoryUsage")
	proto.RegisterType((*TimerInfo)(nil), "TimerInfo")
	proto.RegisterType((*ProcessInfo)(nil), "ProcessInfo")
	proto.RegisterType((*SocketMetric)(nil), "SocketMetric")
	proto.RegisterType((*TcpMetric)(nil), "TcpMetric")
	proto.RegisterType((*IfaceMetric)(nil), "IfaceMetric")
	proto.RegisterType((*NicMetric)(nil), "NicMetric")
	proto.RegisterType((*NetstatMetric)(nil), "NetstatMetric")
}

func init() { proto.RegisterFile("tcpmon.proto", fileDescriptor_59f30c3258032903) }

var fileDescriptor_59f30c3258032903 = []byte{
	// 3974 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x7a, 0x4b, 0x77, 0x1b, 0x47,
	0x76, 0xb0, 0x28, 0x42, 0x94, 0x58, 0x7c, 0x08, 0x6a, 0x4b, 0x76, 0xcb, 0xb2, 0x29, 0x9a, 0x96,
	0x6d, 0x59, 0x1e, 0xd3, 0xb2, 0xfc, 0x1e, 0xbf, 0x06, 0x04, 0xc9, 0x11, 0xc6, 0x24, 0x41, 0x37,
	0x20, 0xf3, 0xf3, 0x37, 0x49, 0x3a, 0x8d, 0xea, 0x02, 0xd9, 0x83, 0x46, 0x57, 0xb3, 0xaa, 0x00,
	0x10, 0x93, 0x4d, 0x7e, 0x40, 0x4e, 0x4e, 0x92, 0x9f, 0x93, 0x5f, 0x90, 0xe5, 0x2c, 0xb3, 0xcc,
	0xb1, 0x97, 0x39, 0x59, 0x67, 0x9b, 0x73, 0xef, 0xad, 0xae, 0x6e, 0x40, 0xa2, 0xe7, 0x24, 0xb3,
	0x43, 0xdf, 0x77, 0xdd, 0x77, 0x15, 0xc9, 0x56, 0x0d, 0xcf, 0x87, 0x32, 0xdb, 0xce, 0x95, 0x34,
	0x72, 0xcb, 0xb0, 0xa5, 0x43, 0x61, 0x54, 0xc2, 0xbd, 0x0d, 0xb6, 0x68, 0x78, 0xee, 0x2f, 0x6c,
	0x2e, 0x3c, 0x5c, 0x79, 0xc2, 0xb6, 0xbb, 0x3c, 0x27, 0xc4, 0xd3, 0x2b, 0x01, 0x20, 0x00, 0x9f,
	0x25, 0xdc, 0xbf, 0x6a, 0xf1, 0x47, 0x09, 0x2f, 0xf1, 0x59, 0xc2, 0xbd, 0x2d, 0xb6, 0x98, 0x09,
	0xe3, 0x2f, 0x22, 0x7e, 0x7d, 0xfb, 0x48, 0x18, 0x6d, 0x22, 0x53, 0xa1, 0x11, 0x66, 0x67, 0x89,
	0xd5, 0x7a, 0x32, 0x9e, 0x6e, 0xfd, 0xcb, 0x55, 0x76, 0xab, 0x23, 0xf9, 0x40, 0x98, 0x43, 0x31,
	0x94, 0x6a, 0xfa, 0x4c, 0x47, 0xa7, 0xc2, 0x7b, 0x9d, 0x31, 0x35, 0x14, 0xc3, 0x30, 0x4a, 0x53,
	0xc9, 0xd1, 0x90, 0xb5, 0x60, 0x19, 0x20, 0x0d, 0x00, 0x78, 0xaf, 0xb0, 0xeb, 0x8a, 0x8f, 0xc3,
	0xde, 0xa8, 0x8f, 0x46, 0xac, 0x05, 0x4b, 0x8a, 0x8f, 0x77, 0x46, 0x7d, 0xe0, 0x9b, 0x94, 0x7c,
	0x8b, 0xc4, 0x37, 0xa9, 0xf2, 0xe9, 0x2c, 0x46, 0xbe, 0x1a, 0xf1, 0xe9, 0x2c, 0x06, 0xbe, 0x7b,
	0x6c, 0xb9, 0x3f, 0x89, 0x2d, 0xdb, 0x35, 0x44, 0xdd, 0xe8, 0x4f, 0x62, 0xe2, 0xba, 0xcf, 0x56,
	0x50, 0xe8, 0xf9, 0x48, 0x8c, 0x44, 0xec, 0x2f, 0x21, 0x1a, 0xf5, 0x7c, 0x8f, 0x10, 0x10, 0x2b,
	0x73, 0x13, 0x0e, 0xc5, 0xd0, 0xbf, 0x4e, 0x62, 0x65, 0x0e, 0xc7, 0xf1, 0xee, 0xb2, 0x1b, 0xbd,
	0x88, 0x0f, 0xc2, 0x54, 0x9e, 0xfa, 0x37, 0x10, 0x73, 0x1d, 0xbe, 0x0f, 0xe4, 0x29, 0x68, 0xd4,
	0x92, 0x0f, 0xc2, 0x58, 0xc9, 0xdc, 0x5f, 0x26, 0x8d, 0x00, 0xd8, 0x55, 0x32, 0xdf, 0x0a, 0xd9,
	0x72, 0x37, 0x19, 0x0a, 0xd5, 0xca, 0xfa, 0xd2, 0xf3, 0x58, 0x2d, 0x8b, 0x86, 0x02, 0xbd, 0xb0,
	0x1c, 0xe0, 0x6f, 0xef, 0x01, 0x5b, 0x17, 0x17, 0x79, 0xa2, 0x44, 0x68, 0x92, 0xa1, 0x08, 0x47,
	0x1a, 0xfd, 0x50, 0x0b, 0x56, 0x09, 0x0a, 0xcc, 0xcf, 0xb4, 0xe7, 0xb3, 0xeb, 0x4a, 0x18, 0x15,
	0x65, 0xda, 0xba, 0xa2, 0xf8, 0xdc, 0x6a, 0xb2, 0x95, 0x63, 0x25, 0xb9, 0xd0, 0xfa, 0x52, 0x15,
	0x75, 0xb6, 0x98, 0x27, 0xb1, 0xf5, 0x2f, 0xfc, 0xf4, 0xd6, 0xd9, 0xd5, 0x7e, 0x6c, 0x25, 0x5d,
	0xed, 0xc7, 0x5b, 0xff, 0xc5, 0xd8, 0x6a, 0x11, 0x3a, 0xcc, 0x9b, 0x2d, 0x76, 0x0d, 0x02, 0x2d,
	0x90, 0x66, 0xfd, 0xc9, 0xea, 0x36, 0x61, 0x3b, 0x00, 0x0b, 0x08, 0xe5, 0xdd, 0x61, 0x4b, 0x4a,
	0xf0, 0x71, 0x78, 0x6e, 0x23, 0x70, 0x0d, 0xbe, 0xbe, 0x07, 0xb0, 0x16, 0x59, 0x1c, 0x9e, 0xa3,
	0xf7, 0x17, 0x83, 0x6b, 0xf0, 0xf5, 0x3d, 0xc4, 0x33, 0x95, 0x3c, 0x4a, 0xc3, 0x28, 0x8e, 0x15,
	0x7a, 0x7e, 0x39, 0x58, 0x46, 0x48, 0x23, 0x8e, 0x15, 0x38, 0x31, 0x17, 0x42, 0x11, 0xf6, 0x3a,
	0x62, 0x6f, 0x00, 0x00, 0x91, 0x8f, 0xd8, 0x72, 0x4e, 0x67, 0x14, 0xda, 0xbf, 0xb1, 0xb9, 0xf8,
	0x70, 0xe5, 0xc9, 0xea, 0x76, 0xe5, 0xd4, 0x41, 0x89, 0xf6, 0xb6, 0xd8, 0x12, 0x38, 0x52, 0x69,
	0x7f, 0x19, 0x09, 0xd9, 0xb6, 0xf3, 0x7f, 0x60, 0x31, 0xde, 0x43, 0x76, 0x4d, 0x0f, 0x20, 0xc6,
	0x0c, 0xf3, 0xda, 0xdb, 0x7e, 0x2e, 0x6d, 0x03, 0x22, 0x00, 0x47, 0x19, 0xed, 0xaf, 0x6c, 0x2e,
	0x3c, 0xbc, 0x11, 0x5c, 0x35, 0x1a, 0xdc, 0xab, 0x23, 0x3e, 0xf0, 0x57, 0x11, 0x82, 0xbf, 0xbd,
	0xdb, 0xec, 0x1a, 0x1f, 0xf5, 0x12, 0xee, 0xaf, 0x21, 0x90, 0x3e, 0x20, 0xd5, 0xa2, 0x3c, 0x0f,
	0xd3, 0x64, 0x98, 0x18, 0x11, 0xfb, 0xeb, 0x88, 0x63, 0x51, 0x9e, 0x1f, 0x10, 0x04, 0x08, 0xf2,
	0x88, 0x27, 0xd9, 0x69, 0xa8, 0xc0, 0xd1, 0x37, 0x37, 0x17, 0x1e, 0x2e, 0x04, 0x8c, 0x40, 0x01,
	0xf8, 0xf7, 0x4d, 0xb6, 0x16, 0x8b, 0x34, 0x19, 0x0b, 0x35, 0x25, 0x92, 0x3a, 0x92, 0xac, 0x16,
	0x40, 0x24, 0x02, 0x83, 0x44, 0x16, 0xfb, 0xb7, 0x10, 0x87, 0xbf, 0xc1, 0xd5, 0x50, 0x1b, 0x13,
	0xcd, 0xa3, 0x54, 0xf8, 0x1e, 0x95, 0x8e, 0xce, 0xe2, 0x13, 0x04, 0x60, 0x45, 0xf2, 0x71, 0x81,
	0x7e, 0xc9, 0x56, 0x24, 0x1f, 0x5b, 0x74, 0x9d, 0x2d, 0x2a, 0x23, 0xfd, 0xdb, 0x28, 0x10, 0x7e,
	0x12, 0xc4, 0xf8, 0x77, 0x0a, 0x88, 0xf1, 0x5e, 0x66, 0x4b, 0xca, 0x98, 0x71, 0xa4, 0xfc, 0x97,
	0x11, 0x68, 0xbf, 0x00, 0x3e, 0x4c, 0x32, 0x20, 0x7e, 0x85, 0xe0, 0xf4, 0x55, 0x54, 0x39, 0x20,
	0x7c, 0xcb, 0xc0, 0xc7, 0x81, 0x31, 0xe0, 0x04, 0x9b, 0xc8, 0x61, 0x26, 0x27, 0xfe, 0x5d, 0x2a,
	0x48, 0x0b, 0x3a, 0x92, 0x13, 0x70, 0x42, 0x41, 0x60, 0xa4, 0x89, 0x52, 0xff, 0x55, 0x24, 0x59,
	0xb5, 0xc0, 0x2e, 0xc0, 0xc0, 0xc0, 0xc8, 0x48, 0x7f, 0x83, 0x0c, 0x8c, 0xc8, 0xe4, 0xa1, 0xd6,
	0xfe, 0x7d, 0x4a, 0xf9, 0xa1, 0xc6, 0xc8, 0xe5, 0x43, 0x33, 0xf2, 0x37, 0x11, 0x84, 0xbf, 0xf1,
	0x18, 0x7c, 0x0c, 0x84, 0x6f, 0xb8, 0xde, 0x03, 0xb4, 0x2f, 0xb3, 0xa5, 0x28, 0x46, 0xf8, 0x16,
	0xc1, 0xe9, 0x0b, 0x64, 0xf0, 0x49, 0x16, 0xfb, 0x6f, 0x92, 0x0c, 0xf8, 0x5d, 0x34, 0x22, 0x00,
	0x3f, 0x70, 0x8d, 0xe8, 0x84, 0xa2, 0xd0, 0x9b, 0x1a, 0xa1, 0x43, 0x2d, 0x32, 0xe3, 0xbf, 0x45,
	0x6e, 0x46, 0x48, 0x47, 0x64, 0x78, 0x72, 0x42, 0x47, 0x7c, 0x20, 0x62, 0xff, 0x6d, 0x2c, 0x7a,
	0xe2, 0x68, 0x00, 0xc4, 0x7b, 0x8b, 0xad, 0x13, 0x81, 0x12, 0x5c, 0x24, 0x63, 0x11, 0xfb, 0xef,
	0x20, 0xcd, 0x1a, 0x42, 0x03, 0x0b, 0x84, 0xc6, 0xa4, 0xc5, 0xa9, 0x0e, 0xe5, 0xc8, 0xf8, 0x0f,
	0xa9, 0x35, 0xc0, 0x77, 0x7b, 0x84, 0x5e, 0x47, 0x54, 0x92, 0xf9, 0xef, 0x5a, 0xd3, 0xc4, 0xa9,
	0x6e, 0x65, 0xd0, 0x4d, 0xd2, 0x48, 0x1b, 0x9d, 0xc5, 0xfe, 0x23, 0x62, 0xb1, 0x9f, 0x05, 0x46,
	0xf1, 0xb1, 0xff, 0x5e, 0x89, 0x51, 0x7c, 0x5c, 0x60, 0x20, 0xf9, 0x7f, 0x55, 0x62, 0x20, 0xff,
	0x5f, 0x63, 0xcb, 0x36, 0x25, 0x45, 0xec, 0xbf, 0x4f, 0xe7, 0x74, 0x00, 0x30, 0xa2, 0x37, 0xd2,
	0xd3, 0x70, 0xa8, 0xfd, 0x6d, 0x32, 0x02, 0x3e, 0x0f, 0x35, 0x54, 0x3c, 0xe4, 0x84, 0xce, 0x23,
	0x2e, 0xfc, 0x0f, 0xa8, 0x6d, 0x2a, 0x3e, 0xee, 0xc0, 0xb7, 0xf7, 0x06, 0x5b, 0x45, 0xa4, 0x36,
	0x67, 0x4a, 0xe8, 0x33, 0xff, 0x31, 0xe2, 0x57, 0x00, 0x6f, 0x41, 0xde, 0x16, 0x5b, 0x8b, 0x23,
	0x13, 0x85, 0xee, 0xf4, 0x1f, 0x12, 0x0d, 0x00, 0x3b, 0xd6, 0x03, 0x9b, 0x6c, 0xb5, 0xa4, 0x49,
	0x32, 0xff, 0x09, 0xe5, 0x57, 0x41, 0xd2, 0xca, 0x50, 0xd1, 0x24, 0x8b, 0x5d, 0x9d, 0x7e, 0x64,
	0x15, 0x4d, 0xb2, 0xb8, 0x28, 0xd4, 0xb7, 0xd8, 0xba, 0xce, 0xe2, 0xde, 0xa8, 0xef, 0x88, 0x3e,
	0x46, 0xa2, 0x35, 0x82, 0x16, 0x64, 0x75, 0xb6, 0x28, 0x78, 0xe6, 0x7f, 0x82, 0x85, 0x0e, 0x3f,
	0xc1, 0x65, 0x82, 0x67, 0x5a, 0x88, 0xcc, 0xff, 0x14, 0xa1, 0xc5, 0xe7, 0x96, 0x66, 0xcb, 0x6e,
	0x14, 0x83, 0xff, 0xa0, 0x2f, 0x69, 0x13, 0x0d, 0x69, 0x52, 0x2f, 0x06, 0x25, 0xc0, 0xbb, 0xcf,
	0x6a, 0x66, 0x9a, 0x0b, 0xec, 0xde, 0xeb, 0x4f, 0x56, 0xb6, 0x89, 0xa9, 0x3b, 0xcd, 0x45, 0x80,
	0x08, 0xef, 0x1d, 0x76, 0x5d, 0x63, 0xfb, 0x82, 0xd1, 0x00, 0x1d, 0x6f, 0x6d, 0xbb, 0xda, 0xca,
	0x83, 0x02, 0xbb, 0xf5, 0xaf, 0x57, 0xd9, 0x4a, 0xab, 0x1f, 0x71, 0x61, 0xf5, 0xbe, 0x68, 0x54,
	0x40, 0x50, 0x2e, 0x42, 0xa1, 0x94, 0x54, 0xc5, 0x20, 0xba, 0xa1, 0x2e, 0xf6, 0xf0, 0x1b, 0x1b,
	0xc7, 0x05, 0x8e, 0xb9, 0x5c, 0xd0, 0xf4, 0xa8, 0x05, 0xcb, 0xea, 0x62, 0x97, 0x00, 0x58, 0xcb,
	0x17, 0xa1, 0x1c, 0x0b, 0xa5, 0x46, 0x99, 0xc6, 0xa1, 0x50, 0x0b, 0x98, 0xba, 0x68, 0x5b, 0x08,
	0xa4, 0xaa, 0xba, 0x08, 0xfb, 0x0a, 0x94, 0x5e, 0x43, 0xec, 0x75, 0x75, 0xb1, 0xaf, 0xac, 0x5e,
	0xe3, 0xf4, 0x2e, 0x91, 0x5e, 0x53, 0xd1, 0x6b, 0x4a, 0xbd, 0xd7, 0x49, 0xaf, 0xa9, 0xea, 0x35,
	0x15, 0xbd, 0x37, 0x48, 0xaf, 0x29, 0xf5, 0x12, 0x3f, 0x8f, 0x94, 0x4a, 0x84, 0xc2, 0x09, 0x8d,
	0xfc, 0x4d, 0x02, 0x40, 0x8b, 0x01, 0xb4, 0x4c, 0xd3, 0x44, 0x27, 0x32, 0xd3, 0x38, 0x15, 0x6a,
	0xc1, 0xaa, 0xb9, 0x68, 0x3a, 0xd8, 0x56, 0xce, 0x96, 0xdd, 0x72, 0xf4, 0x97, 0x46, 0xec, 0x01,
	0x5b, 0x4a, 0x20, 0x0e, 0x45, 0xc0, 0x56, 0xb7, 0x2b, 0x61, 0x09, 0x2c, 0x6e, 0xeb, 0xbf, 0x3f,
	0x65, 0x6b, 0x33, 0xfb, 0xd6, 0x5f, 0xaa, 0xf6, 0x0b, 0x76, 0x37, 0xc9, 0xa9, 0x8b, 0x86, 0x79,
	0x84, 0x39, 0x51, 0xf6, 0x16, 0x8a, 0xe6, 0xcb, 0x49, 0x8e, 0x1d, 0xf5, 0x98, 0xd0, 0xae, 0xc9,
	0xbc, 0xc1, 0x56, 0x93, 0x3c, 0xec, 0x4b, 0x35, 0x89, 0x54, 0x2c, 0x62, 0x1b, 0xdb, 0x95, 0x24,
	0xdf, 0x2f, 0x40, 0x5e, 0x83, 0xbd, 0x9e, 0xe4, 0x61, 0x92, 0x71, 0x39, 0x84, 0x99, 0x56, 0x28,
	0x88, 0x13, 0xcd, 0x89, 0x87, 0x22, 0xfe, 0x6a, 0x92, 0xb7, 0x2c, 0x8d, 0x55, 0xb2, 0x5b, 0x50,
	0x5c, 0x2a, 0xc2, 0x35, 0x97, 0xa5, 0xcb, 0x44, 0xb8, 0x6e, 0xf3, 0x01, 0xbb, 0x9d, 0xe4, 0xa1,
	0x12, 0xe7, 0x23, 0xa1, 0x0d, 0xb5, 0x5e, 0xec, 0x0d, 0x94, 0x34, 0xb7, 0x92, 0x3c, 0xb0, 0x28,
	0xe8, 0xc1, 0xd0, 0x21, 0xbe, 0x66, 0xf7, 0x92, 0x1c, 0x48, 0x4e, 0xe5, 0x8c, 0x4e, 0x9b, 0x6c,
	0x94, 0x4c, 0x7e, 0x92, 0xb7, 0x2d, 0x45, 0xa1, 0xd1, 0xe6, 0xde, 0x77, 0xec, 0xcd, 0x24, 0x2f,
	0xa8, 0xc3, 0x9e, 0xe0, 0xd1, 0x48, 0x8b, 0x50, 0xf6, 0xc3, 0x61, 0xa2, 0x35, 0xce, 0x76, 0x39,
	0x32, 0xc2, 0xe6, 0xdc, 0x46, 0x92, 0x5b, 0xbe, 0x1d, 0x22, 0x6c, 0xf7, 0x0f, 0x89, 0x2c, 0x00,
	0x2a, 0xef, 0x77, 0x6c, 0x0b, 0xbc, 0xac, 0xa2, 0xd3, 0xa1, 0xc8, 0x4a, 0x23, 0xc2, 0xa8, 0x6f,
	0x84, 0xc2, 0xf5, 0x10, 0x8e, 0xc2, 0x0a, 0x59, 0xfb, 0x05, 0xa1, 0x15, 0xda, 0x00, 0xb2, 0x2e,
	0x51, 0x79, 0x9f, 0x33, 0x1f, 0x1d, 0x11, 0x69, 0x2d, 0x86, 0xbd, 0x34, 0xc1, 0x39, 0x72, 0x3e,
	0x4a, 0xc0, 0x8d, 0x2b, 0x45, 0xac, 0x83, 0x0a, 0x3a, 0xb0, 0x58, 0x9b, 0x26, 0x65, 0x82, 0x58,
	0x12, 0x11, 0x87, 0x92, 0xf6, 0x1e, 0x64, 0x75, 0x19, 0xe2, 0xd0, 0xed, 0x81, 0xf7, 0x2d, 0x7b,
	0xcd, 0xb1, 0x56, 0x38, 0x75, 0xd8, 0x8f, 0x92, 0x54, 0xc4, 0xb8, 0x20, 0xd5, 0x82, 0xbb, 0x05,
	0x77, 0xc9, 0xac, 0xf7, 0x91, 0xc0, 0xdb, 0x63, 0xf7, 0x0d, 0xcf, 0xc3, 0x88, 0x9b, 0x64, 0x2c,
	0x42, 0x2e, 0xb3, 0x4c, 0x70, 0x03, 0xf5, 0x17, 0xca, 0x5c, 0x64, 0x49, 0x76, 0xaa, 0x71, 0x91,
	0xaa, 0x05, 0xaf, 0x19, 0x9e, 0x37, 0x90, 0xaa, 0x59, 0x12, 0xb5, 0x2d, 0x4d, 0x21, 0x26, 0x8f,
	0xb4, 0x9e, 0x95, 0x53, 0x8a, 0xb9, 0xe9, 0xc4, 0x1c, 0x13, 0x55, 0x29, 0xc7, 0x89, 0x69, 0xb2,
	0x0d, 0x10, 0x43, 0xc6, 0x57, 0xa5, 0x44, 0xc6, 0x88, 0x61, 0x6e, 0x34, 0x6e, 0x64, 0xb5, 0xe0,
	0x9e, 0xe1, 0x39, 0x1d, 0xa0, 0x14, 0xd2, 0xb0, 0x24, 0x85, 0x90, 0x0a, 0xb7, 0x12, 0x7a, 0xa6,
	0xf4, 0x6e, 0x39, 0x21, 0x25, 0x7b, 0x80, 0x34, 0xae, 0xfe, 0xbe, 0x61, 0xf7, 0x66, 0x85, 0xe8,
	0x10, 0xaa, 0xbe, 0x97, 0x26, 0xfa, 0x4c, 0xc4, 0xb8, 0xe2, 0xd5, 0x82, 0xbb, 0x33, 0x12, 0xf4,
	0x5e, 0x49, 0xe0, 0x3d, 0x61, 0x77, 0x80, 0x5f, 0x0b, 0x9b, 0x59, 0x4e, 0xf7, 0x4b, 0xc8, 0xf9,
	0x92, 0xe1, 0x79, 0xc7, 0xe2, 0x9c, 0xce, 0x0f, 0xe7, 0x78, 0x70, 0xa9, 0x87, 0x04, 0xbc, 0x8d,
	0x3c, 0x5e, 0x85, 0xa7, 0x23, 0xb2, 0x18, 0x8a, 0xe9, 0x2b, 0xf6, 0xea, 0x9c, 0x1a, 0x5c, 0xd2,
	0x86, 0x89, 0x81, 0xa9, 0x79, 0x87, 0x6a, 0x69, 0x46, 0x57, 0x05, 0x0f, 0x89, 0x07, 0xdc, 0xbd,
	0x28, 0x7e, 0x81, 0xa1, 0x2f, 0x53, 0xe2, 0x19, 0x9e, 0xef, 0x44, 0xf1, 0x73, 0xb6, 0xbe, 0xcd,
	0x6e, 0x02, 0xab, 0xf5, 0x2c, 0x2e, 0x5c, 0xaf, 0xd0, 0xb2, 0x64, 0x78, 0x4e, 0xbe, 0xc4, 0xa5,
	0xeb, 0x31, 0xbb, 0x3d, 0x8a, 0xf3, 0xe7, 0xbb, 0x9f, 0x4f, 0x47, 0x1a, 0xc5, 0xf9, 0x7c, 0xe7,
	0x3b, 0x64, 0x0f, 0xaa, 0x1c, 0x46, 0x86, 0xa3, 0x6c, 0x90, 0xc9, 0x49, 0x16, 0xe6, 0x52, 0x99,
	0x52, 0xc2, 0x5d, 0x94, 0x70, 0xbf, 0x94, 0xd0, 0x95, 0xcf, 0x88, 0xf0, 0x58, 0x2a, 0xe3, 0xc4,
	0x7d, 0xc1, 0xee, 0x96, 0xe2, 0x0a, 0xee, 0x62, 0xee, 0xbd, 0x4a, 0x67, 0x74, 0x32, 0x2c, 0x97,
	0x9d, 0x82, 0x0f, 0x59, 0xbd, 0x6a, 0x09, 0x1e, 0xf2, 0x1e, 0x72, 0xac, 0x97, 0x5a, 0xf1, 0x94,
	0x56, 0x49, 0x21, 0xbd, 0x37, 0xea, 0xf7, 0x85, 0x2a, 0x94, 0xbc, 0xe6, 0x94, 0x58, 0xf1, 0x3b,
	0x88, 0xb6, 0x4a, 0x3e, 0x62, 0x80, 0xa1, 0x58, 0xcf, 0xf2, 0xbd, 0x4e, 0x99, 0x32, 0x8a, 0x73,
	0x88, 0xf6, 0x0c, 0xd3, 0x23, 0x76, 0x0b, 0x98, 0x92, 0xd3, 0x4c, 0x2a, 0x11, 0x87, 0xc3, 0x51,
	0x6a, 0x12, 0x5c, 0xc6, 0x6b, 0xc1, 0xcd, 0x51, 0x9c, 0xb7, 0x08, 0x7e, 0x08, 0x60, 0xef, 0x80,
	0xbd, 0x69, 0x78, 0x2e, 0x2e, 0x4c, 0x98, 0x64, 0xe3, 0x28, 0x4d, 0xe2, 0x50, 0x4f, 0xb3, 0x90,
	0x4b, 0x39, 0x48, 0xaa, 0xab, 0xee, 0x7d, 0x72, 0x27, 0x91, 0xb6, 0x88, 0xb2, 0x33, 0xcd, 0x9a,
	0x44, 0xe7, 0xdc, 0x39, 0x64, 0x9f, 0x58, 0x69, 0x73, 0x45, 0x05, 0xb3, 0x2a, 0x14, 0xc3, 0x9e,
	0x9a, 0xca, 0x2c, 0xe1, 0xa8, 0x03, 0xef, 0xaa, 0xc5, 0xa6, 0xb4, 0x89, 0xf2, 0xb7, 0x89, 0x79,
	0xb6, 0xd8, 0xf6, 0xa5, 0xda, 0x2b, 0x18, 0x3b, 0xd3, 0x2c, 0x10, 0x7c, 0x4c, 0xfb, 0x94, 0xf6,
	0x26, 0xec, 0xcb, 0xc2, 0x78, 0x3e, 0xcc, 0xe7, 0x87, 0x85, 0x6b, 0xff, 0xe6, 0x4c, 0x4c, 0xc3,
	0x89, 0x50, 0x02, 0xca, 0x05, 0x86, 0xc1, 0x24, 0xc9, 0x62, 0x39, 0xc1, 0x4b, 0x46, 0x2d, 0x78,
	0x62, 0x0f, 0xc5, 0x87, 0xf9, 0xec, 0x30, 0xb1, 0x43, 0xa1, 0x7b, 0x26, 0xa6, 0x27, 0x42, 0x89,
	0xf6, 0xc8, 0xb4, 0xfb, 0x27, 0xc8, 0x59, 0x39, 0xe7, 0x2f, 0x2a, 0xa6, 0xd3, 0x85, 0x93, 0x48,
	0x87, 0xa9, 0xc4, 0x6b, 0xc5, 0x56, 0xf5, 0x9c, 0x97, 0xaa, 0xa4, 0xf3, 0x9d, 0x44, 0xfa, 0x00,
	0xb9, 0xbc, 0x33, 0xf6, 0x91, 0x55, 0x87, 0xe5, 0x4c, 0xa7, 0x0f, 0xfb, 0x49, 0x86, 0xdd, 0x84,
	0x1e, 0x2a, 0x26, 0x51, 0x02, 0x31, 0x0c, 0xfb, 0x91, 0x36, 0x08, 0x51, 0x78, 0x2d, 0xaa, 0x05,
	0xef, 0x11, 0x6b, 0x97, 0xe7, 0xd6, 0x6d, 0xfb, 0x96, 0x0f, 0x46, 0xd3, 0x49, 0x94, 0x98, 0x56,
	0xb6, 0x1f, 0x69, 0x83, 0xb7, 0x72, 0xef, 0x1f, 0x17, 0xd8, 0xbe, 0x55, 0x55, 0x16, 0xe5, 0x1f,
	0x04, 0x37, 0xb0, 0xae, 0x57, 0x7b, 0xdc, 0x4c, 0xef, 0xab, 0xcc, 0xd9, 0x72, 0x21, 0x7a, 0x80,
	0xda, 0xbf, 0x21, 0x69, 0xae, 0x8c, 0x51, 0x56, 0x2b, 0xab, 0x34, 0xc3, 0x4a, 0x8b, 0x74, 0x63,
	0xb8, 0xeb, 0xb6, 0xa8, 0xcf, 0x98, 0x6f, 0xed, 0x89, 0x45, 0x1a, 0x4d, 0x61, 0xfa, 0xf2, 0x41,
	0xe5, 0x0e, 0x57, 0x0b, 0xee, 0x10, 0x7e, 0x97, 0xd0, 0x0d, 0x3e, 0xa0, 0xa2, 0xfb, 0x23, 0xfb,
	0xea, 0x45, 0x8c, 0xfd, 0x91, 0x32, 0x67, 0x42, 0x39, 0x60, 0xc5, 0x74, 0x0a, 0x91, 0x75, 0xaf,
	0xbd, 0x00, 0x7e, 0xfc, 0x9c, 0xf0, 0x7d, 0x12, 0x60, 0x21, 0xce, 0x62, 0x8a, 0x14, 0x79, 0xd8,
	0xfb, 0x81, 0xbd, 0x6b, 0x75, 0x9f, 0x8f, 0x12, 0x3e, 0x00, 0xcd, 0xe1, 0x50, 0xc6, 0x02, 0x33,
	0x01, 0x87, 0x69, 0x64, 0x6c, 0xdc, 0xb4, 0xbd, 0x45, 0xda, 0x2a, 0xfc, 0x1e, 0xe8, 0x1b, 0x7c,
	0x70, 0x28, 0x63, 0x71, 0x12, 0xe9, 0x46, 0x41, 0x8b, 0x0e, 0xf1, 0xfe, 0xc0, 0x3e, 0x2e, 0xf2,
	0x00, 0xbe, 0x21, 0xb1, 0xc3, 0x34, 0xd1, 0x46, 0x64, 0xf4, 0x82, 0x06, 0xa7, 0x88, 0x8a, 0xac,
	0x83, 0x05, 0xbc, 0x9f, 0xca, 0x89, 0x88, 0xf1, 0x1e, 0x5a, 0x0b, 0x7e, 0x65, 0x13, 0x01, 0x58,
	0xbb, 0x67, 0xe2, 0x00, 0x19, 0xf1, 0x9d, 0xad, 0xdd, 0x6f, 0x90, 0xe5, 0x6d, 0xc7, 0xe3, 0xb5,
	0xd9, 0x5b, 0x56, 0x97, 0x9e, 0xe2, 0x65, 0xbf, 0xd0, 0x54, 0xa4, 0x5f, 0xb1, 0x92, 0xbd, 0x8b,
	0xc2, 0x37, 0x89, 0xb8, 0x33, 0xcd, 0x74, 0x57, 0x92, 0x68, 0x9b, 0x6e, 0xc5, 0x6a, 0x46, 0x4b,
	0x40, 0x99, 0x59, 0xe1, 0x99, 0x88, 0x62, 0xa1, 0x74, 0x98, 0x2b, 0x11, 0x27, 0x1c, 0x26, 0xd2,
	0x23, 0xb7, 0x04, 0xb8, 0x94, 0x79, 0x4a, 0x44, 0xc7, 0x05, 0x8d, 0xf7, 0x47, 0x57, 0xf3, 0x11,
	0x87, 0x7e, 0x9e, 0x8a, 0xd8, 0xce, 0xa6, 0x4c, 0x1a, 0xc8, 0x4a, 0x13, 0x25, 0xb0, 0x2e, 0x84,
	0x78, 0xd1, 0xcc, 0xa3, 0x69, 0x2a, 0xa3, 0xb8, 0x6c, 0x64, 0xef, 0xa1, 0x0a, 0x5b, 0xbd, 0x8d,
	0x59, 0x09, 0x47, 0xd2, 0x34, 0x1d, 0xff, 0x6e, 0x64, 0xa2, 0x63, 0xe2, 0x76, 0xed, 0xed, 0x29,
	0xdb, 0x2c, 0x8e, 0x50, 0xd8, 0x33, 0x6f, 0x05, 0x5e, 0xc6, 0x6b, 0xc1, 0x86, 0x3d, 0x43, 0x41,
	0x36, 0xa7, 0xc9, 0xfb, 0x87, 0x05, 0xb6, 0x37, 0x13, 0x4a, 0x25, 0xb8, 0xc4, 0x95, 0x39, 0xec,
	0x2b, 0x39, 0x2c, 0x5c, 0x94, 0x4a, 0xad, 0xc3, 0xde, 0x34, 0xd4, 0x22, 0x15, 0xb4, 0x83, 0x95,
	0xea, 0x04, 0xe9, 0x7b, 0x1f, 0xf5, 0x7d, 0x5d, 0x89, 0x6d, 0x50, 0x88, 0xda, 0x57, 0x72, 0x48,
	0x5e, 0x3c, 0x90, 0x5a, 0xef, 0x4c, 0x3b, 0x85, 0x94, 0xc6, 0x9c, 0x10, 0xef, 0xf7, 0xec, 0x3d,
	0x57, 0x2c, 0x46, 0xe0, 0xb9, 0x94, 0x90, 0x2a, 0x16, 0x0a, 0x3c, 0x49, 0x16, 0x8e, 0x70, 0x7f,
	0xc6, 0xd7, 0xb6, 0x6d, 0xd4, 0xf9, 0x76, 0x51, 0x1b, 0xc4, 0x11, 0x38, 0x06, 0xb4, 0xe2, 0x19,
	0x90, 0x77, 0x22, 0x3e, 0xf0, 0xfe, 0xce, 0x55, 0x22, 0x97, 0xd9, 0xa9, 0xd0, 0xb8, 0x74, 0x51,
	0x0b, 0x86, 0x7a, 0x4c, 0xd3, 0x69, 0xe5, 0xf4, 0x93, 0xc4, 0x9c, 0x41, 0x97, 0xd6, 0xa9, 0x9c,
	0x84, 0xda, 0x44, 0xca, 0xe0, 0x5b, 0x84, 0x0b, 0x59, 0xd3, 0x89, 0xa0, 0x56, 0xac, 0xf7, 0x41,
	0x80, 0x3b, 0xf2, 0x09, 0xb1, 0x77, 0x52, 0x39, 0xe9, 0x00, 0xb3, 0xf7, 0xf7, 0x0b, 0xec, 0xdb,
	0xcb, 0xb5, 0xff, 0x92, 0x5e, 0xf0, 0x7b, 0x8c, 0xc7, 0x7d, 0x8c, 0x06, 0x7c, 0x76, 0x89, 0x01,
	0x97, 0xea, 0xde, 0x99, 0xee, 0xe2, 0x7b, 0xe4, 0x3f, 0x2f, 0xb0, 0xa7, 0xff, 0x47, 0x13, 0xe8,
	0xa6, 0x91, 0x47, 0xca, 0x24, 0x51, 0x0a, 0xb1, 0xc7, 0x47, 0x95, 0x5a, 0xf0, 0xed, 0xff, 0xd6,
	0x16, 0xbc, 0x8b, 0x1c, 0x93, 0x9c, 0x06, 0x1f, 0x78, 0x5f, 0xe2, 0x66, 0x58, 0x4c, 0x94, 0x54,
	0x6a, 0x53, 0x59, 0x0e, 0xf1, 0x59, 0xa6, 0x16, 0xbc, 0xe2, 0x06, 0xc7, 0x81, 0xd4, 0xa6, 0xdc,
	0x0d, 0x2b, 0x3b, 0x83, 0xbd, 0x03, 0x69, 0x6b, 0x28, 0x1c, 0xb7, 0x38, 0xd0, 0x14, 0x9f, 0x6e,
	0xdc, 0xce, 0x60, 0xef, 0x41, 0x1a, 0x0d, 0x81, 0xb4, 0xb0, 0xa6, 0x4e, 0xbd, 0xdf, 0xb0, 0xd7,
	0xe7, 0xa5, 0x25, 0x19, 0x65, 0x3e, 0x3d, 0x79, 0x7f, 0xec, 0xb6, 0xe9, 0x8a, 0x9c, 0x56, 0x06,
	0x39, 0x8d, 0xef, 0xdf, 0xde, 0xa7, 0xcc, 0x9a, 0x4a, 0xc3, 0xaf, 0x3c, 0x88, 0xc6, 0xd7, 0x1f,
	0x37, 0x22, 0x60, 0xcc, 0x95, 0xc7, 0xd0, 0xde, 0xbe, 0x2b, 0xe7, 0x0a, 0x0b, 0x28, 0xaf, 0x24,
	0xdf, 0xa7, 0xd5, 0x96, 0x54, 0x61, 0x6e, 0x65, 0x65, 0x8e, 0xd1, 0xa2, 0x0c, 0x72, 0x24, 0xce,
	0x16, 0x70, 0x69, 0x71, 0x16, 0xff, 0x33, 0xb7, 0x28, 0x8b, 0x0b, 0xd3, 0x06, 0x7c, 0x97, 0xe7,
	0xc5, 0x29, 0x60, 0xbf, 0x9b, 0x8d, 0x03, 0xb4, 0x43, 0xd9, 0x13, 0xda, 0xff, 0xdc, 0xdd, 0x04,
	0x5c, 0x0c, 0xf4, 0x31, 0xa2, 0xbc, 0x1d, 0xb6, 0xf1, 0x42, 0xa6, 0xd2, 0xf5, 0x5f, 0xd0, 0xc5,
	0xfc, 0x79, 0x66, 0xe7, 0xf5, 0xa6, 0x93, 0x61, 0x83, 0x56, 0x3a, 0xc0, 0x5e, 0x0e, 0x7f, 0xed,
	0xae, 0x41, 0xd0, 0xd7, 0x31, 0x62, 0x8e, 0xc6, 0x5e, 0x0f, 0xbf, 0x66, 0xf7, 0x2a, 0x86, 0xf4,
	0x22, 0x3e, 0x48, 0xe5, 0x69, 0xc8, 0x65, 0x94, 0x0a, 0xcd, 0x85, 0xff, 0xa5, 0xbb, 0x60, 0x90,
	0x15, 0x3b, 0x44, 0xd0, 0xb4, 0x78, 0xaf, 0xc5, 0xb6, 0x8a, 0xae, 0xa3, 0xdd, 0x54, 0xc7, 0x4d,
	0x51, 0xa6, 0x71, 0xb1, 0x7f, 0xf8, 0x5f, 0xa1, 0x14, 0x9b, 0x23, 0x58, 0x51, 0x38, 0xe0, 0xf7,
	0xa5, 0x6a, 0xa7, 0xb1, 0xdd, 0x2b, 0xbc, 0x1f, 0xcb, 0x06, 0x36, 0x2f, 0x8a, 0x56, 0x3e, 0xec,
	0x4d, 0x4e, 0xe6, 0xd7, 0x28, 0xf3, 0xc1, 0x8b, 0x64, 0xc2, 0x96, 0xd7, 0x06, 0xe2, 0x42, 0xf4,
	0xc7, 0x2e, 0x44, 0x56, 0xb4, 0x9b, 0x25, 0xdf, 0xa0, 0x94, 0xdb, 0x55, 0x29, 0x6e, 0x54, 0x44,
	0xec, 0x83, 0x59, 0xae, 0xcb, 0x6c, 0x29, 0xc5, 0x7d, 0x8b, 0xe2, 0x1e, 0x56, 0xc5, 0xbd, 0xc8,
	0x20, 0xa7, 0xa2, 0xe7, 0x54, 0x54, 0x77, 0x31, 0x5c, 0xbc, 0xc3, 0x78, 0x24, 0xe8, 0x6e, 0x24,
	0x2e, 0x72, 0xea, 0xe7, 0x30, 0x0e, 0xfd, 0xdf, 0xa0, 0x8a, 0x77, 0x5d, 0xf7, 0x28, 0xb8, 0x70,
	0xe3, 0xde, 0x1d, 0x09, 0xb8, 0x24, 0x15, 0x1c, 0x30, 0x00, 0x3d, 0xce, 0x1e, 0xff, 0x39, 0x1d,
	0x22, 0x52, 0xe9, 0x34, 0x1c, 0x69, 0xa1, 0x42, 0x9e, 0x4a, 0x2d, 0xfc, 0xc6, 0x9f, 0x55, 0xb2,
	0x07, 0x2c, 0xcf, 0xb4, 0x50, 0x4d, 0x60, 0xf0, 0x4e, 0xdc, 0xba, 0x54, 0x55, 0x12, 0xf5, 0xa4,
	0x42, 0xc3, 0x49, 0x4d, 0xf1, 0xdc, 0xb2, 0x53, 0x0d, 0x5d, 0x45, 0x7a, 0x83, 0xc8, 0x51, 0x7e,
	0xf1, 0xe8, 0xf2, 0x0d, 0x7b, 0xad, 0x92, 0x9f, 0x18, 0x08, 0x77, 0x2b, 0x92, 0x69, 0xec, 0x37,
	0xe7, 0x12, 0x14, 0x9d, 0x6e, 0xaf, 0x47, 0xed, 0x14, 0x56, 0x96, 0xcd, 0x4b, 0xf9, 0x33, 0xf0,
	0x6e, 0x2c, 0xfd, 0xdd, 0x6a, 0x99, 0xcc, 0xc9, 0x38, 0x92, 0xcf, 0xb2, 0x58, 0x56, 0x76, 0x58,
	0x5c, 0xdf, 0xf3, 0x91, 0x4a, 0xe4, 0x48, 0x87, 0xca, 0x48, 0xed, 0xef, 0x55, 0x1b, 0x14, 0xec,
	0xe8, 0x16, 0x1b, 0x18, 0x39, 0xdf, 0x1d, 0x50, 0xfd, 0x50, 0xa8, 0x53, 0x11, 0xfb, 0xfb, 0x73,
	0xdd, 0x01, 0xea, 0xf3, 0x10, 0x51, 0x73, 0xdd, 0x01, 0x99, 0xf4, 0x59, 0xd2, 0x87, 0xe6, 0x98,
	0xa6, 0x50, 0xa3, 0xfe, 0x6f, 0xe7, 0xba, 0x03, 0x30, 0x77, 0x80, 0x64, 0xdf, 0x52, 0x54, 0x7a,
	0x32, 0x3e, 0x5a, 0x8d, 0x85, 0xd2, 0x22, 0xcc, 0x23, 0x73, 0x16, 0xf6, 0x93, 0xd4, 0x08, 0xe5,
	0x3f, 0xad, 0xf6, 0xe4, 0x56, 0x1e, 0x10, 0xc9, 0x71, 0x64, 0xce, 0xf6, 0x91, 0xc0, 0xfb, 0xc4,
	0xf5, 0x64, 0x7a, 0x08, 0xa0, 0x3f, 0x19, 0x41, 0x6b, 0xf1, 0x5b, 0xd5, 0xb2, 0xe9, 0xf2, 0xdc,
	0xf6, 0x15, 0xe8, 0x29, 0xf3, 0x6c, 0x7c, 0x5c, 0x76, 0x93, 0xdf, 0xcd, 0xb3, 0xf1, 0xb1, 0xeb,
	0x24, 0x1f, 0xb0, 0xdb, 0x15, 0x36, 0xd9, 0x97, 0xb4, 0x0f, 0xfb, 0xdf, 0xd1, 0x33, 0xa3, 0xe3,
	0x69, 0xf7, 0x25, 0x2e, 0xbc, 0x2f, 0x60, 0x40, 0xc7, 0xfa, 0x07, 0xcf, 0x33, 0xa0, 0x5b, 0xe7,
	0x62, 0xc8, 0xcf, 0xa2, 0x34, 0x15, 0xd9, 0x29, 0xee, 0x63, 0xfe, 0xe1, 0x5c, 0x0c, 0x9b, 0x05,
	0x16, 0x26, 0xed, 0x5c, 0xf0, 0xe1, 0x72, 0x5d, 0xa0, 0xfd, 0xa3, 0xf9, 0xe0, 0x4f, 0x33, 0xc7,
	0x3b, 0x97, 0x7c, 0x38, 0xd9, 0x64, 0x2e, 0xb2, 0xe2, 0x31, 0x0e, 0x5d, 0xd9, 0x9e, 0x4b, 0x3e,
	0x98, 0x70, 0xed, 0x5c, 0x64, 0xf4, 0x14, 0x87, 0x1e, 0xbd, 0x4c, 0x0c, 0x5d, 0xf1, 0x43, 0x25,
	0xce, 0x63, 0xff, 0xf8, 0x12, 0x31, 0x74, 0xbd, 0x0f, 0xc4, 0xf9, 0x7c, 0x56, 0x95, 0x62, 0x7a,
	0x69, 0xc4, 0x07, 0x67, 0x32, 0x15, 0xfe, 0xf7, 0x73, 0x59, 0x55, 0x08, 0xd9, 0x29, 0x28, 0xbc,
	0xef, 0xca, 0xbd, 0x61, 0xb6, 0x0e, 0x2e, 0xc2, 0x33, 0xd8, 0x40, 0x30, 0x66, 0xda, 0x0f, 0xaa,
	0x1b, 0xf4, 0x4c, 0x49, 0x5c, 0x3c, 0x95, 0xda, 0x60, 0x00, 0xf5, 0x5c, 0xa6, 0x44, 0x23, 0x23,
	0x43, 0x2e, 0xd5, 0x20, 0xc9, 0x4e, 0xfd, 0xce, 0x5c, 0xa6, 0x34, 0x46, 0x46, 0x36, 0x09, 0x37,
	0x5f, 0x52, 0xf8, 0x0e, 0x41, 0x7f, 0xc7, 0xef, 0xce, 0x97, 0xd4, 0x34, 0xb3, 0x99, 0xe9, 0x7d,
	0xee, 0x06, 0x3c, 0x66, 0x8b, 0x4a, 0xec, 0xed, 0x02, 0x6f, 0xa1, 0xcf, 0xe6, 0x82, 0xd8, 0x56,
	0x09, 0x5e, 0x1e, 0xf0, 0x16, 0xba, 0xeb, 0x2e, 0x3d, 0xc0, 0x79, 0x36, 0xa5, 0xb5, 0xce, 0xa8,
	0x28, 0xc9, 0xec, 0xaa, 0xed, 0xff, 0x30, 0xe7, 0xfc, 0xa7, 0x44, 0xd4, 0x05, 0x1a, 0xda, 0xad,
	0xab, 0x2b, 0xd2, 0x73, 0x52, 0xf0, 0x0f, 0xa0, 0x27, 0x33, 0x2b, 0xd2, 0xac, 0x8c, 0xe6, 0x24,
	0x8b, 0x2f, 0xb1, 0x03, 0x2f, 0xc1, 0x85, 0x1d, 0xff, 0xef, 0xc5, 0x76, 0xe0, 0x45, 0xf7, 0x17,
	0xed, 0x20, 0x29, 0x68, 0xc7, 0x8f, 0x2f, 0xb6, 0x03, 0x65, 0xa0, 0x1d, 0xbf, 0x9e, 0xd9, 0x3b,
	0xb1, 0x37, 0x0d, 0x12, 0x7c, 0x33, 0xd1, 0xe2, 0xdc, 0xff, 0xff, 0xd5, 0x5d, 0x09, 0x02, 0xc7,
	0x07, 0x1d, 0x42, 0x77, 0xc4, 0x79, 0x65, 0x5d, 0x9b, 0xe7, 0x2d, 0x2b, 0xea, 0xf7, 0xd5, 0x75,
	0x6d, 0x46, 0x42, 0x59, 0x58, 0xf4, 0x90, 0x5a, 0xc8, 0x19, 0x08, 0x91, 0x87, 0x51, 0x9a, 0x8c,
	0x85, 0xff, 0x57, 0xee, 0x21, 0x95, 0x98, 0xbf, 0x13, 0x22, 0x6f, 0x00, 0xc6, 0x7b, 0x3c, 0xd3,
	0x2e, 0xca, 0x3f, 0x80, 0xfc, 0xf5, 0x1c, 0x47, 0xf9, 0x87, 0x8f, 0x2f, 0x66, 0x52, 0x06, 0x8c,
	0xe5, 0x72, 0x98, 0x2b, 0xa1, 0xb5, 0x88, 0xfd, 0xbf, 0x79, 0xfe, 0x9c, 0x4d, 0x87, 0xf5, 0xde,
	0x67, 0x2f, 0x25, 0xf6, 0x45, 0x2e, 0xec, 0x71, 0xa8, 0xb4, 0x7c, 0x60, 0xb4, 0x1f, 0x22, 0x53,
	0x3d, 0xa1, 0x17, 0xb8, 0x1d, 0x40, 0x1c, 0x0f, 0x8c, 0xf6, 0xde, 0x66, 0x37, 0x1d, 0xb9, 0xe4,
	0x06, 0xd6, 0x9b, 0xbf, 0xa5, 0xb7, 0x56, 0x4b, 0xda, 0x46, 0xa0, 0xf7, 0x90, 0x11, 0x2f, 0x6d,
	0x21, 0x44, 0x18, 0xd1, 0x7b, 0x25, 0xc2, 0x61, 0xd1, 0x20, 0xca, 0x0f, 0xd9, 0x9d, 0x39, 0x03,
	0x2c, 0x79, 0x8f, 0x8e, 0x5b, 0x35, 0xc1, 0xb2, 0x6c, 0xb3, 0xdb, 0x8e, 0x25, 0x93, 0xa1, 0xe0,
	0xd6, 0x68, 0x3e, 0x63, 0xf4, 0x91, 0xdc, 0xe3, 0x64, 0xf4, 0x7b, 0xcc, 0x73, 0xf4, 0x82, 0x9b,
	0xc7, 0x44, 0x1d, 0xd3, 0x1b, 0xa5, 0xa5, 0xde, 0xe3, 0xe6, 0x31, 0x10, 0x3f, 0x7a, 0x87, 0xb1,
	0xf2, 0x8f, 0x67, 0xde, 0x75, 0xb6, 0xd8, 0x6d, 0x1e, 0xd7, 0xaf, 0xc0, 0x8f, 0xa3, 0x56, 0xb3,
	0xbe, 0x80, 0x3f, 0xf6, 0xba, 0xf5, 0xab, 0x8f, 0xfe, 0x73, 0x81, 0xad, 0x54, 0xfe, 0x31, 0xc6,
	0x7b, 0x89, 0xdd, 0xec, 0x36, 0x8f, 0xc3, 0xbd, 0x4e, 0xb7, 0xb1, 0x73, 0xd0, 0xea, 0x3c, 0xdd,
	0xdb, 0xad, 0x5f, 0xf1, 0xea, 0x6c, 0x15, 0x80, 0x9d, 0x1f, 0x8f, 0xc2, 0xce, 0xde, 0x51, 0xb7,
	0xbe, 0x50, 0x85, 0x04, 0x7b, 0xcd, 0x1f, 0xea, 0x57, 0xbd, 0x5b, 0x6c, 0x0d, 0x20, 0xfb, 0xad,
	0xa3, 0xf0, 0xa4, 0xd1, 0xea, 0x7e, 0x58, 0x5f, 0x9c, 0x07, 0x3d, 0xa9, 0xd7, 0x0a, 0x50, 0xb7,
	0x75, 0xb8, 0x87, 0xb0, 0xfa, 0x35, 0x6f, 0x8d, 0x2d, 0x03, 0xa8, 0x79, 0xd0, 0xee, 0xec, 0xd5,
	0x97, 0x3c, 0x8f, 0xad, 0xbb, 0x4f, 0x22, 0xb9, 0x5e, 0x68, 0x3b, 0x68, 0x74, 0xba, 0x61, 0xa3,
	0xf9, 0x5d, 0xfd, 0x86, 0xb7, 0xce, 0x18, 0x42, 0x5a, 0x9d, 0xee, 0xde, 0x51, 0x7d, 0xd9, 0xbb,
	0xc9, 0x56, 0x0a, 0xae, 0xd6, 0xd1, 0x6f, 0xeb, 0xcc, 0xbb, 0xcd, 0xea, 0x00, 0x38, 0xda, 0x3b,
	0x29, 0x8d, 0x5c, 0xd9, 0xf1, 0xff, 0xed, 0xa7, 0x8d, 0x85, 0x3f, 0xfd, 0xb4, 0xb1, 0xf0, 0x1f,
	0x3f, 0x6d, 0x2c, 0xfc, 0xd3, 0xcf, 0x1b, 0x57, 0xfe, 0xf4, 0xf3, 0xc6, 0x95, 0x7f, 0xff, 0x79,
	0xe3, 0x4a, 0x6f, 0x09, 0xff, 0xed, 0xec, 0xa3, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x28,
	0x1a, 0x36, 0x86, 0x26, 0x00, 0x00,
}

func (m *Metric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size := m.Body.Size()
			i -= size
			if _, err := m.Body.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Metric_Tcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Tcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcp != nil {
		{
			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Metric_Nic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Nic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Nic != nil {
		{
			size, err := m.Nic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Metric_Net) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Net) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Net != nil {
		{
			size, err := m.Net.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SocketMemoryUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocketMemoryUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocketMemoryUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SockDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SockDrop))
		i--
		dAtA[i] = 0x48
	}
	if m.BackLog != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BackLog))
		i--
		dAtA[i] = 0x40
	}
	if m.OptMem != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.OptMem))
		i--
		dAtA[i] = 0x38
	}
	if m.WmemQueued != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.WmemQueued))
		i--
		dAtA[i] = 0x30
	}
	if m.FwdAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.FwdAlloc))
		i--
		dAtA[i] = 0x28
	}
	if m.SndBuf != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndBuf))
		i--
		dAtA[i] = 0x20
	}
	if m.WmemAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.WmemAlloc))
		i--
		dAtA[i] = 0x18
	}
	if m.RcvBuf != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvBuf))
		i--
		dAtA[i] = 0x10
	}
	if m.RmemAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RmemAlloc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retrans != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Retrans))
		i--
		dAtA[i] = 0x18
	}
	if m.ExpireTimeUs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.ExpireTimeUs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Fd))
		i--
		dAtA[i] = 0x18
	}
	if m.Pid != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SocketMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocketMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocketMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecnseen {
		i--
		if m.Ecnseen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.Ecn {
		i--
		if m.Ecn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.SndbufLimited != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndbufLimited))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.RwndLimited != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RwndLimited))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.DataSegsIn != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.DataSegsIn))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DataSegsOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.DataSegsOut))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.RcvSsthresh != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvSsthresh))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.RcvSpace != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.BusyMs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BusyMs))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.Delivered != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Delivered))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.Lastack != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastack))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.Lastrcv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastrcv))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.Lastsnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastsnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.SegsIn != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SegsIn))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.SegsOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SegsOut))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.BytesReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesReceived))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.BytesAcked != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesAcked))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.BytesSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesSent))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.SndWnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndWnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.Cwnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Cwnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.Advmss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Advmss))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.Rcvmss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Rcvmss))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.Pmtu != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Pmtu))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.Mss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Mss))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.Ato != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ato))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf1
	}
	if m.RetransTotal != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RetransTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.RetransNow != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RetransNow))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.RcvRtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RcvRtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if m.Minrtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minrtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb9
	}
	if m.Rttvar != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rttvar))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb1
	}
	if m.Rtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if m.Rto != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rto))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.RcvWscale != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvWscale))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SndWscale != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndWscale))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Send != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Send))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.DeliveryRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeliveryRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.PacingRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PacingRate))))
		i--
		dAtA[i] = 0x79
	}
	if m.AppLimited {
		i--
		if m.AppLimited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Cubic {
		i--
		if m.Cubic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Sack {
		i--
		if m.Sack {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Ts {
		i--
		if m.Ts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Skmem != nil {
		{
			size, err := m.Skmem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Timers) > 0 {
		for iNdEx := len(m.Timers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Timers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Processes) > 0 {
		for iNdEx := len(m.Processes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PeerAddr) > 0 {
		i -= len(m.PeerAddr)
		copy(dAtA[i:], m.PeerAddr)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.PeerAddr)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LocalAddr) > 0 {
		i -= len(m.LocalAddr)
		copy(dAtA[i:], m.LocalAddr)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.LocalAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.SendQ != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SendQ))
		i--
		dAtA[i] = 0x28
	}
	if m.RecvQ != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RecvQ))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *TcpMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sockets) > 0 {
		for iNdEx := len(m.Sockets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sockets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IfaceMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IfaceMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IfaceMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxCollisions != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxCollisions))
		i--
		dAtA[i] = 0x50
	}
	if m.TxCarrier != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxCarrier))
		i--
		dAtA[i] = 0x48
	}
	if m.TxOverruns != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxOverruns))
		i--
		dAtA[i] = 0x40
	}
	if m.TxDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxDropped))
		i--
		dAtA[i] = 0x38
	}
	if m.TxErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxErrors))
		i--
		dAtA[i] = 0x30
	}
	if m.RxFrame != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxFrame))
		i--
		dAtA[i] = 0x28
	}
	if m.RxOverruns != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxOverruns))
		i--
		dAtA[i] = 0x20
	}
	if m.RxDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxDropped))
		i--
		dAtA[i] = 0x18
	}
	if m.RxErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxErrors))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NicMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NicMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NicMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ifaces) > 0 {
		for iNdEx := len(m.Ifaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ifaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetstatMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetstatMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetstatMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IpextInEct0Pkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpextInEct0Pkts))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.IpextInNoEctPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpextInNoEctPkts))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x98
	}
	if m.IpextInBcastOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpextInBcastOctets))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x90
	}
	if m.IpextOutOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpextOutOctets))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x88
	}
	if m.IpextInOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpextInOctets))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x80
	}
	if m.IpextInBcastPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpextInBcastPkts))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpextTcpAckCompressed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpAckCompressed))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpextTcpDelivered != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpDelivered))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpextTcpKeepAlive != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpKeepAlive))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpextTcpAckSkippedChallenge != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpAckSkippedChallenge))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpextTcpAckSkippedSeq != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpAckSkippedSeq))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpextTcpHystartDelayCwnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpHystartDelayCwnd))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpextTcpHystartDelayDetect != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpHystartDelayDetect))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpextTcpHystartTrainCwnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpHystartTrainCwnd))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpextTcpHystartTrainDetect != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpHystartTrainDetect))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpextTcpOrigDataSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpOrigDataSent))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpextTcpSynRetrans != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpSynRetrans))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpextTcpAutoCorking != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpAutoCorking))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x98
	}
	if m.TcpextTcpSpuriousRtxHostQueues != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpSpuriousRtxHostQueues))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x90
	}
	if m.TcpextTcpFastOpenBlackhole != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpFastOpenBlackhole))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x88
	}
	if m.TcpextTcpFastOpenCookieReqd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpFastOpenCookieReqd))
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x80
	}
	if m.TcpextTcpFastOpenActiveFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpFastOpenActiveFail))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpextTcpSynChallenge != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpSynChallenge))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpextTcpChallengeAck != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpChallengeAck))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpextTcpOfoMerge != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpOfoMerge))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpextTcpOfoQueue != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpOfoQueue))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpextTcpRcvCoalesce != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpRcvCoalesce))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpextTcpRetransFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpRetransFail))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpextIpReversePathFilter != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextIpReversePathFilter))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpextTcpSackShiftFallback != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpSackShiftFallback))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpextTcpSackMerged != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpSackMerged))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpextTcpSpuriousRtos != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpSpuriousRtos))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpextTcpDsackIgnoredNoUndo != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpDsackIgnoredNoUndo))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpextTcpDsackIgnoredOld != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpDsackIgnoredOld))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x98
	}
	if m.TcpextConnectionsAbortedDueToTimeout != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextConnectionsAbortedDueToTimeout))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if m.TcpextConnectionsResetDueToEarlyUserClose != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextConnectionsResetDueToEarlyUserClose))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x88
	}
	if m.TcpextConnectionsResetDueToUnexpectedData != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextConnectionsResetDueToUnexpectedData))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x80
	}
	if m.TcpextDsacksForOutOfOrderPacketsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextDsacksForOutOfOrderPacketsReceived))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpextDsacksReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextDsacksReceived))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpextDsacksSentForOutOfOrderPackets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextDsacksSentForOutOfOrderPackets))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpextDsacksSentForOldPackets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextDsacksSentForOldPackets))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpextTcpBacklogCoalesce != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpBacklogCoalesce))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpextSackRetransmitsFailed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextSackRetransmitsFailed))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpextTcpLossProbeRecovery != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpLossProbeRecovery))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpextTcpLossProbes != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpLossProbes))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpextOtherTcpTimeouts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextOtherTcpTimeouts))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpextRetransmitsInSlowStart != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextRetransmitsInSlowStart))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpextFastRetransmits != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextFastRetransmits))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpextTimeoutsInLossState != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTimeoutsInLossState))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpextTimeoutsAfterSackRecovery != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTimeoutsAfterSackRecovery))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.TcpextTcpLostRetransmit != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpLostRetransmit))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.TcpextCongestionWindowsFullyRecoveredWithoutSlowStart != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextCongestionWindowsFullyRecoveredWithoutSlowStart))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpextDetectedReorderingTimesUsingSack != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextDetectedReorderingTimesUsingSack))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpextPredictedAcknowledgments != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextPredictedAcknowledgments))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpextAcknowledgmentsNotContainingDataPayloadReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextAcknowledgmentsNotContainingDataPayloadReceived))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpextPacketHeadersPredicted != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextPacketHeadersPredicted))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpextSynsToListenSocketsDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextSynsToListenSocketsDropped))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpextTimesTheListenQueueOfASocketOverflowed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTimesTheListenQueueOfASocketOverflowed))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpextQuickAckModeWasActivatedTimes != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextQuickAckModeWasActivatedTimes))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpextDelayedAcksSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextDelayedAcksSent))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpextTcpSocketsFinishedTimeWaitInFastTimer != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextTcpSocketsFinishedTimeWaitInFastTimer))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.TcpextIcmpPacketsDroppedBecauseSocketWasLocked != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextIcmpPacketsDroppedBecauseSocketWasLocked))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.TcpextResetsReceivedForEmbryonicSynRecvSockets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextResetsReceivedForEmbryonicSynRecvSockets))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.TcpextInvalidSynCookiesReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpextInvalidSynCookiesReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.UdpIgnoredMulti != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpIgnoredMulti))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.UdpSendBufferErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpSendBufferErrors))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.UdpReceiveBufferErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpReceiveBufferErrors))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.UdpPacketsSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketsSent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.UdpPacketReceiveErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketReceiveErrors))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.UdpPacketsToUnknownPortReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketsToUnknownPortReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.UdpPacketsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpPacketsReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpResetsSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpResetsSent))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpBadSegmentsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpBadSegmentsReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpSegmentsRetransmitted != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSegmentsRetransmitted))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpSegmentsSendOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSegmentsSendOut))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpSegmentsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSegmentsReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TcpConnectionsEstablished != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpConnectionsEstablished))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.TcpConnectionResetsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpConnectionResetsReceived))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TcpFailedConnectionAttempts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFailedConnectionAttempts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TcpPassiveConnectionOpenings != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPassiveConnectionOpenings))
		i--
		dAtA[i] = 0x78
	}
	if m.TcpActiveConnectionsOpenings != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpActiveConnectionsOpenings))
		i--
		dAtA[i] = 0x70
	}
	if m.IpPacketReassemblesFailed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpPacketReassemblesFailed))
		i--
		dAtA[i] = 0x68
	}
	if m.IpPacketsReassembledOk != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpPacketsReassembledOk))
		i--
		dAtA[i] = 0x60
	}
	if m.IpReassembliesRequired != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpReassembliesRequired))
		i--
		dAtA[i] = 0x58
	}
	if m.IpFragmentsDroppedAfterTimeout != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpFragmentsDroppedAfterTimeout))
		i--
		dAtA[i] = 0x50
	}
	if m.IpDroppedBecauseOfMissingRoute != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpDroppedBecauseOfMissingRoute))
		i--
		dAtA[i] = 0x48
	}
	if m.IpOutgoingPacketsDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutgoingPacketsDropped))
		i--
		dAtA[i] = 0x40
	}
	if m.IpRequestsSentOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpRequestsSentOut))
		i--
		dAtA[i] = 0x38
	}
	if m.IpIncomingPacketsDelivered != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpIncomingPacketsDelivered))
		i--
		dAtA[i] = 0x30
	}
	if m.IpIncomingPacketsDiscarded != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpIncomingPacketsDiscarded))
		i--
		dAtA[i] = 0x28
	}
	if m.IpForwarded != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpForwarded))
		i--
		dAtA[i] = 0x20
	}
	if m.IpTotalPacketsReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpTotalPacketsReceived))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTcpmon(dAtA []byte, offset int, v uint64) int {
	offset -= sovTcpmon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	return n
}

func (m *Metric_Tcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *Metric_Nic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nic != nil {
		l = m.Nic.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *Metric_Net) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Net != nil {
		l = m.Net.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *SocketMemoryUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RmemAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.RmemAlloc))
	}
	if m.RcvBuf != 0 {
		n += 1 + sovTcpmon(uint64(m.RcvBuf))
	}
	if m.WmemAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.WmemAlloc))
	}
	if m.SndBuf != 0 {
		n += 1 + sovTcpmon(uint64(m.SndBuf))
	}
	if m.FwdAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.FwdAlloc))
	}
	if m.WmemQueued != 0 {
		n += 1 + sovTcpmon(uint64(m.WmemQueued))
	}
	if m.OptMem != 0 {
		n += 1 + sovTcpmon(uint64(m.OptMem))
	}
	if m.BackLog != 0 {
		n += 1 + sovTcpmon(uint64(m.BackLog))
	}
	if m.SockDrop != 0 {
		n += 1 + sovTcpmon(uint64(m.SockDrop))
	}
	return n
}

func (m *TimerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.ExpireTimeUs != 0 {
		n += 1 + sovTcpmon(uint64(m.ExpireTimeUs))
	}
	if m.Retrans != 0 {
		n += 1 + sovTcpmon(uint64(m.Retrans))
	}
	return n
}

func (m *ProcessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovTcpmon(uint64(m.Pid))
	}
	if m.Fd != 0 {
		n += 1 + sovTcpmon(uint64(m.Fd))
	}
	return n
}

func (m *SocketMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovTcpmon(uint64(m.State))
	}
	if m.RecvQ != 0 {
		n += 1 + sovTcpmon(uint64(m.RecvQ))
	}
	if m.SendQ != 0 {
		n += 1 + sovTcpmon(uint64(m.SendQ))
	}
	l = len(m.LocalAddr)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	l = len(m.PeerAddr)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	if len(m.Timers) > 0 {
		for _, e := range m.Timers {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	if m.Skmem != nil {
		l = m.Skmem.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.Ts {
		n += 2
	}
	if m.Sack {
		n += 2
	}
	if m.Cubic {
		n += 2
	}
	if m.AppLimited {
		n += 2
	}
	if m.PacingRate != 0 {
		n += 9
	}
	if m.DeliveryRate != 0 {
		n += 10
	}
	if m.Send != 0 {
		n += 10
	}
	if m.SndWscale != 0 {
		n += 2 + sovTcpmon(uint64(m.SndWscale))
	}
	if m.RcvWscale != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvWscale))
	}
	if m.Rto != 0 {
		n += 10
	}
	if m.Rtt != 0 {
		n += 10
	}
	if m.Rttvar != 0 {
		n += 10
	}
	if m.Minrtt != 0 {
		n += 10
	}
	if m.RcvRtt != 0 {
		n += 10
	}
	if m.RetransNow != 0 {
		n += 2 + sovTcpmon(uint64(m.RetransNow))
	}
	if m.RetransTotal != 0 {
		n += 2 + sovTcpmon(uint64(m.RetransTotal))
	}
	if m.Ato != 0 {
		n += 10
	}
	if m.Mss != 0 {
		n += 2 + sovTcpmon(uint64(m.Mss))
	}
	if m.Pmtu != 0 {
		n += 2 + sovTcpmon(uint64(m.Pmtu))
	}
	if m.Rcvmss != 0 {
		n += 2 + sovTcpmon(uint64(m.Rcvmss))
	}
	if m.Advmss != 0 {
		n += 2 + sovTcpmon(uint64(m.Advmss))
	}
	if m.Cwnd != 0 {
		n += 2 + sovTcpmon(uint64(m.Cwnd))
	}
	if m.SndWnd != 0 {
		n += 2 + sovTcpmon(uint64(m.SndWnd))
	}
	if m.BytesSent != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesSent))
	}
	if m.BytesAcked != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesAcked))
	}
	if m.BytesReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesReceived))
	}
	if m.SegsOut != 0 {
		n += 2 + sovTcpmon(uint64(m.SegsOut))
	}
	if m.SegsIn != 0 {
		n += 2 + sovTcpmon(uint64(m.SegsIn))
	}
	if m.Lastsnd != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastsnd))
	}
	if m.Lastrcv != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastrcv))
	}
	if m.Lastack != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastack))
	}
	if m.Delivered != 0 {
		n += 2 + sovTcpmon(uint64(m.Delivered))
	}
	if m.BusyMs != 0 {
		n += 2 + sovTcpmon(uint64(m.BusyMs))
	}
	if m.RcvSpace != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvSpace))
	}
	if m.RcvSsthresh != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvSsthresh))
	}
	if m.DataSegsOut != 0 {
		n += 2 + sovTcpmon(uint64(m.DataSegsOut))
	}
	if m.DataSegsIn != 0 {
		n += 2 + sovTcpmon(uint64(m.DataSegsIn))
	}
	if m.RwndLimited != 0 {
		n += 2 + sovTcpmon(uint64(m.RwndLimited))
	}
	if m.SndbufLimited != 0 {
		n += 2 + sovTcpmon(uint64(m.SndbufLimited))
	}
	if m.Ecn {
		n += 3
	}
	if m.Ecnseen {
		n += 3
	}
	return n
}

func (m *TcpMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if len(m.Sockets) > 0 {
		for _, e := range m.Sockets {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	return n
}

func (m *IfaceMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.RxErrors != 0 {
		n += 1 + sovTcpmon(uint64(m.RxErrors))
	}
	if m.RxDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.RxDropped))
	}
	if m.RxOverruns != 0 {
		n += 1 + sovTcpmon(uint64(m.RxOverruns))
	}
	if m.RxFrame != 0 {
		n += 1 + sovTcpmon(uint64(m.RxFrame))
	}
	if m.TxErrors != 0 {
		n += 1 + sovTcpmon(uint64(m.TxErrors))
	}
	if m.TxDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.TxDropped))
	}
	if m.TxOverruns != 0 {
		n += 1 + sovTcpmon(uint64(m.TxOverruns))
	}
	if m.TxCarrier != 0 {
		n += 1 + sovTcpmon(uint64(m.TxCarrier))
	}
	if m.TxCollisions != 0 {
		n += 1 + sovTcpmon(uint64(m.TxCollisions))
	}
	return n
}

func (m *NicMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if len(m.Ifaces) > 0 {
		for _, e := range m.Ifaces {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	return n
}

func (m *NetstatMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if m.IpTotalPacketsReceived != 0 {
		n += 1 + sovTcpmon(uint64(m.IpTotalPacketsReceived))
	}
	if m.IpForwarded != 0 {
		n += 1 + sovTcpmon(uint64(m.IpForwarded))
	}
	if m.IpIncomingPacketsDiscarded != 0 {
		n += 1 + sovTcpmon(uint64(m.IpIncomingPacketsDiscarded))
	}
	if m.IpIncomingPacketsDelivered != 0 {
		n += 1 + sovTcpmon(uint64(m.IpIncomingPacketsDelivered))
	}
	if m.IpRequestsSentOut != 0 {
		n += 1 + sovTcpmon(uint64(m.IpRequestsSentOut))
	}
	if m.IpOutgoingPacketsDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.IpOutgoingPacketsDropped))
	}
	if m.IpDroppedBecauseOfMissingRoute != 0 {
		n += 1 + sovTcpmon(uint64(m.IpDroppedBecauseOfMissingRoute))
	}
	if m.IpFragmentsDroppedAfterTimeout != 0 {
		n += 1 + sovTcpmon(uint64(m.IpFragmentsDroppedAfterTimeout))
	}
	if m.IpReassembliesRequired != 0 {
		n += 1 + sovTcpmon(uint64(m.IpReassembliesRequired))
	}
	if m.IpPacketsReassembledOk != 0 {
		n += 1 + sovTcpmon(uint64(m.IpPacketsReassembledOk))
	}
	if m.IpPacketReassemblesFailed != 0 {
		n += 1 + sovTcpmon(uint64(m.IpPacketReassemblesFailed))
	}
	if m.TcpActiveConnectionsOpenings != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpActiveConnectionsOpenings))
	}
	if m.TcpPassiveConnectionOpenings != 0 {
		n += 1 + sovTcpmon(uint64(m.TcpPassiveConnectionOpenings))
	}
	if m.TcpFailedConnectionAttempts != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFailedConnectionAttempts))
	}
	if m.TcpConnectionResetsReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpConnectionResetsReceived))
	}
	if m.TcpConnectionsEstablished != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpConnectionsEstablished))
	}
	if m.TcpSegmentsReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSegmentsReceived))
	}
	if m.TcpSegmentsSendOut != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSegmentsSendOut))
	}
	if m.TcpSegmentsRetransmitted != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSegmentsRetransmitted))
	}
	if m.TcpBadSegmentsReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpBadSegmentsReceived))
	}
	if m.TcpResetsSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpResetsSent))
	}
	if m.UdpPacketsReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketsReceived))
	}
	if m.UdpPacketsToUnknownPortReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketsToUnknownPortReceived))
	}
	if m.UdpPacketReceiveErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketReceiveErrors))
	}
	if m.UdpPacketsSent != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpPacketsSent))
	}
	if m.UdpReceiveBufferErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpReceiveBufferErrors))
	}
	if m.UdpSendBufferErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpSendBufferErrors))
	}
	if m.UdpIgnoredMulti != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpIgnoredMulti))
	}
	if m.TcpextInvalidSynCookiesReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextInvalidSynCookiesReceived))
	}
	if m.TcpextResetsReceivedForEmbryonicSynRecvSockets != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextResetsReceivedForEmbryonicSynRecvSockets))
	}
	if m.TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow))
	}
	if m.TcpextIcmpPacketsDroppedBecauseSocketWasLocked != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextIcmpPacketsDroppedBecauseSocketWasLocked))
	}
	if m.TcpextTcpSocketsFinishedTimeWaitInFastTimer != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpSocketsFinishedTimeWaitInFastTimer))
	}
	if m.TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp))
	}
	if m.TcpextDelayedAcksSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextDelayedAcksSent))
	}
	if m.TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket))
	}
	if m.TcpextQuickAckModeWasActivatedTimes != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextQuickAckModeWasActivatedTimes))
	}
	if m.TcpextTimesTheListenQueueOfASocketOverflowed != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTimesTheListenQueueOfASocketOverflowed))
	}
	if m.TcpextSynsToListenSocketsDropped != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextSynsToListenSocketsDropped))
	}
	if m.TcpextPacketHeadersPredicted != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextPacketHeadersPredicted))
	}
	if m.TcpextAcknowledgmentsNotContainingDataPayloadReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextAcknowledgmentsNotContainingDataPayloadReceived))
	}
	if m.TcpextPredictedAcknowledgments != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextPredictedAcknowledgments))
	}
	if m.TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements))
	}
	if m.TcpextDetectedReorderingTimesUsingSack != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextDetectedReorderingTimesUsingSack))
	}
	if m.TcpextCongestionWindowsFullyRecoveredWithoutSlowStart != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextCongestionWindowsFullyRecoveredWithoutSlowStart))
	}
	if m.TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack))
	}
	if m.TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck))
	}
	if m.TcpextTcpLostRetransmit != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpLostRetransmit))
	}
	if m.TcpextTimeoutsAfterSackRecovery != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTimeoutsAfterSackRecovery))
	}
	if m.TcpextTimeoutsInLossState != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTimeoutsInLossState))
	}
	if m.TcpextFastRetransmits != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextFastRetransmits))
	}
	if m.TcpextRetransmitsInSlowStart != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextRetransmitsInSlowStart))
	}
	if m.TcpextOtherTcpTimeouts != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextOtherTcpTimeouts))
	}
	if m.TcpextTcpLossProbes != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpLossProbes))
	}
	if m.TcpextTcpLossProbeRecovery != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpLossProbeRecovery))
	}
	if m.TcpextSackRetransmitsFailed != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextSackRetransmitsFailed))
	}
	if m.TcpextTcpBacklogCoalesce != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpBacklogCoalesce))
	}
	if m.TcpextDsacksSentForOldPackets != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextDsacksSentForOldPackets))
	}
	if m.TcpextDsacksSentForOutOfOrderPackets != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextDsacksSentForOutOfOrderPackets))
	}
	if m.TcpextDsacksReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextDsacksReceived))
	}
	if m.TcpextDsacksForOutOfOrderPacketsReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextDsacksForOutOfOrderPacketsReceived))
	}
	if m.TcpextConnectionsResetDueToUnexpectedData != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextConnectionsResetDueToUnexpectedData))
	}
	if m.TcpextConnectionsResetDueToEarlyUserClose != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextConnectionsResetDueToEarlyUserClose))
	}
	if m.TcpextConnectionsAbortedDueToTimeout != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextConnectionsAbortedDueToTimeout))
	}
	if m.TcpextTcpDsackIgnoredOld != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpDsackIgnoredOld))
	}
	if m.TcpextTcpDsackIgnoredNoUndo != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpDsackIgnoredNoUndo))
	}
	if m.TcpextTcpSpuriousRtos != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpSpuriousRtos))
	}
	if m.TcpextTcpSackMerged != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpSackMerged))
	}
	if m.TcpextTcpSackShiftFallback != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpSackShiftFallback))
	}
	if m.TcpextIpReversePathFilter != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextIpReversePathFilter))
	}
	if m.TcpextTcpRetransFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpRetransFail))
	}
	if m.TcpextTcpRcvCoalesce != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpRcvCoalesce))
	}
	if m.TcpextTcpOfoQueue != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpOfoQueue))
	}
	if m.TcpextTcpOfoMerge != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpOfoMerge))
	}
	if m.TcpextTcpChallengeAck != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpChallengeAck))
	}
	if m.TcpextTcpSynChallenge != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpSynChallenge))
	}
	if m.TcpextTcpFastOpenActiveFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpFastOpenActiveFail))
	}
	if m.TcpextTcpFastOpenCookieReqd != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpFastOpenCookieReqd))
	}
	if m.TcpextTcpFastOpenBlackhole != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpFastOpenBlackhole))
	}
	if m.TcpextTcpSpuriousRtxHostQueues != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpSpuriousRtxHostQueues))
	}
	if m.TcpextTcpAutoCorking != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpAutoCorking))
	}
	if m.TcpextTcpSynRetrans != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpSynRetrans))
	}
	if m.TcpextTcpOrigDataSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpOrigDataSent))
	}
	if m.TcpextTcpHystartTrainDetect != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpHystartTrainDetect))
	}
	if m.TcpextTcpHystartTrainCwnd != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpHystartTrainCwnd))
	}
	if m.TcpextTcpHystartDelayDetect != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpHystartDelayDetect))
	}
	if m.TcpextTcpHystartDelayCwnd != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpHystartDelayCwnd))
	}
	if m.TcpextTcpAckSkippedSeq != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpAckSkippedSeq))
	}
	if m.TcpextTcpAckSkippedChallenge != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpAckSkippedChallenge))
	}
	if m.TcpextTcpKeepAlive != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpKeepAlive))
	}
	if m.TcpextTcpDelivered != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpDelivered))
	}
	if m.TcpextTcpAckCompressed != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpextTcpAckCompressed))
	}
	if m.IpextInBcastPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpextInBcastPkts))
	}
	if m.IpextInOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpextInOctets))
	}
	if m.IpextOutOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpextOutOctets))
	}
	if m.IpextInBcastOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpextInBcastOctets))
	}
	if m.IpextInNoEctPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpextInNoEctPkts))
	}
	if m.IpextInEct0Pkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpextInEct0Pkts))
	}
	return n
}

func sovTcpmon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTcpmon(x uint64) (n int) {
	return sovTcpmon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Tcp{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NicMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Nic{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetstatMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Net{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocketMemoryUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocketMemoryUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocketMemoryUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RmemAlloc", wireType)
			}
			m.RmemAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RmemAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvBuf", wireType)
			}
			m.RcvBuf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvBuf |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WmemAlloc", wireType)
			}
			m.WmemAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WmemAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndBuf", wireType)
			}
			m.SndBuf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndBuf |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdAlloc", wireType)
			}
			m.FwdAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WmemQueued", wireType)
			}
			m.WmemQueued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WmemQueued |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptMem", wireType)
			}
			m.OptMem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptMem |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackLog", wireType)
			}
			m.BackLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackLog |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SockDrop", wireType)
			}
			m.SockDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SockDrop |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTimeUs", wireType)
			}
			m.ExpireTimeUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTimeUs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retrans", wireType)
			}
			m.Retrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retrans |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fd", wireType)
			}
			m.Fd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocketMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocketMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocketMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SocketState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvQ", wireType)
			}
			m.RecvQ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvQ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendQ", wireType)
			}
			m.SendQ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendQ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &ProcessInfo{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timers = append(m.Timers, &TimerInfo{})
			if err := m.Timers[len(m.Timers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skmem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skmem == nil {
				m.Skmem = &SocketMemoryUsage{}
			}
			if err := m.Skmem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ts = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sack = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cubic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cubic = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppLimited = bool(v != 0)
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacingRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PacingRate = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeliveryRate = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Send = float64(math.Float64frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWscale", wireType)
			}
			m.SndWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWscale", wireType)
			}
			m.RcvWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rto", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rto = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rtt = float64(math.Float64frombits(v))
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rttvar", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rttvar = float64(math.Float64frombits(v))
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minrtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minrtt = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvRtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RcvRtt = float64(math.Float64frombits(v))
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransNow", wireType)
			}
			m.RetransNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransNow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransTotal", wireType)
			}
			m.RetransTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransTotal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ato", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ato = float64(math.Float64frombits(v))
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mss", wireType)
			}
			m.Mss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmtu", wireType)
			}
			m.Pmtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rcvmss", wireType)
			}
			m.Rcvmss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rcvmss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advmss", wireType)
			}
			m.Advmss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Advmss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwnd", wireType)
			}
			m.Cwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cwnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWnd", wireType)
			}
			m.SndWnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSent", wireType)
			}
			m.BytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesSent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesAcked", wireType)
			}
			m.BytesAcked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesAcked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesReceived", wireType)
			}
			m.BytesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegsOut", wireType)
			}
			m.SegsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegsIn", wireType)
			}
			m.SegsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegsIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastsnd", wireType)
			}
			m.Lastsnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastsnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastrcv", wireType)
			}
			m.Lastrcv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastrcv |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastack", wireType)
			}
			m.Lastack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastack |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delivered", wireType)
			}
			m.Delivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delivered |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusyMs", wireType)
			}
			m.BusyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusyMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvSpace", wireType)
			}
			m.RcvSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvSpace |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvSsthresh", wireType)
			}
			m.RcvSsthresh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvSsthresh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSegsOut", wireType)
			}
			m.DataSegsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSegsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSegsIn", wireType)
			}
			m.DataSegsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSegsIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwndLimited", wireType)
			}
			m.RwndLimited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RwndLimited |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndbufLimited", wireType)
			}
			m.SndbufLimited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndbufLimited |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ecn = bool(v != 0)
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecnseen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ecnseen = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sockets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sockets = append(m.Sockets, &SocketMetric{})
			if err := m.Sockets[len(m.Sockets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IfaceMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IfaceMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IfaceMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxErrors", wireType)
			}
			m.RxErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDropped", wireType)
			}
			m.RxDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOverruns", wireType)
			}
			m.RxOverruns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOverruns |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxFrame", wireType)
			}
			m.RxFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxFrame |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxErrors", wireType)
			}
			m.TxErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDropped", wireType)
			}
			m.TxDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOverruns", wireType)
			}
			m.TxOverruns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOverruns |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCarrier", wireType)
			}
			m.TxCarrier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCarrier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCollisions", wireType)
			}
			m.TxCollisions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCollisions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NicMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NicMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NicMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifaces = append(m.Ifaces, &IfaceMetric{})
			if err := m.Ifaces[len(m.Ifaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetstatMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetstatMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetstatMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTotalPacketsReceived", wireType)
			}
			m.IpTotalPacketsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpTotalPacketsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpForwarded", wireType)
			}
			m.IpForwarded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpForwarded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpIncomingPacketsDiscarded", wireType)
			}
			m.IpIncomingPacketsDiscarded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpIncomingPacketsDiscarded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpIncomingPacketsDelivered", wireType)
			}
			m.IpIncomingPacketsDelivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpIncomingPacketsDelivered |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRequestsSentOut", wireType)
			}
			m.IpRequestsSentOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpRequestsSentOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutgoingPacketsDropped", wireType)
			}
			m.IpOutgoingPacketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutgoingPacketsDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDroppedBecauseOfMissingRoute", wireType)
			}
			m.IpDroppedBecauseOfMissingRoute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDroppedBecauseOfMissingRoute |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFragmentsDroppedAfterTimeout", wireType)
			}
			m.IpFragmentsDroppedAfterTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpFragmentsDroppedAfterTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReassembliesRequired", wireType)
			}
			m.IpReassembliesRequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpReassembliesRequired |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPacketsReassembledOk", wireType)
			}
			m.IpPacketsReassembledOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPacketsReassembledOk |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPacketReassemblesFailed", wireType)
			}
			m.IpPacketReassemblesFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpPacketReassemblesFailed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpActiveConnectionsOpenings", wireType)
			}
			m.TcpActiveConnectionsOpenings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpActiveConnectionsOpenings |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPassiveConnectionOpenings", wireType)
			}
			m.TcpPassiveConnectionOpenings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPassiveConnectionOpenings |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFailedConnectionAttempts", wireType)
			}
			m.TcpFailedConnectionAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFailedConnectionAttempts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpConnectionResetsReceived", wireType)
			}
			m.TcpConnectionResetsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpConnectionResetsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpConnectionsEstablished", wireType)
			}
			m.TcpConnectionsEstablished = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpConnectionsEstablished |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSegmentsReceived", wireType)
			}
			m.TcpSegmentsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSegmentsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSegmentsSendOut", wireType)
			}
			m.TcpSegmentsSendOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSegmentsSendOut |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSegmentsRetransmitted", wireType)
			}
			m.TcpSegmentsRetransmitted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSegmentsRetransmitted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpBadSegmentsReceived", wireType)
			}
			m.TcpBadSegmentsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpBadSegmentsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpResetsSent", wireType)
			}
			m.TcpResetsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpResetsSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketsReceived", wireType)
			}
			m.UdpPacketsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketsToUnknownPortReceived", wireType)
			}
			m.UdpPacketsToUnknownPortReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketsToUnknownPortReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketReceiveErrors", wireType)
			}
			m.UdpPacketReceiveErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketReceiveErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpPacketsSent", wireType)
			}
			m.UdpPacketsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpPacketsSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpReceiveBufferErrors", wireType)
			}
			m.UdpReceiveBufferErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpReceiveBufferErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSendBufferErrors", wireType)
			}
			m.UdpSendBufferErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpSendBufferErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpIgnoredMulti", wireType)
			}
			m.UdpIgnoredMulti = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpIgnoredMulti |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextInvalidSynCookiesReceived", wireType)
			}
			m.TcpextInvalidSynCookiesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextInvalidSynCookiesReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextResetsReceivedForEmbryonicSynRecvSockets", wireType)
			}
			m.TcpextResetsReceivedForEmbryonicSynRecvSockets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextResetsReceivedForEmbryonicSynRecvSockets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow", wireType)
			}
			m.TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextIcmpPacketsDroppedBecauseTheyWereOutOfWindow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextIcmpPacketsDroppedBecauseSocketWasLocked", wireType)
			}
			m.TcpextIcmpPacketsDroppedBecauseSocketWasLocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextIcmpPacketsDroppedBecauseSocketWasLocked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpSocketsFinishedTimeWaitInFastTimer", wireType)
			}
			m.TcpextTcpSocketsFinishedTimeWaitInFastTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpSocketsFinishedTimeWaitInFastTimer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp", wireType)
			}
			m.TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextPacketsRejectsInEstablishedConnectionsBecauseOfTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextDelayedAcksSent", wireType)
			}
			m.TcpextDelayedAcksSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextDelayedAcksSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket", wireType)
			}
			m.TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextDelayedAcksFurtherDelayedBecauseOfLockedSocket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextQuickAckModeWasActivatedTimes", wireType)
			}
			m.TcpextQuickAckModeWasActivatedTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextQuickAckModeWasActivatedTimes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTimesTheListenQueueOfASocketOverflowed", wireType)
			}
			m.TcpextTimesTheListenQueueOfASocketOverflowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTimesTheListenQueueOfASocketOverflowed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextSynsToListenSocketsDropped", wireType)
			}
			m.TcpextSynsToListenSocketsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextSynsToListenSocketsDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextPacketHeadersPredicted", wireType)
			}
			m.TcpextPacketHeadersPredicted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextPacketHeadersPredicted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextAcknowledgmentsNotContainingDataPayloadReceived", wireType)
			}
			m.TcpextAcknowledgmentsNotContainingDataPayloadReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextAcknowledgmentsNotContainingDataPayloadReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextPredictedAcknowledgments", wireType)
			}
			m.TcpextPredictedAcknowledgments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextPredictedAcknowledgments |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements", wireType)
			}
			m.TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTimesRecoveredFromPacketLossBySelectiveAcknowledgements |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextDetectedReorderingTimesUsingSack", wireType)
			}
			m.TcpextDetectedReorderingTimesUsingSack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextDetectedReorderingTimesUsingSack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextCongestionWindowsFullyRecoveredWithoutSlowStart", wireType)
			}
			m.TcpextCongestionWindowsFullyRecoveredWithoutSlowStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextCongestionWindowsFullyRecoveredWithoutSlowStart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack", wireType)
			}
			m.TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextCongestionWindowsRecoveredWithoutSlowStartByDsack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck", wireType)
			}
			m.TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextCongestionWindowsRecoveredWithoutSlowStartAfterPartialAck |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpLostRetransmit", wireType)
			}
			m.TcpextTcpLostRetransmit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpLostRetransmit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTimeoutsAfterSackRecovery", wireType)
			}
			m.TcpextTimeoutsAfterSackRecovery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTimeoutsAfterSackRecovery |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTimeoutsInLossState", wireType)
			}
			m.TcpextTimeoutsInLossState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTimeoutsInLossState |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextFastRetransmits", wireType)
			}
			m.TcpextFastRetransmits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextFastRetransmits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextRetransmitsInSlowStart", wireType)
			}
			m.TcpextRetransmitsInSlowStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextRetransmitsInSlowStart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextOtherTcpTimeouts", wireType)
			}
			m.TcpextOtherTcpTimeouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextOtherTcpTimeouts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpLossProbes", wireType)
			}
			m.TcpextTcpLossProbes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpLossProbes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpLossProbeRecovery", wireType)
			}
			m.TcpextTcpLossProbeRecovery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpLossProbeRecovery |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextSackRetransmitsFailed", wireType)
			}
			m.TcpextSackRetransmitsFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextSackRetransmitsFailed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpBacklogCoalesce", wireType)
			}
			m.TcpextTcpBacklogCoalesce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpBacklogCoalesce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextDsacksSentForOldPackets", wireType)
			}
			m.TcpextDsacksSentForOldPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextDsacksSentForOldPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 61:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextDsacksSentForOutOfOrderPackets", wireType)
			}
			m.TcpextDsacksSentForOutOfOrderPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextDsacksSentForOutOfOrderPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 62:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextDsacksReceived", wireType)
			}
			m.TcpextDsacksReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextDsacksReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextDsacksForOutOfOrderPacketsReceived", wireType)
			}
			m.TcpextDsacksForOutOfOrderPacketsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextDsacksForOutOfOrderPacketsReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextConnectionsResetDueToUnexpectedData", wireType)
			}
			m.TcpextConnectionsResetDueToUnexpectedData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextConnectionsResetDueToUnexpectedData |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 65:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextConnectionsResetDueToEarlyUserClose", wireType)
			}
			m.TcpextConnectionsResetDueToEarlyUserClose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextConnectionsResetDueToEarlyUserClose |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextConnectionsAbortedDueToTimeout", wireType)
			}
			m.TcpextConnectionsAbortedDueToTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextConnectionsAbortedDueToTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 67:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpDsackIgnoredOld", wireType)
			}
			m.TcpextTcpDsackIgnoredOld = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpDsackIgnoredOld |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 68:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpDsackIgnoredNoUndo", wireType)
			}
			m.TcpextTcpDsackIgnoredNoUndo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpDsackIgnoredNoUndo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 69:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpSpuriousRtos", wireType)
			}
			m.TcpextTcpSpuriousRtos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpSpuriousRtos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 70:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpSackMerged", wireType)
			}
			m.TcpextTcpSackMerged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpSackMerged |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 71:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpSackShiftFallback", wireType)
			}
			m.TcpextTcpSackShiftFallback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpSackShiftFallback |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 72:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextIpReversePathFilter", wireType)
			}
			m.TcpextIpReversePathFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextIpReversePathFilter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 73:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpRetransFail", wireType)
			}
			m.TcpextTcpRetransFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpRetransFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 74:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpRcvCoalesce", wireType)
			}
			m.TcpextTcpRcvCoalesce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpRcvCoalesce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 75:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpOfoQueue", wireType)
			}
			m.TcpextTcpOfoQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpOfoQueue |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 76:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpOfoMerge", wireType)
			}
			m.TcpextTcpOfoMerge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpOfoMerge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 77:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpChallengeAck", wireType)
			}
			m.TcpextTcpChallengeAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpChallengeAck |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 78:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpSynChallenge", wireType)
			}
			m.TcpextTcpSynChallenge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpSynChallenge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 79:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpFastOpenActiveFail", wireType)
			}
			m.TcpextTcpFastOpenActiveFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpFastOpenActiveFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 80:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpFastOpenCookieReqd", wireType)
			}
			m.TcpextTcpFastOpenCookieReqd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpFastOpenCookieReqd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 81:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpFastOpenBlackhole", wireType)
			}
			m.TcpextTcpFastOpenBlackhole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpFastOpenBlackhole |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 82:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpSpuriousRtxHostQueues", wireType)
			}
			m.TcpextTcpSpuriousRtxHostQueues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpSpuriousRtxHostQueues |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 83:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpAutoCorking", wireType)
			}
			m.TcpextTcpAutoCorking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpAutoCorking |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 84:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpSynRetrans", wireType)
			}
			m.TcpextTcpSynRetrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpSynRetrans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 85:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpOrigDataSent", wireType)
			}
			m.TcpextTcpOrigDataSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpOrigDataSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 86:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpHystartTrainDetect", wireType)
			}
			m.TcpextTcpHystartTrainDetect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpHystartTrainDetect |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 87:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpHystartTrainCwnd", wireType)
			}
			m.TcpextTcpHystartTrainCwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpHystartTrainCwnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 88:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpHystartDelayDetect", wireType)
			}
			m.TcpextTcpHystartDelayDetect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpHystartDelayDetect |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 89:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpHystartDelayCwnd", wireType)
			}
			m.TcpextTcpHystartDelayCwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpHystartDelayCwnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 90:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpAckSkippedSeq", wireType)
			}
			m.TcpextTcpAckSkippedSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpAckSkippedSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 91:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpAckSkippedChallenge", wireType)
			}
			m.TcpextTcpAckSkippedChallenge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpAckSkippedChallenge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 92:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpKeepAlive", wireType)
			}
			m.TcpextTcpKeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpKeepAlive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 93:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpDelivered", wireType)
			}
			m.TcpextTcpDelivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpDelivered |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 94:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpextTcpAckCompressed", wireType)
			}
			m.TcpextTcpAckCompressed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpextTcpAckCompressed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 95:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpextInBcastPkts", wireType)
			}
			m.IpextInBcastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpextInBcastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 96:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpextInOctets", wireType)
			}
			m.IpextInOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpextInOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 97:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpextOutOctets", wireType)
			}
			m.IpextOutOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpextOutOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 98:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpextInBcastOctets", wireType)
			}
			m.IpextInBcastOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpextInBcastOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpextInNoEctPkts", wireType)
			}
			m.IpextInNoEctPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpextInNoEctPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpextInEct0Pkts", wireType)
			}
			m.IpextInEct0Pkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpextInEct0Pkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTcpmon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTcpmon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTcpmon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTcpmon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTcpmon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTcpmon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTcpmon = fmt.Errorf("proto: unexpected end of group")
)
