// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tcpmon.proto

package tproto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MetricType int32

const (
	MetricType_TCP MetricType = 0
	MetricType_NIC MetricType = 1
	MetricType_NET MetricType = 2
)

var MetricType_name = map[int32]string{
	0: "TCP",
	1: "NIC",
	2: "NET",
}

var MetricType_value = map[string]int32{
	"TCP": 0,
	"NIC": 1,
	"NET": 2,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}

func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{0}
}

// from linux/include/net/tcp_states.h
type SocketState int32

const (
	SocketState_TCP_ESTABLISHED  SocketState = 0
	SocketState_TCP_SYN_SENT     SocketState = 1
	SocketState_TCP_SYN_RECV     SocketState = 2
	SocketState_TCP_FIN_WAIT1    SocketState = 3
	SocketState_TCP_FIN_WAIT2    SocketState = 4
	SocketState_TCP_TIME_WAIT    SocketState = 5
	SocketState_TCP_CLOSE        SocketState = 6
	SocketState_TCP_CLOSE_WAIT   SocketState = 7
	SocketState_TCP_LAST_ACK     SocketState = 8
	SocketState_TCP_LISTEN       SocketState = 9
	SocketState_TCP_CLOSING      SocketState = 10
	SocketState_TCP_NEW_SYN_RECV SocketState = 11
)

var SocketState_name = map[int32]string{
	0:  "TCP_ESTABLISHED",
	1:  "TCP_SYN_SENT",
	2:  "TCP_SYN_RECV",
	3:  "TCP_FIN_WAIT1",
	4:  "TCP_FIN_WAIT2",
	5:  "TCP_TIME_WAIT",
	6:  "TCP_CLOSE",
	7:  "TCP_CLOSE_WAIT",
	8:  "TCP_LAST_ACK",
	9:  "TCP_LISTEN",
	10: "TCP_CLOSING",
	11: "TCP_NEW_SYN_RECV",
}

var SocketState_value = map[string]int32{
	"TCP_ESTABLISHED":  0,
	"TCP_SYN_SENT":     1,
	"TCP_SYN_RECV":     2,
	"TCP_FIN_WAIT1":    3,
	"TCP_FIN_WAIT2":    4,
	"TCP_TIME_WAIT":    5,
	"TCP_CLOSE":        6,
	"TCP_CLOSE_WAIT":   7,
	"TCP_LAST_ACK":     8,
	"TCP_LISTEN":       9,
	"TCP_CLOSING":      10,
	"TCP_NEW_SYN_RECV": 11,
}

func (x SocketState) String() string {
	return proto.EnumName(SocketState_name, int32(x))
}

func (SocketState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{1}
}

type Metric struct {
	// Types that are valid to be assigned to Body:
	//
	//	*Metric_Tcp
	//	*Metric_Nic
	//	*Metric_Net
	Body isMetric_Body `protobuf_oneof:"body"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{0}
}
func (m *Metric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return m.Size()
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

type isMetric_Body interface {
	isMetric_Body()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Metric_Tcp struct {
	Tcp *TcpMetric `protobuf:"bytes,1,opt,name=tcp,proto3,oneof" json:"tcp,omitempty"`
}
type Metric_Nic struct {
	Nic *NicMetric `protobuf:"bytes,2,opt,name=nic,proto3,oneof" json:"nic,omitempty"`
}
type Metric_Net struct {
	Net *NetstatMetric `protobuf:"bytes,3,opt,name=net,proto3,oneof" json:"net,omitempty"`
}

func (*Metric_Tcp) isMetric_Body() {}
func (*Metric_Nic) isMetric_Body() {}
func (*Metric_Net) isMetric_Body() {}

func (m *Metric) GetBody() isMetric_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Metric) GetTcp() *TcpMetric {
	if x, ok := m.GetBody().(*Metric_Tcp); ok {
		return x.Tcp
	}
	return nil
}

func (m *Metric) GetNic() *NicMetric {
	if x, ok := m.GetBody().(*Metric_Nic); ok {
		return x.Nic
	}
	return nil
}

func (m *Metric) GetNet() *NetstatMetric {
	if x, ok := m.GetBody().(*Metric_Net); ok {
		return x.Net
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Metric) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Metric_Tcp)(nil),
		(*Metric_Nic)(nil),
		(*Metric_Net)(nil),
	}
}

// Socket memory usage. aka skmem
// check: https://man7.org/linux/man-pages/man8/ss.8.html
type SocketMemoryUsage struct {
	RmemAlloc  uint32 `protobuf:"varint,1,opt,name=rmem_alloc,json=rmemAlloc,proto3" json:"rmem_alloc,omitempty"`
	RcvBuf     uint32 `protobuf:"varint,2,opt,name=rcv_buf,json=rcvBuf,proto3" json:"rcv_buf,omitempty"`
	WmemAlloc  uint32 `protobuf:"varint,3,opt,name=wmem_alloc,json=wmemAlloc,proto3" json:"wmem_alloc,omitempty"`
	SndBuf     uint32 `protobuf:"varint,4,opt,name=snd_buf,json=sndBuf,proto3" json:"snd_buf,omitempty"`
	FwdAlloc   uint32 `protobuf:"varint,5,opt,name=fwd_alloc,json=fwdAlloc,proto3" json:"fwd_alloc,omitempty"`
	WmemQueued uint32 `protobuf:"varint,6,opt,name=wmem_queued,json=wmemQueued,proto3" json:"wmem_queued,omitempty"`
	OptMem     uint32 `protobuf:"varint,7,opt,name=opt_mem,json=optMem,proto3" json:"opt_mem,omitempty"`
	BackLog    uint32 `protobuf:"varint,8,opt,name=back_log,json=backLog,proto3" json:"back_log,omitempty"`
	SockDrop   uint32 `protobuf:"varint,9,opt,name=sock_drop,json=sockDrop,proto3" json:"sock_drop,omitempty"`
}

func (m *SocketMemoryUsage) Reset()         { *m = SocketMemoryUsage{} }
func (m *SocketMemoryUsage) String() string { return proto.CompactTextString(m) }
func (*SocketMemoryUsage) ProtoMessage()    {}
func (*SocketMemoryUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{1}
}
func (m *SocketMemoryUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocketMemoryUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocketMemoryUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocketMemoryUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocketMemoryUsage.Merge(m, src)
}
func (m *SocketMemoryUsage) XXX_Size() int {
	return m.Size()
}
func (m *SocketMemoryUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_SocketMemoryUsage.DiscardUnknown(m)
}

var xxx_messageInfo_SocketMemoryUsage proto.InternalMessageInfo

func (m *SocketMemoryUsage) GetRmemAlloc() uint32 {
	if m != nil {
		return m.RmemAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetRcvBuf() uint32 {
	if m != nil {
		return m.RcvBuf
	}
	return 0
}

func (m *SocketMemoryUsage) GetWmemAlloc() uint32 {
	if m != nil {
		return m.WmemAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetSndBuf() uint32 {
	if m != nil {
		return m.SndBuf
	}
	return 0
}

func (m *SocketMemoryUsage) GetFwdAlloc() uint32 {
	if m != nil {
		return m.FwdAlloc
	}
	return 0
}

func (m *SocketMemoryUsage) GetWmemQueued() uint32 {
	if m != nil {
		return m.WmemQueued
	}
	return 0
}

func (m *SocketMemoryUsage) GetOptMem() uint32 {
	if m != nil {
		return m.OptMem
	}
	return 0
}

func (m *SocketMemoryUsage) GetBackLog() uint32 {
	if m != nil {
		return m.BackLog
	}
	return 0
}

func (m *SocketMemoryUsage) GetSockDrop() uint32 {
	if m != nil {
		return m.SockDrop
	}
	return 0
}

type TimerInfo struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ExpireTimeUs uint64 `protobuf:"varint,2,opt,name=expire_time_us,json=expireTimeUs,proto3" json:"expire_time_us,omitempty"`
	Retrans      uint32 `protobuf:"varint,3,opt,name=retrans,proto3" json:"retrans,omitempty"`
}

func (m *TimerInfo) Reset()         { *m = TimerInfo{} }
func (m *TimerInfo) String() string { return proto.CompactTextString(m) }
func (*TimerInfo) ProtoMessage()    {}
func (*TimerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{2}
}
func (m *TimerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimerInfo.Merge(m, src)
}
func (m *TimerInfo) XXX_Size() int {
	return m.Size()
}
func (m *TimerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TimerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TimerInfo proto.InternalMessageInfo

func (m *TimerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TimerInfo) GetExpireTimeUs() uint64 {
	if m != nil {
		return m.ExpireTimeUs
	}
	return 0
}

func (m *TimerInfo) GetRetrans() uint32 {
	if m != nil {
		return m.Retrans
	}
	return 0
}

type ProcessInfo struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Pid  uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Fd   uint32 `protobuf:"varint,3,opt,name=fd,proto3" json:"fd,omitempty"`
}

func (m *ProcessInfo) Reset()         { *m = ProcessInfo{} }
func (m *ProcessInfo) String() string { return proto.CompactTextString(m) }
func (*ProcessInfo) ProtoMessage()    {}
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{3}
}
func (m *ProcessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInfo.Merge(m, src)
}
func (m *ProcessInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProcessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInfo proto.InternalMessageInfo

func (m *ProcessInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ProcessInfo) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *ProcessInfo) GetFd() uint32 {
	if m != nil {
		return m.Fd
	}
	return 0
}

type SocketMetric struct {
	State         SocketState        `protobuf:"varint,3,opt,name=state,proto3,enum=SocketState" json:"state,omitempty"`
	RecvQ         uint32             `protobuf:"varint,4,opt,name=recv_q,json=recvQ,proto3" json:"recv_q,omitempty"`
	SendQ         int64              `protobuf:"varint,5,opt,name=send_q,json=sendQ,proto3" json:"send_q,omitempty"`
	LocalAddr     string             `protobuf:"bytes,6,opt,name=local_addr,json=localAddr,proto3" json:"local_addr,omitempty"`
	PeerAddr      string             `protobuf:"bytes,7,opt,name=peer_addr,json=peerAddr,proto3" json:"peer_addr,omitempty"`
	Processes     []*ProcessInfo     `protobuf:"bytes,8,rep,name=processes,proto3" json:"processes,omitempty"`
	Timers        []*TimerInfo       `protobuf:"bytes,9,rep,name=timers,proto3" json:"timers,omitempty"`
	Skmem         *SocketMemoryUsage `protobuf:"bytes,10,opt,name=skmem,proto3" json:"skmem,omitempty"`
	Ts            bool               `protobuf:"varint,11,opt,name=ts,proto3" json:"ts,omitempty"`
	Sack          bool               `protobuf:"varint,12,opt,name=sack,proto3" json:"sack,omitempty"`
	Cubic         bool               `protobuf:"varint,13,opt,name=cubic,proto3" json:"cubic,omitempty"`
	AppLimited    bool               `protobuf:"varint,14,opt,name=app_limited,json=appLimited,proto3" json:"app_limited,omitempty"`
	PacingRate    float64            `protobuf:"fixed64,15,opt,name=pacing_rate,json=pacingRate,proto3" json:"pacing_rate,omitempty"`
	DeliveryRate  float64            `protobuf:"fixed64,16,opt,name=delivery_rate,json=deliveryRate,proto3" json:"delivery_rate,omitempty"`
	Send          float64            `protobuf:"fixed64,17,opt,name=send,proto3" json:"send,omitempty"`
	SndWscale     uint32             `protobuf:"varint,18,opt,name=snd_wscale,json=sndWscale,proto3" json:"snd_wscale,omitempty"`
	RcvWscale     uint32             `protobuf:"varint,19,opt,name=rcv_wscale,json=rcvWscale,proto3" json:"rcv_wscale,omitempty"`
	Rto           float64            `protobuf:"fixed64,20,opt,name=rto,proto3" json:"rto,omitempty"`
	Rtt           float64            `protobuf:"fixed64,21,opt,name=rtt,proto3" json:"rtt,omitempty"`
	Rttvar        float64            `protobuf:"fixed64,22,opt,name=rttvar,proto3" json:"rttvar,omitempty"`
	Minrtt        float64            `protobuf:"fixed64,23,opt,name=minrtt,proto3" json:"minrtt,omitempty"`
	RcvRtt        float64            `protobuf:"fixed64,24,opt,name=rcv_rtt,json=rcvRtt,proto3" json:"rcv_rtt,omitempty"`
	RetransNow    uint32             `protobuf:"varint,25,opt,name=retrans_now,json=retransNow,proto3" json:"retrans_now,omitempty"`
	RetransTotal  uint32             `protobuf:"varint,26,opt,name=retrans_total,json=retransTotal,proto3" json:"retrans_total,omitempty"`
	Ato           float64            `protobuf:"fixed64,30,opt,name=ato,proto3" json:"ato,omitempty"`
	Mss           uint32             `protobuf:"varint,31,opt,name=mss,proto3" json:"mss,omitempty"`
	Pmtu          uint32             `protobuf:"varint,32,opt,name=pmtu,proto3" json:"pmtu,omitempty"`
	Rcvmss        uint32             `protobuf:"varint,33,opt,name=rcvmss,proto3" json:"rcvmss,omitempty"`
	Advmss        uint32             `protobuf:"varint,34,opt,name=advmss,proto3" json:"advmss,omitempty"`
	Cwnd          uint32             `protobuf:"varint,35,opt,name=cwnd,proto3" json:"cwnd,omitempty"`
	SndWnd        uint32             `protobuf:"varint,36,opt,name=snd_wnd,json=sndWnd,proto3" json:"snd_wnd,omitempty"`
	BytesSent     uint32             `protobuf:"varint,37,opt,name=bytes_sent,json=bytesSent,proto3" json:"bytes_sent,omitempty"`
	BytesAcked    uint64             `protobuf:"varint,38,opt,name=bytes_acked,json=bytesAcked,proto3" json:"bytes_acked,omitempty"`
	BytesReceived uint64             `protobuf:"varint,39,opt,name=bytes_received,json=bytesReceived,proto3" json:"bytes_received,omitempty"`
	SegsOut       uint32             `protobuf:"varint,40,opt,name=segs_out,json=segsOut,proto3" json:"segs_out,omitempty"`
	SegsIn        uint32             `protobuf:"varint,41,opt,name=segs_in,json=segsIn,proto3" json:"segs_in,omitempty"`
	Lastsnd       uint32             `protobuf:"varint,42,opt,name=lastsnd,proto3" json:"lastsnd,omitempty"`
	Lastrcv       uint32             `protobuf:"varint,43,opt,name=lastrcv,proto3" json:"lastrcv,omitempty"`
	Lastack       uint32             `protobuf:"varint,44,opt,name=lastack,proto3" json:"lastack,omitempty"`
	Delivered     uint32             `protobuf:"varint,45,opt,name=delivered,proto3" json:"delivered,omitempty"`
	BusyMs        uint32             `protobuf:"varint,46,opt,name=busy_ms,json=busyMs,proto3" json:"busy_ms,omitempty"`
	RcvSpace      uint32             `protobuf:"varint,47,opt,name=rcv_space,json=rcvSpace,proto3" json:"rcv_space,omitempty"`
	RcvSsthresh   uint32             `protobuf:"varint,48,opt,name=rcv_ssthresh,json=rcvSsthresh,proto3" json:"rcv_ssthresh,omitempty"`
	DataSegsOut   uint32             `protobuf:"varint,49,opt,name=data_segs_out,json=dataSegsOut,proto3" json:"data_segs_out,omitempty"`
	DataSegsIn    uint32             `protobuf:"varint,50,opt,name=data_segs_in,json=dataSegsIn,proto3" json:"data_segs_in,omitempty"`
	RwndLimited   uint32             `protobuf:"varint,51,opt,name=rwnd_limited,json=rwndLimited,proto3" json:"rwnd_limited,omitempty"`
	SndbufLimited uint32             `protobuf:"varint,52,opt,name=sndbuf_limited,json=sndbufLimited,proto3" json:"sndbuf_limited,omitempty"`
	Ecn           bool               `protobuf:"varint,53,opt,name=ecn,proto3" json:"ecn,omitempty"`
	Ecnseen       bool               `protobuf:"varint,54,opt,name=ecnseen,proto3" json:"ecnseen,omitempty"`
}

func (m *SocketMetric) Reset()         { *m = SocketMetric{} }
func (m *SocketMetric) String() string { return proto.CompactTextString(m) }
func (*SocketMetric) ProtoMessage()    {}
func (*SocketMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{4}
}
func (m *SocketMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocketMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocketMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocketMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocketMetric.Merge(m, src)
}
func (m *SocketMetric) XXX_Size() int {
	return m.Size()
}
func (m *SocketMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_SocketMetric.DiscardUnknown(m)
}

var xxx_messageInfo_SocketMetric proto.InternalMessageInfo

func (m *SocketMetric) GetState() SocketState {
	if m != nil {
		return m.State
	}
	return SocketState_TCP_ESTABLISHED
}

func (m *SocketMetric) GetRecvQ() uint32 {
	if m != nil {
		return m.RecvQ
	}
	return 0
}

func (m *SocketMetric) GetSendQ() int64 {
	if m != nil {
		return m.SendQ
	}
	return 0
}

func (m *SocketMetric) GetLocalAddr() string {
	if m != nil {
		return m.LocalAddr
	}
	return ""
}

func (m *SocketMetric) GetPeerAddr() string {
	if m != nil {
		return m.PeerAddr
	}
	return ""
}

func (m *SocketMetric) GetProcesses() []*ProcessInfo {
	if m != nil {
		return m.Processes
	}
	return nil
}

func (m *SocketMetric) GetTimers() []*TimerInfo {
	if m != nil {
		return m.Timers
	}
	return nil
}

func (m *SocketMetric) GetSkmem() *SocketMemoryUsage {
	if m != nil {
		return m.Skmem
	}
	return nil
}

func (m *SocketMetric) GetTs() bool {
	if m != nil {
		return m.Ts
	}
	return false
}

func (m *SocketMetric) GetSack() bool {
	if m != nil {
		return m.Sack
	}
	return false
}

func (m *SocketMetric) GetCubic() bool {
	if m != nil {
		return m.Cubic
	}
	return false
}

func (m *SocketMetric) GetAppLimited() bool {
	if m != nil {
		return m.AppLimited
	}
	return false
}

func (m *SocketMetric) GetPacingRate() float64 {
	if m != nil {
		return m.PacingRate
	}
	return 0
}

func (m *SocketMetric) GetDeliveryRate() float64 {
	if m != nil {
		return m.DeliveryRate
	}
	return 0
}

func (m *SocketMetric) GetSend() float64 {
	if m != nil {
		return m.Send
	}
	return 0
}

func (m *SocketMetric) GetSndWscale() uint32 {
	if m != nil {
		return m.SndWscale
	}
	return 0
}

func (m *SocketMetric) GetRcvWscale() uint32 {
	if m != nil {
		return m.RcvWscale
	}
	return 0
}

func (m *SocketMetric) GetRto() float64 {
	if m != nil {
		return m.Rto
	}
	return 0
}

func (m *SocketMetric) GetRtt() float64 {
	if m != nil {
		return m.Rtt
	}
	return 0
}

func (m *SocketMetric) GetRttvar() float64 {
	if m != nil {
		return m.Rttvar
	}
	return 0
}

func (m *SocketMetric) GetMinrtt() float64 {
	if m != nil {
		return m.Minrtt
	}
	return 0
}

func (m *SocketMetric) GetRcvRtt() float64 {
	if m != nil {
		return m.RcvRtt
	}
	return 0
}

func (m *SocketMetric) GetRetransNow() uint32 {
	if m != nil {
		return m.RetransNow
	}
	return 0
}

func (m *SocketMetric) GetRetransTotal() uint32 {
	if m != nil {
		return m.RetransTotal
	}
	return 0
}

func (m *SocketMetric) GetAto() float64 {
	if m != nil {
		return m.Ato
	}
	return 0
}

func (m *SocketMetric) GetMss() uint32 {
	if m != nil {
		return m.Mss
	}
	return 0
}

func (m *SocketMetric) GetPmtu() uint32 {
	if m != nil {
		return m.Pmtu
	}
	return 0
}

func (m *SocketMetric) GetRcvmss() uint32 {
	if m != nil {
		return m.Rcvmss
	}
	return 0
}

func (m *SocketMetric) GetAdvmss() uint32 {
	if m != nil {
		return m.Advmss
	}
	return 0
}

func (m *SocketMetric) GetCwnd() uint32 {
	if m != nil {
		return m.Cwnd
	}
	return 0
}

func (m *SocketMetric) GetSndWnd() uint32 {
	if m != nil {
		return m.SndWnd
	}
	return 0
}

func (m *SocketMetric) GetBytesSent() uint32 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *SocketMetric) GetBytesAcked() uint64 {
	if m != nil {
		return m.BytesAcked
	}
	return 0
}

func (m *SocketMetric) GetBytesReceived() uint64 {
	if m != nil {
		return m.BytesReceived
	}
	return 0
}

func (m *SocketMetric) GetSegsOut() uint32 {
	if m != nil {
		return m.SegsOut
	}
	return 0
}

func (m *SocketMetric) GetSegsIn() uint32 {
	if m != nil {
		return m.SegsIn
	}
	return 0
}

func (m *SocketMetric) GetLastsnd() uint32 {
	if m != nil {
		return m.Lastsnd
	}
	return 0
}

func (m *SocketMetric) GetLastrcv() uint32 {
	if m != nil {
		return m.Lastrcv
	}
	return 0
}

func (m *SocketMetric) GetLastack() uint32 {
	if m != nil {
		return m.Lastack
	}
	return 0
}

func (m *SocketMetric) GetDelivered() uint32 {
	if m != nil {
		return m.Delivered
	}
	return 0
}

func (m *SocketMetric) GetBusyMs() uint32 {
	if m != nil {
		return m.BusyMs
	}
	return 0
}

func (m *SocketMetric) GetRcvSpace() uint32 {
	if m != nil {
		return m.RcvSpace
	}
	return 0
}

func (m *SocketMetric) GetRcvSsthresh() uint32 {
	if m != nil {
		return m.RcvSsthresh
	}
	return 0
}

func (m *SocketMetric) GetDataSegsOut() uint32 {
	if m != nil {
		return m.DataSegsOut
	}
	return 0
}

func (m *SocketMetric) GetDataSegsIn() uint32 {
	if m != nil {
		return m.DataSegsIn
	}
	return 0
}

func (m *SocketMetric) GetRwndLimited() uint32 {
	if m != nil {
		return m.RwndLimited
	}
	return 0
}

func (m *SocketMetric) GetSndbufLimited() uint32 {
	if m != nil {
		return m.SndbufLimited
	}
	return 0
}

func (m *SocketMetric) GetEcn() bool {
	if m != nil {
		return m.Ecn
	}
	return false
}

func (m *SocketMetric) GetEcnseen() bool {
	if m != nil {
		return m.Ecnseen
	}
	return false
}

type TcpMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	Sockets []*SocketMetric `protobuf:"bytes,3,rep,name=sockets,proto3" json:"sockets,omitempty"`
}

func (m *TcpMetric) Reset()         { *m = TcpMetric{} }
func (m *TcpMetric) String() string { return proto.CompactTextString(m) }
func (*TcpMetric) ProtoMessage()    {}
func (*TcpMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{5}
}
func (m *TcpMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TcpMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TcpMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TcpMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TcpMetric.Merge(m, src)
}
func (m *TcpMetric) XXX_Size() int {
	return m.Size()
}
func (m *TcpMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_TcpMetric.DiscardUnknown(m)
}

var xxx_messageInfo_TcpMetric proto.InternalMessageInfo

func (m *TcpMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TcpMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *TcpMetric) GetSockets() []*SocketMetric {
	if m != nil {
		return m.Sockets
	}
	return nil
}

type IfaceMetric struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RxErrors     uint64 `protobuf:"varint,2,opt,name=rx_errors,json=rxErrors,proto3" json:"rx_errors,omitempty"`
	RxDropped    uint64 `protobuf:"varint,3,opt,name=rx_dropped,json=rxDropped,proto3" json:"rx_dropped,omitempty"`
	RxOverruns   uint64 `protobuf:"varint,4,opt,name=rx_overruns,json=rxOverruns,proto3" json:"rx_overruns,omitempty"`
	RxFrame      uint64 `protobuf:"varint,5,opt,name=rx_frame,json=rxFrame,proto3" json:"rx_frame,omitempty"`
	TxErrors     uint64 `protobuf:"varint,6,opt,name=tx_errors,json=txErrors,proto3" json:"tx_errors,omitempty"`
	TxDropped    uint64 `protobuf:"varint,7,opt,name=tx_dropped,json=txDropped,proto3" json:"tx_dropped,omitempty"`
	TxOverruns   uint64 `protobuf:"varint,8,opt,name=tx_overruns,json=txOverruns,proto3" json:"tx_overruns,omitempty"`
	TxCarrier    uint64 `protobuf:"varint,9,opt,name=tx_carrier,json=txCarrier,proto3" json:"tx_carrier,omitempty"`
	TxCollisions uint64 `protobuf:"varint,10,opt,name=tx_collisions,json=txCollisions,proto3" json:"tx_collisions,omitempty"`
}

func (m *IfaceMetric) Reset()         { *m = IfaceMetric{} }
func (m *IfaceMetric) String() string { return proto.CompactTextString(m) }
func (*IfaceMetric) ProtoMessage()    {}
func (*IfaceMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{6}
}
func (m *IfaceMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IfaceMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IfaceMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IfaceMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IfaceMetric.Merge(m, src)
}
func (m *IfaceMetric) XXX_Size() int {
	return m.Size()
}
func (m *IfaceMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_IfaceMetric.DiscardUnknown(m)
}

var xxx_messageInfo_IfaceMetric proto.InternalMessageInfo

func (m *IfaceMetric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IfaceMetric) GetRxErrors() uint64 {
	if m != nil {
		return m.RxErrors
	}
	return 0
}

func (m *IfaceMetric) GetRxDropped() uint64 {
	if m != nil {
		return m.RxDropped
	}
	return 0
}

func (m *IfaceMetric) GetRxOverruns() uint64 {
	if m != nil {
		return m.RxOverruns
	}
	return 0
}

func (m *IfaceMetric) GetRxFrame() uint64 {
	if m != nil {
		return m.RxFrame
	}
	return 0
}

func (m *IfaceMetric) GetTxErrors() uint64 {
	if m != nil {
		return m.TxErrors
	}
	return 0
}

func (m *IfaceMetric) GetTxDropped() uint64 {
	if m != nil {
		return m.TxDropped
	}
	return 0
}

func (m *IfaceMetric) GetTxOverruns() uint64 {
	if m != nil {
		return m.TxOverruns
	}
	return 0
}

func (m *IfaceMetric) GetTxCarrier() uint64 {
	if m != nil {
		return m.TxCarrier
	}
	return 0
}

func (m *IfaceMetric) GetTxCollisions() uint64 {
	if m != nil {
		return m.TxCollisions
	}
	return 0
}

type NicMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// fields
	Ifaces []*IfaceMetric `protobuf:"bytes,3,rep,name=ifaces,proto3" json:"ifaces,omitempty"`
}

func (m *NicMetric) Reset()         { *m = NicMetric{} }
func (m *NicMetric) String() string { return proto.CompactTextString(m) }
func (*NicMetric) ProtoMessage()    {}
func (*NicMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{7}
}
func (m *NicMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NicMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NicMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NicMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NicMetric.Merge(m, src)
}
func (m *NicMetric) XXX_Size() int {
	return m.Size()
}
func (m *NicMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_NicMetric.DiscardUnknown(m)
}

var xxx_messageInfo_NicMetric proto.InternalMessageInfo

func (m *NicMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NicMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *NicMetric) GetIfaces() []*IfaceMetric {
	if m != nil {
		return m.Ifaces
	}
	return nil
}

type NetstatMetric struct {
	// header
	Timestamp int64      `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=MetricType" json:"type,omitempty"`
	// ip /proc/net/snmp
	IpForwarding      uint64 `protobuf:"varint,100,opt,name=ip_forwarding,json=ipForwarding,proto3" json:"ip_forwarding,omitempty"`
	IpDefaultTtl      uint64 `protobuf:"varint,101,opt,name=ip_default_ttl,json=ipDefaultTtl,proto3" json:"ip_default_ttl,omitempty"`
	IpInReceives      uint64 `protobuf:"varint,102,opt,name=ip_in_receives,json=ipInReceives,proto3" json:"ip_in_receives,omitempty"`
	IpInHdrErrors     uint64 `protobuf:"varint,103,opt,name=ip_in_hdr_errors,json=ipInHdrErrors,proto3" json:"ip_in_hdr_errors,omitempty"`
	IpInAddrErrors    uint64 `protobuf:"varint,104,opt,name=ip_in_addr_errors,json=ipInAddrErrors,proto3" json:"ip_in_addr_errors,omitempty"`
	IpForwDatagrams   uint64 `protobuf:"varint,105,opt,name=ip_forw_datagrams,json=ipForwDatagrams,proto3" json:"ip_forw_datagrams,omitempty"`
	IpInUnknownProtos uint64 `protobuf:"varint,106,opt,name=ip_in_unknown_protos,json=ipInUnknownProtos,proto3" json:"ip_in_unknown_protos,omitempty"`
	IpInDiscards      uint64 `protobuf:"varint,107,opt,name=ip_in_discards,json=ipInDiscards,proto3" json:"ip_in_discards,omitempty"`
	IpInDelivers      uint64 `protobuf:"varint,108,opt,name=ip_in_delivers,json=ipInDelivers,proto3" json:"ip_in_delivers,omitempty"`
	IpOutRequests     uint64 `protobuf:"varint,109,opt,name=ip_out_requests,json=ipOutRequests,proto3" json:"ip_out_requests,omitempty"`
	IpOutDiscards     uint64 `protobuf:"varint,110,opt,name=ip_out_discards,json=ipOutDiscards,proto3" json:"ip_out_discards,omitempty"`
	IpOutNoRoutes     uint64 `protobuf:"varint,111,opt,name=ip_out_no_routes,json=ipOutNoRoutes,proto3" json:"ip_out_no_routes,omitempty"`
	IpReasmTimeout    uint64 `protobuf:"varint,112,opt,name=ip_reasm_timeout,json=ipReasmTimeout,proto3" json:"ip_reasm_timeout,omitempty"`
	IpReasmReqds      uint64 `protobuf:"varint,113,opt,name=ip_reasm_reqds,json=ipReasmReqds,proto3" json:"ip_reasm_reqds,omitempty"`
	IpReasmOks        uint64 `protobuf:"varint,114,opt,name=ip_reasm_oks,json=ipReasmOks,proto3" json:"ip_reasm_oks,omitempty"`
	IpReasmFails      uint64 `protobuf:"varint,115,opt,name=ip_reasm_fails,json=ipReasmFails,proto3" json:"ip_reasm_fails,omitempty"`
	IpFragOks         uint64 `protobuf:"varint,116,opt,name=ip_frag_oks,json=ipFragOks,proto3" json:"ip_frag_oks,omitempty"`
	IpFragFails       uint64 `protobuf:"varint,117,opt,name=ip_frag_fails,json=ipFragFails,proto3" json:"ip_frag_fails,omitempty"`
	IpFragCreates     uint64 `protobuf:"varint,118,opt,name=ip_frag_creates,json=ipFragCreates,proto3" json:"ip_frag_creates,omitempty"`
	// ip ext /proc/net/netstat
	IpInNoRoutes      uint64 `protobuf:"varint,600,opt,name=ip_in_no_routes,json=ipInNoRoutes,proto3" json:"ip_in_no_routes,omitempty"`
	IpInTruncatedPkts uint64 `protobuf:"varint,601,opt,name=ip_in_truncated_pkts,json=ipInTruncatedPkts,proto3" json:"ip_in_truncated_pkts,omitempty"`
	IpInMcastPkts     uint64 `protobuf:"varint,602,opt,name=ip_in_mcast_pkts,json=ipInMcastPkts,proto3" json:"ip_in_mcast_pkts,omitempty"`
	IpOutMcastPkts    uint64 `protobuf:"varint,603,opt,name=ip_out_mcast_pkts,json=ipOutMcastPkts,proto3" json:"ip_out_mcast_pkts,omitempty"`
	IpInBcastPkts     uint64 `protobuf:"varint,604,opt,name=ip_in_bcast_pkts,json=ipInBcastPkts,proto3" json:"ip_in_bcast_pkts,omitempty"`
	IpOutBcastPkts    uint64 `protobuf:"varint,605,opt,name=ip_out_bcast_pkts,json=ipOutBcastPkts,proto3" json:"ip_out_bcast_pkts,omitempty"`
	IpInOctets        uint64 `protobuf:"varint,606,opt,name=ip_in_octets,json=ipInOctets,proto3" json:"ip_in_octets,omitempty"`
	IpOutOctets       uint64 `protobuf:"varint,607,opt,name=ip_out_octets,json=ipOutOctets,proto3" json:"ip_out_octets,omitempty"`
	IpInMcastOctets   uint64 `protobuf:"varint,608,opt,name=ip_in_mcast_octets,json=ipInMcastOctets,proto3" json:"ip_in_mcast_octets,omitempty"`
	IpOutMcastOctets  uint64 `protobuf:"varint,609,opt,name=ip_out_mcast_octets,json=ipOutMcastOctets,proto3" json:"ip_out_mcast_octets,omitempty"`
	IpInBcastOctets   uint64 `protobuf:"varint,610,opt,name=ip_in_bcast_octets,json=ipInBcastOctets,proto3" json:"ip_in_bcast_octets,omitempty"`
	IpOutBcastOctets  uint64 `protobuf:"varint,611,opt,name=ip_out_bcast_octets,json=ipOutBcastOctets,proto3" json:"ip_out_bcast_octets,omitempty"`
	IpInCsumErrors    uint64 `protobuf:"varint,612,opt,name=ip_in_csum_errors,json=ipInCsumErrors,proto3" json:"ip_in_csum_errors,omitempty"`
	IpInNoEctPkts     uint64 `protobuf:"varint,613,opt,name=ip_in_no_ect_pkts,json=ipInNoEctPkts,proto3" json:"ip_in_no_ect_pkts,omitempty"`
	IpInEct1Pkts      uint64 `protobuf:"varint,614,opt,name=ip_in_ect1_pkts,json=ipInEct1Pkts,proto3" json:"ip_in_ect1_pkts,omitempty"`
	IpInEct0Pkts      uint64 `protobuf:"varint,615,opt,name=ip_in_ect0_pkts,json=ipInEct0Pkts,proto3" json:"ip_in_ect0_pkts,omitempty"`
	IpInCePkts        uint64 `protobuf:"varint,616,opt,name=ip_in_ce_pkts,json=ipInCePkts,proto3" json:"ip_in_ce_pkts,omitempty"`
	IpReasmOverlaps   uint64 `protobuf:"varint,617,opt,name=ip_reasm_overlaps,json=ipReasmOverlaps,proto3" json:"ip_reasm_overlaps,omitempty"`
	// udp /proc/net/snmp
	UdpInDatagrams  uint64 `protobuf:"varint,200,opt,name=udp_in_datagrams,json=udpInDatagrams,proto3" json:"udp_in_datagrams,omitempty"`
	UdpNoPorts      uint64 `protobuf:"varint,201,opt,name=udp_no_ports,json=udpNoPorts,proto3" json:"udp_no_ports,omitempty"`
	UdpInErrors     uint64 `protobuf:"varint,202,opt,name=udp_in_errors,json=udpInErrors,proto3" json:"udp_in_errors,omitempty"`
	UdpOutDatagrams uint64 `protobuf:"varint,203,opt,name=udp_out_datagrams,json=udpOutDatagrams,proto3" json:"udp_out_datagrams,omitempty"`
	UdpRcvbufErrors uint64 `protobuf:"varint,204,opt,name=udp_rcvbuf_errors,json=udpRcvbufErrors,proto3" json:"udp_rcvbuf_errors,omitempty"`
	UdpSndbufErrors uint64 `protobuf:"varint,205,opt,name=udp_sndbuf_errors,json=udpSndbufErrors,proto3" json:"udp_sndbuf_errors,omitempty"`
	UdpInCsumErrors uint64 `protobuf:"varint,206,opt,name=udp_in_csum_errors,json=udpInCsumErrors,proto3" json:"udp_in_csum_errors,omitempty"`
	UdpIgnoredMulti uint64 `protobuf:"varint,207,opt,name=udp_ignored_multi,json=udpIgnoredMulti,proto3" json:"udp_ignored_multi,omitempty"`
	UdpMemErrors    uint64 `protobuf:"varint,208,opt,name=udp_mem_errors,json=udpMemErrors,proto3" json:"udp_mem_errors,omitempty"`
	// tcp /proc/net/snmp
	TcpRtoAlgorithm uint64 `protobuf:"varint,300,opt,name=tcp_rto_algorithm,json=tcpRtoAlgorithm,proto3" json:"tcp_rto_algorithm,omitempty"`
	TcpRtoMin       uint64 `protobuf:"varint,301,opt,name=tcp_rto_min,json=tcpRtoMin,proto3" json:"tcp_rto_min,omitempty"`
	TcpRtoMax       uint64 `protobuf:"varint,302,opt,name=tcp_rto_max,json=tcpRtoMax,proto3" json:"tcp_rto_max,omitempty"`
	TcpMaxConn      int64  `protobuf:"varint,303,opt,name=tcp_max_conn,json=tcpMaxConn,proto3" json:"tcp_max_conn,omitempty"`
	TcpActiveOpens  uint64 `protobuf:"varint,304,opt,name=tcp_active_opens,json=tcpActiveOpens,proto3" json:"tcp_active_opens,omitempty"`
	TcpPassiveOpens uint64 `protobuf:"varint,305,opt,name=tcp_passive_opens,json=tcpPassiveOpens,proto3" json:"tcp_passive_opens,omitempty"`
	TcpAttemptFails uint64 `protobuf:"varint,306,opt,name=tcp_attempt_fails,json=tcpAttemptFails,proto3" json:"tcp_attempt_fails,omitempty"`
	TcpEstabResets  uint64 `protobuf:"varint,307,opt,name=tcp_estab_resets,json=tcpEstabResets,proto3" json:"tcp_estab_resets,omitempty"`
	TcpCurrEstab    uint64 `protobuf:"varint,308,opt,name=tcp_curr_estab,json=tcpCurrEstab,proto3" json:"tcp_curr_estab,omitempty"`
	TcpInSegs       uint64 `protobuf:"varint,309,opt,name=tcp_in_segs,json=tcpInSegs,proto3" json:"tcp_in_segs,omitempty"`
	TcpOutSegs      uint64 `protobuf:"varint,310,opt,name=tcp_out_segs,json=tcpOutSegs,proto3" json:"tcp_out_segs,omitempty"`
	TcpRetransSegs  uint64 `protobuf:"varint,311,opt,name=tcp_retrans_segs,json=tcpRetransSegs,proto3" json:"tcp_retrans_segs,omitempty"`
	TcpInErrs       uint64 `protobuf:"varint,312,opt,name=tcp_in_errs,json=tcpInErrs,proto3" json:"tcp_in_errs,omitempty"`
	TcpOutRsts      uint64 `protobuf:"varint,313,opt,name=tcp_out_rsts,json=tcpOutRsts,proto3" json:"tcp_out_rsts,omitempty"`
	TcpInCsumErrors uint64 `protobuf:"varint,314,opt,name=tcp_in_csum_errors,json=tcpInCsumErrors,proto3" json:"tcp_in_csum_errors,omitempty"`
	// tcp ext /proc/net/netstat
	TcpSyncookiesSent         uint64 `protobuf:"varint,400,opt,name=tcp_syncookies_sent,json=tcpSyncookiesSent,proto3" json:"tcp_syncookies_sent,omitempty"`
	TcpSyncookiesRecv         uint64 `protobuf:"varint,401,opt,name=tcp_syncookies_recv,json=tcpSyncookiesRecv,proto3" json:"tcp_syncookies_recv,omitempty"`
	TcpSyncookiesFailed       uint64 `protobuf:"varint,402,opt,name=tcp_syncookies_failed,json=tcpSyncookiesFailed,proto3" json:"tcp_syncookies_failed,omitempty"`
	TcpEmbryonicRsts          uint64 `protobuf:"varint,403,opt,name=tcp_embryonic_rsts,json=tcpEmbryonicRsts,proto3" json:"tcp_embryonic_rsts,omitempty"`
	TcpPruneCalled            uint64 `protobuf:"varint,404,opt,name=tcp_prune_called,json=tcpPruneCalled,proto3" json:"tcp_prune_called,omitempty"`
	TcpRcvPruned              uint64 `protobuf:"varint,405,opt,name=tcp_rcv_pruned,json=tcpRcvPruned,proto3" json:"tcp_rcv_pruned,omitempty"`
	TcpOfoPruned              uint64 `protobuf:"varint,406,opt,name=tcp_ofo_pruned,json=tcpOfoPruned,proto3" json:"tcp_ofo_pruned,omitempty"`
	TcpOutOfWindowIcmps       uint64 `protobuf:"varint,407,opt,name=tcp_out_of_window_icmps,json=tcpOutOfWindowIcmps,proto3" json:"tcp_out_of_window_icmps,omitempty"`
	TcpLockDroppedIcmps       uint64 `protobuf:"varint,408,opt,name=tcp_lock_dropped_icmps,json=tcpLockDroppedIcmps,proto3" json:"tcp_lock_dropped_icmps,omitempty"`
	TcpArpFilter              uint64 `protobuf:"varint,409,opt,name=tcp_arp_filter,json=tcpArpFilter,proto3" json:"tcp_arp_filter,omitempty"`
	TcpTw                     uint64 `protobuf:"varint,410,opt,name=tcp_tw,json=tcpTw,proto3" json:"tcp_tw,omitempty"`
	TcpTwRecycled             uint64 `protobuf:"varint,411,opt,name=tcp_tw_recycled,json=tcpTwRecycled,proto3" json:"tcp_tw_recycled,omitempty"`
	TcpTwKilled               uint64 `protobuf:"varint,412,opt,name=tcp_tw_killed,json=tcpTwKilled,proto3" json:"tcp_tw_killed,omitempty"`
	TcpPawsActive             uint64 `protobuf:"varint,413,opt,name=tcp_paws_active,json=tcpPawsActive,proto3" json:"tcp_paws_active,omitempty"`
	TcpPawsEstab              uint64 `protobuf:"varint,414,opt,name=tcp_paws_estab,json=tcpPawsEstab,proto3" json:"tcp_paws_estab,omitempty"`
	TcpDelayedAcks            uint64 `protobuf:"varint,415,opt,name=tcp_delayed_acks,json=tcpDelayedAcks,proto3" json:"tcp_delayed_acks,omitempty"`
	TcpDelayedAckLocked       uint64 `protobuf:"varint,416,opt,name=tcp_delayed_ack_locked,json=tcpDelayedAckLocked,proto3" json:"tcp_delayed_ack_locked,omitempty"`
	TcpDelayedAckLost         uint64 `protobuf:"varint,417,opt,name=tcp_delayed_ack_lost,json=tcpDelayedAckLost,proto3" json:"tcp_delayed_ack_lost,omitempty"`
	TcpListenOverflows        uint64 `protobuf:"varint,418,opt,name=tcp_listen_overflows,json=tcpListenOverflows,proto3" json:"tcp_listen_overflows,omitempty"`
	TcpListenDrops            uint64 `protobuf:"varint,419,opt,name=tcp_listen_drops,json=tcpListenDrops,proto3" json:"tcp_listen_drops,omitempty"`
	TcpHpHits                 uint64 `protobuf:"varint,420,opt,name=tcp_hp_hits,json=tcpHpHits,proto3" json:"tcp_hp_hits,omitempty"`
	TcpPureAcks               uint64 `protobuf:"varint,421,opt,name=tcp_pure_acks,json=tcpPureAcks,proto3" json:"tcp_pure_acks,omitempty"`
	TcpHpAcks                 uint64 `protobuf:"varint,422,opt,name=tcp_hp_acks,json=tcpHpAcks,proto3" json:"tcp_hp_acks,omitempty"`
	TcpRenoRecovery           uint64 `protobuf:"varint,423,opt,name=tcp_reno_recovery,json=tcpRenoRecovery,proto3" json:"tcp_reno_recovery,omitempty"`
	TcpSackRecovery           uint64 `protobuf:"varint,424,opt,name=tcp_sack_recovery,json=tcpSackRecovery,proto3" json:"tcp_sack_recovery,omitempty"`
	TcpSackReneging           uint64 `protobuf:"varint,425,opt,name=tcp_sack_reneging,json=tcpSackReneging,proto3" json:"tcp_sack_reneging,omitempty"`
	TcpSackReorder            uint64 `protobuf:"varint,426,opt,name=tcp_sack_reorder,json=tcpSackReorder,proto3" json:"tcp_sack_reorder,omitempty"`
	TcpRenoReorder            uint64 `protobuf:"varint,427,opt,name=tcp_reno_reorder,json=tcpRenoReorder,proto3" json:"tcp_reno_reorder,omitempty"`
	TcpTsReorder              uint64 `protobuf:"varint,428,opt,name=tcp_ts_reorder,json=tcpTsReorder,proto3" json:"tcp_ts_reorder,omitempty"`
	TcpFullUndo               uint64 `protobuf:"varint,429,opt,name=tcp_full_undo,json=tcpFullUndo,proto3" json:"tcp_full_undo,omitempty"`
	TcpPartialUndo            uint64 `protobuf:"varint,430,opt,name=tcp_partial_undo,json=tcpPartialUndo,proto3" json:"tcp_partial_undo,omitempty"`
	TcpDsackUndo              uint64 `protobuf:"varint,431,opt,name=tcp_dsack_undo,json=tcpDsackUndo,proto3" json:"tcp_dsack_undo,omitempty"`
	TcpLossUndo               uint64 `protobuf:"varint,432,opt,name=tcp_loss_undo,json=tcpLossUndo,proto3" json:"tcp_loss_undo,omitempty"`
	TcpLostRetransmit         uint64 `protobuf:"varint,433,opt,name=tcp_lost_retransmit,json=tcpLostRetransmit,proto3" json:"tcp_lost_retransmit,omitempty"`
	TcpRenoFailures           uint64 `protobuf:"varint,434,opt,name=tcp_reno_failures,json=tcpRenoFailures,proto3" json:"tcp_reno_failures,omitempty"`
	TcpSackFailures           uint64 `protobuf:"varint,435,opt,name=tcp_sack_failures,json=tcpSackFailures,proto3" json:"tcp_sack_failures,omitempty"`
	TcpLossFailures           uint64 `protobuf:"varint,436,opt,name=tcp_loss_failures,json=tcpLossFailures,proto3" json:"tcp_loss_failures,omitempty"`
	TcpFastRetrans            uint64 `protobuf:"varint,437,opt,name=tcp_fast_retrans,json=tcpFastRetrans,proto3" json:"tcp_fast_retrans,omitempty"`
	TcpSlowStartRetrans       uint64 `protobuf:"varint,438,opt,name=tcp_slow_start_retrans,json=tcpSlowStartRetrans,proto3" json:"tcp_slow_start_retrans,omitempty"`
	TcpTimeouts               uint64 `protobuf:"varint,439,opt,name=tcp_timeouts,json=tcpTimeouts,proto3" json:"tcp_timeouts,omitempty"`
	TcpLossProbes             uint64 `protobuf:"varint,440,opt,name=tcp_loss_probes,json=tcpLossProbes,proto3" json:"tcp_loss_probes,omitempty"`
	TcpLossProbeRecovery      uint64 `protobuf:"varint,441,opt,name=tcp_loss_probe_recovery,json=tcpLossProbeRecovery,proto3" json:"tcp_loss_probe_recovery,omitempty"`
	TcpRenoRecoveryFail       uint64 `protobuf:"varint,442,opt,name=tcp_reno_recovery_fail,json=tcpRenoRecoveryFail,proto3" json:"tcp_reno_recovery_fail,omitempty"`
	TcpSackRecoveryFail       uint64 `protobuf:"varint,443,opt,name=tcp_sack_recovery_fail,json=tcpSackRecoveryFail,proto3" json:"tcp_sack_recovery_fail,omitempty"`
	TcpRcvCollapsed           uint64 `protobuf:"varint,444,opt,name=tcp_rcv_collapsed,json=tcpRcvCollapsed,proto3" json:"tcp_rcv_collapsed,omitempty"`
	TcpBacklogCoalesce        uint64 `protobuf:"varint,445,opt,name=tcp_backlog_coalesce,json=tcpBacklogCoalesce,proto3" json:"tcp_backlog_coalesce,omitempty"`
	TcpDsackOldSent           uint64 `protobuf:"varint,446,opt,name=tcp_dsack_old_sent,json=tcpDsackOldSent,proto3" json:"tcp_dsack_old_sent,omitempty"`
	TcpDsackOfoSent           uint64 `protobuf:"varint,447,opt,name=tcp_dsack_ofo_sent,json=tcpDsackOfoSent,proto3" json:"tcp_dsack_ofo_sent,omitempty"`
	TcpDsackRecv              uint64 `protobuf:"varint,448,opt,name=tcp_dsack_recv,json=tcpDsackRecv,proto3" json:"tcp_dsack_recv,omitempty"`
	TcpDsackOfoRecv           uint64 `protobuf:"varint,449,opt,name=tcp_dsack_ofo_recv,json=tcpDsackOfoRecv,proto3" json:"tcp_dsack_ofo_recv,omitempty"`
	TcpAbortOnData            uint64 `protobuf:"varint,450,opt,name=tcp_abort_on_data,json=tcpAbortOnData,proto3" json:"tcp_abort_on_data,omitempty"`
	TcpAbortOnClose           uint64 `protobuf:"varint,451,opt,name=tcp_abort_on_close,json=tcpAbortOnClose,proto3" json:"tcp_abort_on_close,omitempty"`
	TcpAbortOnMemory          uint64 `protobuf:"varint,452,opt,name=tcp_abort_on_memory,json=tcpAbortOnMemory,proto3" json:"tcp_abort_on_memory,omitempty"`
	TcpAbortOnTimeout         uint64 `protobuf:"varint,453,opt,name=tcp_abort_on_timeout,json=tcpAbortOnTimeout,proto3" json:"tcp_abort_on_timeout,omitempty"`
	TcpAbortOnLinger          uint64 `protobuf:"varint,454,opt,name=tcp_abort_on_linger,json=tcpAbortOnLinger,proto3" json:"tcp_abort_on_linger,omitempty"`
	TcpAbortFailed            uint64 `protobuf:"varint,455,opt,name=tcp_abort_failed,json=tcpAbortFailed,proto3" json:"tcp_abort_failed,omitempty"`
	TcpMemoryPressures        uint64 `protobuf:"varint,456,opt,name=tcp_memory_pressures,json=tcpMemoryPressures,proto3" json:"tcp_memory_pressures,omitempty"`
	TcpMemoryPressuresChrono  uint64 `protobuf:"varint,457,opt,name=tcp_memory_pressures_chrono,json=tcpMemoryPressuresChrono,proto3" json:"tcp_memory_pressures_chrono,omitempty"`
	TcpSackDiscard            uint64 `protobuf:"varint,458,opt,name=tcp_sack_discard,json=tcpSackDiscard,proto3" json:"tcp_sack_discard,omitempty"`
	TcpDsackIgnoredOld        uint64 `protobuf:"varint,459,opt,name=tcp_dsack_ignored_old,json=tcpDsackIgnoredOld,proto3" json:"tcp_dsack_ignored_old,omitempty"`
	TcpDsackIgnoredNoUndo     uint64 `protobuf:"varint,460,opt,name=tcp_dsack_ignored_no_undo,json=tcpDsackIgnoredNoUndo,proto3" json:"tcp_dsack_ignored_no_undo,omitempty"`
	TcpSpuriousRtos           uint64 `protobuf:"varint,461,opt,name=tcp_spurious_rtos,json=tcpSpuriousRtos,proto3" json:"tcp_spurious_rtos,omitempty"`
	TcpMd5NotFound            uint64 `protobuf:"varint,462,opt,name=tcp_md5_not_found,json=tcpMd5NotFound,proto3" json:"tcp_md5_not_found,omitempty"`
	TcpMd5Unexpected          uint64 `protobuf:"varint,463,opt,name=tcp_md5_unexpected,json=tcpMd5Unexpected,proto3" json:"tcp_md5_unexpected,omitempty"`
	TcpMd5Failure             uint64 `protobuf:"varint,464,opt,name=tcp_md5_failure,json=tcpMd5Failure,proto3" json:"tcp_md5_failure,omitempty"`
	TcpSackShifted            uint64 `protobuf:"varint,465,opt,name=tcp_sack_shifted,json=tcpSackShifted,proto3" json:"tcp_sack_shifted,omitempty"`
	TcpSackMerged             uint64 `protobuf:"varint,466,opt,name=tcp_sack_merged,json=tcpSackMerged,proto3" json:"tcp_sack_merged,omitempty"`
	TcpSackShiftFallback      uint64 `protobuf:"varint,467,opt,name=tcp_sack_shift_fallback,json=tcpSackShiftFallback,proto3" json:"tcp_sack_shift_fallback,omitempty"`
	TcpBacklogDrop            uint64 `protobuf:"varint,468,opt,name=tcp_backlog_drop,json=tcpBacklogDrop,proto3" json:"tcp_backlog_drop,omitempty"`
	TcpPfMemallocDrop         uint64 `protobuf:"varint,469,opt,name=tcp_pf_memalloc_drop,json=tcpPfMemallocDrop,proto3" json:"tcp_pf_memalloc_drop,omitempty"`
	TcpMinTtlDrop             uint64 `protobuf:"varint,470,opt,name=tcp_min_ttl_drop,json=tcpMinTtlDrop,proto3" json:"tcp_min_ttl_drop,omitempty"`
	TcpDeferAcceptDrop        uint64 `protobuf:"varint,471,opt,name=tcp_defer_accept_drop,json=tcpDeferAcceptDrop,proto3" json:"tcp_defer_accept_drop,omitempty"`
	TcpIpReversePathFilter    uint64 `protobuf:"varint,472,opt,name=tcp_ip_reverse_path_filter,json=tcpIpReversePathFilter,proto3" json:"tcp_ip_reverse_path_filter,omitempty"`
	TcpTimeWaitOverflow       uint64 `protobuf:"varint,473,opt,name=tcp_time_wait_overflow,json=tcpTimeWaitOverflow,proto3" json:"tcp_time_wait_overflow,omitempty"`
	TcpReqQFullDoCookies      uint64 `protobuf:"varint,474,opt,name=tcp_req_q_full_do_cookies,json=tcpReqQFullDoCookies,proto3" json:"tcp_req_q_full_do_cookies,omitempty"`
	TcpReqQFullDrop           uint64 `protobuf:"varint,475,opt,name=tcp_req_q_full_drop,json=tcpReqQFullDrop,proto3" json:"tcp_req_q_full_drop,omitempty"`
	TcpRetransFail            uint64 `protobuf:"varint,476,opt,name=tcp_retrans_fail,json=tcpRetransFail,proto3" json:"tcp_retrans_fail,omitempty"`
	TcpRcvCoalesce            uint64 `protobuf:"varint,477,opt,name=tcp_rcv_coalesce,json=tcpRcvCoalesce,proto3" json:"tcp_rcv_coalesce,omitempty"`
	TcpOfoQueue               uint64 `protobuf:"varint,478,opt,name=tcp_ofo_queue,json=tcpOfoQueue,proto3" json:"tcp_ofo_queue,omitempty"`
	TcpOfoDrop                uint64 `protobuf:"varint,479,opt,name=tcp_ofo_drop,json=tcpOfoDrop,proto3" json:"tcp_ofo_drop,omitempty"`
	TcpOfoMerge               uint64 `protobuf:"varint,480,opt,name=tcp_ofo_merge,json=tcpOfoMerge,proto3" json:"tcp_ofo_merge,omitempty"`
	TcpChallengeAck           uint64 `protobuf:"varint,481,opt,name=tcp_challenge_ack,json=tcpChallengeAck,proto3" json:"tcp_challenge_ack,omitempty"`
	TcpSynChallenge           uint64 `protobuf:"varint,482,opt,name=tcp_syn_challenge,json=tcpSynChallenge,proto3" json:"tcp_syn_challenge,omitempty"`
	TcpFastOpenActive         uint64 `protobuf:"varint,483,opt,name=tcp_fast_open_active,json=tcpFastOpenActive,proto3" json:"tcp_fast_open_active,omitempty"`
	TcpFastOpenActiveFail     uint64 `protobuf:"varint,484,opt,name=tcp_fast_open_active_fail,json=tcpFastOpenActiveFail,proto3" json:"tcp_fast_open_active_fail,omitempty"`
	TcpFastOpenPassive        uint64 `protobuf:"varint,485,opt,name=tcp_fast_open_passive,json=tcpFastOpenPassive,proto3" json:"tcp_fast_open_passive,omitempty"`
	TcpFastOpenPassiveFail    uint64 `protobuf:"varint,486,opt,name=tcp_fast_open_passive_fail,json=tcpFastOpenPassiveFail,proto3" json:"tcp_fast_open_passive_fail,omitempty"`
	TcpFastOpenListenOverflow uint64 `protobuf:"varint,487,opt,name=tcp_fast_open_listen_overflow,json=tcpFastOpenListenOverflow,proto3" json:"tcp_fast_open_listen_overflow,omitempty"`
	TcpFastOpenCookieReqd     uint64 `protobuf:"varint,488,opt,name=tcp_fast_open_cookie_reqd,json=tcpFastOpenCookieReqd,proto3" json:"tcp_fast_open_cookie_reqd,omitempty"`
	TcpFastOpenBlackhole      uint64 `protobuf:"varint,489,opt,name=tcp_fast_open_blackhole,json=tcpFastOpenBlackhole,proto3" json:"tcp_fast_open_blackhole,omitempty"`
	TcpSpuriousRtxHostQueues  uint64 `protobuf:"varint,490,opt,name=tcp_spurious_rtx_host_queues,json=tcpSpuriousRtxHostQueues,proto3" json:"tcp_spurious_rtx_host_queues,omitempty"`
	TcpBusyPollRxPackets      uint64 `protobuf:"varint,491,opt,name=tcp_busy_poll_rx_packets,json=tcpBusyPollRxPackets,proto3" json:"tcp_busy_poll_rx_packets,omitempty"`
	TcpAutoCorking            uint64 `protobuf:"varint,492,opt,name=tcp_auto_corking,json=tcpAutoCorking,proto3" json:"tcp_auto_corking,omitempty"`
	TcpFromZeroWindowAdv      uint64 `protobuf:"varint,493,opt,name=tcp_from_zero_window_adv,json=tcpFromZeroWindowAdv,proto3" json:"tcp_from_zero_window_adv,omitempty"`
	TcpToZeroWindowAdv        uint64 `protobuf:"varint,494,opt,name=tcp_to_zero_window_adv,json=tcpToZeroWindowAdv,proto3" json:"tcp_to_zero_window_adv,omitempty"`
	TcpWantZeroWindowAdv      uint64 `protobuf:"varint,495,opt,name=tcp_want_zero_window_adv,json=tcpWantZeroWindowAdv,proto3" json:"tcp_want_zero_window_adv,omitempty"`
	TcpSynRetrans             uint64 `protobuf:"varint,496,opt,name=tcp_syn_retrans,json=tcpSynRetrans,proto3" json:"tcp_syn_retrans,omitempty"`
	TcpOrigDataSent           uint64 `protobuf:"varint,497,opt,name=tcp_orig_data_sent,json=tcpOrigDataSent,proto3" json:"tcp_orig_data_sent,omitempty"`
	TcpHystartTrainDetect     uint64 `protobuf:"varint,498,opt,name=tcp_hystart_train_detect,json=tcpHystartTrainDetect,proto3" json:"tcp_hystart_train_detect,omitempty"`
	TcpHystartTrainCwnd       uint64 `protobuf:"varint,499,opt,name=tcp_hystart_train_cwnd,json=tcpHystartTrainCwnd,proto3" json:"tcp_hystart_train_cwnd,omitempty"`
	TcpHystartDelayDetect     uint64 `protobuf:"varint,500,opt,name=tcp_hystart_delay_detect,json=tcpHystartDelayDetect,proto3" json:"tcp_hystart_delay_detect,omitempty"`
	TcpHystartDelayCwnd       uint64 `protobuf:"varint,501,opt,name=tcp_hystart_delay_cwnd,json=tcpHystartDelayCwnd,proto3" json:"tcp_hystart_delay_cwnd,omitempty"`
	TcpAckSkippedSynRecv      uint64 `protobuf:"varint,502,opt,name=tcp_ack_skipped_syn_recv,json=tcpAckSkippedSynRecv,proto3" json:"tcp_ack_skipped_syn_recv,omitempty"`
	TcpAckSkippedPaws         uint64 `protobuf:"varint,503,opt,name=tcp_ack_skipped_paws,json=tcpAckSkippedPaws,proto3" json:"tcp_ack_skipped_paws,omitempty"`
	TcpAckSkippedSeq          uint64 `protobuf:"varint,504,opt,name=tcp_ack_skipped_seq,json=tcpAckSkippedSeq,proto3" json:"tcp_ack_skipped_seq,omitempty"`
	TcpAckSkippedFinWait2     uint64 `protobuf:"varint,505,opt,name=tcp_ack_skipped_fin_wait2,json=tcpAckSkippedFinWait2,proto3" json:"tcp_ack_skipped_fin_wait2,omitempty"`
	TcpAckSkippedTimeWait     uint64 `protobuf:"varint,506,opt,name=tcp_ack_skipped_time_wait,json=tcpAckSkippedTimeWait,proto3" json:"tcp_ack_skipped_time_wait,omitempty"`
	TcpAckSkippedChallenge    uint64 `protobuf:"varint,507,opt,name=tcp_ack_skipped_challenge,json=tcpAckSkippedChallenge,proto3" json:"tcp_ack_skipped_challenge,omitempty"`
	TcpWinProbe               uint64 `protobuf:"varint,508,opt,name=tcp_win_probe,json=tcpWinProbe,proto3" json:"tcp_win_probe,omitempty"`
	TcpKeepAlive              uint64 `protobuf:"varint,509,opt,name=tcp_keep_alive,json=tcpKeepAlive,proto3" json:"tcp_keep_alive,omitempty"`
	TcpMtupFail               uint64 `protobuf:"varint,510,opt,name=tcp_mtup_fail,json=tcpMtupFail,proto3" json:"tcp_mtup_fail,omitempty"`
	TcpMtupSuccess            uint64 `protobuf:"varint,511,opt,name=tcp_mtup_success,json=tcpMtupSuccess,proto3" json:"tcp_mtup_success,omitempty"`
	TcpDelivered              uint64 `protobuf:"varint,512,opt,name=tcp_delivered,json=tcpDelivered,proto3" json:"tcp_delivered,omitempty"`
	TcpDeliveredCe            uint64 `protobuf:"varint,513,opt,name=tcp_delivered_ce,json=tcpDeliveredCe,proto3" json:"tcp_delivered_ce,omitempty"`
	TcpAckCompressed          uint64 `protobuf:"varint,514,opt,name=tcp_ack_compressed,json=tcpAckCompressed,proto3" json:"tcp_ack_compressed,omitempty"`
	TcpZeroWindowDrop         uint64 `protobuf:"varint,515,opt,name=tcp_zero_window_drop,json=tcpZeroWindowDrop,proto3" json:"tcp_zero_window_drop,omitempty"`
	TcpRcvQDrop               uint64 `protobuf:"varint,516,opt,name=tcp_rcv_q_drop,json=tcpRcvQDrop,proto3" json:"tcp_rcv_q_drop,omitempty"`
	TcpWqueueTooBig           uint64 `protobuf:"varint,517,opt,name=tcp_wqueue_too_big,json=tcpWqueueTooBig,proto3" json:"tcp_wqueue_too_big,omitempty"`
	TcpFastOpenPassiveAltKey  uint64 `protobuf:"varint,518,opt,name=tcp_fast_open_passive_alt_key,json=tcpFastOpenPassiveAltKey,proto3" json:"tcp_fast_open_passive_alt_key,omitempty"`
	TcpTimeoutRehash          uint64 `protobuf:"varint,519,opt,name=tcp_timeout_rehash,json=tcpTimeoutRehash,proto3" json:"tcp_timeout_rehash,omitempty"`
	TcpDuplicateDataRehash    uint64 `protobuf:"varint,520,opt,name=tcp_duplicate_data_rehash,json=tcpDuplicateDataRehash,proto3" json:"tcp_duplicate_data_rehash,omitempty"`
	TcpDsackRecvSegs          uint64 `protobuf:"varint,521,opt,name=tcp_dsack_recv_segs,json=tcpDsackRecvSegs,proto3" json:"tcp_dsack_recv_segs,omitempty"`
	TcpDsackIgnoredDubious    uint64 `protobuf:"varint,522,opt,name=tcp_dsack_ignored_dubious,json=tcpDsackIgnoredDubious,proto3" json:"tcp_dsack_ignored_dubious,omitempty"`
	TcpMigrateReqSuccess      uint64 `protobuf:"varint,523,opt,name=tcp_migrate_req_success,json=tcpMigrateReqSuccess,proto3" json:"tcp_migrate_req_success,omitempty"`
	TcpMigrateReqFailure      uint64 `protobuf:"varint,524,opt,name=tcp_migrate_req_failure,json=tcpMigrateReqFailure,proto3" json:"tcp_migrate_req_failure,omitempty"`
	TcpPlbRehash              uint64 `protobuf:"varint,525,opt,name=tcp_plb_rehash,json=tcpPlbRehash,proto3" json:"tcp_plb_rehash,omitempty"`
	// icmp /proc/net/snmp
	IcmpInMsgs             uint64 `protobuf:"varint,700,opt,name=icmp_in_msgs,json=icmpInMsgs,proto3" json:"icmp_in_msgs,omitempty"`
	IcmpInErrors           uint64 `protobuf:"varint,701,opt,name=icmp_in_errors,json=icmpInErrors,proto3" json:"icmp_in_errors,omitempty"`
	IcmpInCsumErrors       uint64 `protobuf:"varint,702,opt,name=icmp_in_csum_errors,json=icmpInCsumErrors,proto3" json:"icmp_in_csum_errors,omitempty"`
	IcmpInDestUnreachs     uint64 `protobuf:"varint,703,opt,name=icmp_in_dest_unreachs,json=icmpInDestUnreachs,proto3" json:"icmp_in_dest_unreachs,omitempty"`
	IcmpInTimeExcds        uint64 `protobuf:"varint,704,opt,name=icmp_in_time_excds,json=icmpInTimeExcds,proto3" json:"icmp_in_time_excds,omitempty"`
	IcmpInParmProbs        uint64 `protobuf:"varint,705,opt,name=icmp_in_parm_probs,json=icmpInParmProbs,proto3" json:"icmp_in_parm_probs,omitempty"`
	IcmpInSrcQuenchs       uint64 `protobuf:"varint,706,opt,name=icmp_in_src_quenchs,json=icmpInSrcQuenchs,proto3" json:"icmp_in_src_quenchs,omitempty"`
	IcmpInRedirects        uint64 `protobuf:"varint,707,opt,name=icmp_in_redirects,json=icmpInRedirects,proto3" json:"icmp_in_redirects,omitempty"`
	IcmpInEchos            uint64 `protobuf:"varint,708,opt,name=icmp_in_echos,json=icmpInEchos,proto3" json:"icmp_in_echos,omitempty"`
	IcmpInEchoReps         uint64 `protobuf:"varint,709,opt,name=icmp_in_echo_reps,json=icmpInEchoReps,proto3" json:"icmp_in_echo_reps,omitempty"`
	IcmpInTimestamps       uint64 `protobuf:"varint,710,opt,name=icmp_in_timestamps,json=icmpInTimestamps,proto3" json:"icmp_in_timestamps,omitempty"`
	IcmpInTimestampReps    uint64 `protobuf:"varint,711,opt,name=icmp_in_timestamp_reps,json=icmpInTimestampReps,proto3" json:"icmp_in_timestamp_reps,omitempty"`
	IcmpInAddrMasks        uint64 `protobuf:"varint,712,opt,name=icmp_in_addr_masks,json=icmpInAddrMasks,proto3" json:"icmp_in_addr_masks,omitempty"`
	IcmpInAddrMaskReps     uint64 `protobuf:"varint,713,opt,name=icmp_in_addr_mask_reps,json=icmpInAddrMaskReps,proto3" json:"icmp_in_addr_mask_reps,omitempty"`
	IcmpOutMsgs            uint64 `protobuf:"varint,714,opt,name=icmp_out_msgs,json=icmpOutMsgs,proto3" json:"icmp_out_msgs,omitempty"`
	IcmpOutErrors          uint64 `protobuf:"varint,715,opt,name=icmp_out_errors,json=icmpOutErrors,proto3" json:"icmp_out_errors,omitempty"`
	IcmpOutRateLimitGlobal uint64 `protobuf:"varint,716,opt,name=icmp_out_rate_limit_global,json=icmpOutRateLimitGlobal,proto3" json:"icmp_out_rate_limit_global,omitempty"`
	IcmpOutRateLimitHost   uint64 `protobuf:"varint,717,opt,name=icmp_out_rate_limit_host,json=icmpOutRateLimitHost,proto3" json:"icmp_out_rate_limit_host,omitempty"`
	IcmpOutDestUnreachs    uint64 `protobuf:"varint,718,opt,name=icmp_out_dest_unreachs,json=icmpOutDestUnreachs,proto3" json:"icmp_out_dest_unreachs,omitempty"`
	IcmpOutTimeExcds       uint64 `protobuf:"varint,719,opt,name=icmp_out_time_excds,json=icmpOutTimeExcds,proto3" json:"icmp_out_time_excds,omitempty"`
	IcmpOutParmProbs       uint64 `protobuf:"varint,720,opt,name=icmp_out_parm_probs,json=icmpOutParmProbs,proto3" json:"icmp_out_parm_probs,omitempty"`
	IcmpOutSrcQuenchs      uint64 `protobuf:"varint,721,opt,name=icmp_out_src_quenchs,json=icmpOutSrcQuenchs,proto3" json:"icmp_out_src_quenchs,omitempty"`
	IcmpOutRedirects       uint64 `protobuf:"varint,722,opt,name=icmp_out_redirects,json=icmpOutRedirects,proto3" json:"icmp_out_redirects,omitempty"`
	IcmpOutEchos           uint64 `protobuf:"varint,723,opt,name=icmp_out_echos,json=icmpOutEchos,proto3" json:"icmp_out_echos,omitempty"`
	IcmpOutEchoReps        uint64 `protobuf:"varint,724,opt,name=icmp_out_echo_reps,json=icmpOutEchoReps,proto3" json:"icmp_out_echo_reps,omitempty"`
	IcmpOutTimestamps      uint64 `protobuf:"varint,725,opt,name=icmp_out_timestamps,json=icmpOutTimestamps,proto3" json:"icmp_out_timestamps,omitempty"`
	IcmpOutTimestampReps   uint64 `protobuf:"varint,726,opt,name=icmp_out_timestamp_reps,json=icmpOutTimestampReps,proto3" json:"icmp_out_timestamp_reps,omitempty"`
	IcmpOutAddrMasks       uint64 `protobuf:"varint,727,opt,name=icmp_out_addr_masks,json=icmpOutAddrMasks,proto3" json:"icmp_out_addr_masks,omitempty"`
	IcmpOutAddrMaskReps    uint64 `protobuf:"varint,728,opt,name=icmp_out_addr_mask_reps,json=icmpOutAddrMaskReps,proto3" json:"icmp_out_addr_mask_reps,omitempty"`
}

func (m *NetstatMetric) Reset()         { *m = NetstatMetric{} }
func (m *NetstatMetric) String() string { return proto.CompactTextString(m) }
func (*NetstatMetric) ProtoMessage()    {}
func (*NetstatMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_59f30c3258032903, []int{8}
}
func (m *NetstatMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetstatMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetstatMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetstatMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetstatMetric.Merge(m, src)
}
func (m *NetstatMetric) XXX_Size() int {
	return m.Size()
}
func (m *NetstatMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_NetstatMetric.DiscardUnknown(m)
}

var xxx_messageInfo_NetstatMetric proto.InternalMessageInfo

func (m *NetstatMetric) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *NetstatMetric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_TCP
}

func (m *NetstatMetric) GetIpForwarding() uint64 {
	if m != nil {
		return m.IpForwarding
	}
	return 0
}

func (m *NetstatMetric) GetIpDefaultTtl() uint64 {
	if m != nil {
		return m.IpDefaultTtl
	}
	return 0
}

func (m *NetstatMetric) GetIpInReceives() uint64 {
	if m != nil {
		return m.IpInReceives
	}
	return 0
}

func (m *NetstatMetric) GetIpInHdrErrors() uint64 {
	if m != nil {
		return m.IpInHdrErrors
	}
	return 0
}

func (m *NetstatMetric) GetIpInAddrErrors() uint64 {
	if m != nil {
		return m.IpInAddrErrors
	}
	return 0
}

func (m *NetstatMetric) GetIpForwDatagrams() uint64 {
	if m != nil {
		return m.IpForwDatagrams
	}
	return 0
}

func (m *NetstatMetric) GetIpInUnknownProtos() uint64 {
	if m != nil {
		return m.IpInUnknownProtos
	}
	return 0
}

func (m *NetstatMetric) GetIpInDiscards() uint64 {
	if m != nil {
		return m.IpInDiscards
	}
	return 0
}

func (m *NetstatMetric) GetIpInDelivers() uint64 {
	if m != nil {
		return m.IpInDelivers
	}
	return 0
}

func (m *NetstatMetric) GetIpOutRequests() uint64 {
	if m != nil {
		return m.IpOutRequests
	}
	return 0
}

func (m *NetstatMetric) GetIpOutDiscards() uint64 {
	if m != nil {
		return m.IpOutDiscards
	}
	return 0
}

func (m *NetstatMetric) GetIpOutNoRoutes() uint64 {
	if m != nil {
		return m.IpOutNoRoutes
	}
	return 0
}

func (m *NetstatMetric) GetIpReasmTimeout() uint64 {
	if m != nil {
		return m.IpReasmTimeout
	}
	return 0
}

func (m *NetstatMetric) GetIpReasmReqds() uint64 {
	if m != nil {
		return m.IpReasmReqds
	}
	return 0
}

func (m *NetstatMetric) GetIpReasmOks() uint64 {
	if m != nil {
		return m.IpReasmOks
	}
	return 0
}

func (m *NetstatMetric) GetIpReasmFails() uint64 {
	if m != nil {
		return m.IpReasmFails
	}
	return 0
}

func (m *NetstatMetric) GetIpFragOks() uint64 {
	if m != nil {
		return m.IpFragOks
	}
	return 0
}

func (m *NetstatMetric) GetIpFragFails() uint64 {
	if m != nil {
		return m.IpFragFails
	}
	return 0
}

func (m *NetstatMetric) GetIpFragCreates() uint64 {
	if m != nil {
		return m.IpFragCreates
	}
	return 0
}

func (m *NetstatMetric) GetIpInNoRoutes() uint64 {
	if m != nil {
		return m.IpInNoRoutes
	}
	return 0
}

func (m *NetstatMetric) GetIpInTruncatedPkts() uint64 {
	if m != nil {
		return m.IpInTruncatedPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpInMcastPkts() uint64 {
	if m != nil {
		return m.IpInMcastPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpOutMcastPkts() uint64 {
	if m != nil {
		return m.IpOutMcastPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpInBcastPkts() uint64 {
	if m != nil {
		return m.IpInBcastPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpOutBcastPkts() uint64 {
	if m != nil {
		return m.IpOutBcastPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpInOctets() uint64 {
	if m != nil {
		return m.IpInOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpOutOctets() uint64 {
	if m != nil {
		return m.IpOutOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpInMcastOctets() uint64 {
	if m != nil {
		return m.IpInMcastOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpOutMcastOctets() uint64 {
	if m != nil {
		return m.IpOutMcastOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpInBcastOctets() uint64 {
	if m != nil {
		return m.IpInBcastOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpOutBcastOctets() uint64 {
	if m != nil {
		return m.IpOutBcastOctets
	}
	return 0
}

func (m *NetstatMetric) GetIpInCsumErrors() uint64 {
	if m != nil {
		return m.IpInCsumErrors
	}
	return 0
}

func (m *NetstatMetric) GetIpInNoEctPkts() uint64 {
	if m != nil {
		return m.IpInNoEctPkts
	}
	return 0
}

func (m *NetstatMetric) GetIpInEct1Pkts() uint64 {
	if m != nil {
		return m.IpInEct1Pkts
	}
	return 0
}

func (m *NetstatMetric) GetIpInEct0Pkts() uint64 {
	if m != nil {
		return m.IpInEct0Pkts
	}
	return 0
}

func (m *NetstatMetric) GetIpInCePkts() uint64 {
	if m != nil {
		return m.IpInCePkts
	}
	return 0
}

func (m *NetstatMetric) GetIpReasmOverlaps() uint64 {
	if m != nil {
		return m.IpReasmOverlaps
	}
	return 0
}

func (m *NetstatMetric) GetUdpInDatagrams() uint64 {
	if m != nil {
		return m.UdpInDatagrams
	}
	return 0
}

func (m *NetstatMetric) GetUdpNoPorts() uint64 {
	if m != nil {
		return m.UdpNoPorts
	}
	return 0
}

func (m *NetstatMetric) GetUdpInErrors() uint64 {
	if m != nil {
		return m.UdpInErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpOutDatagrams() uint64 {
	if m != nil {
		return m.UdpOutDatagrams
	}
	return 0
}

func (m *NetstatMetric) GetUdpRcvbufErrors() uint64 {
	if m != nil {
		return m.UdpRcvbufErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpSndbufErrors() uint64 {
	if m != nil {
		return m.UdpSndbufErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpInCsumErrors() uint64 {
	if m != nil {
		return m.UdpInCsumErrors
	}
	return 0
}

func (m *NetstatMetric) GetUdpIgnoredMulti() uint64 {
	if m != nil {
		return m.UdpIgnoredMulti
	}
	return 0
}

func (m *NetstatMetric) GetUdpMemErrors() uint64 {
	if m != nil {
		return m.UdpMemErrors
	}
	return 0
}

func (m *NetstatMetric) GetTcpRtoAlgorithm() uint64 {
	if m != nil {
		return m.TcpRtoAlgorithm
	}
	return 0
}

func (m *NetstatMetric) GetTcpRtoMin() uint64 {
	if m != nil {
		return m.TcpRtoMin
	}
	return 0
}

func (m *NetstatMetric) GetTcpRtoMax() uint64 {
	if m != nil {
		return m.TcpRtoMax
	}
	return 0
}

func (m *NetstatMetric) GetTcpMaxConn() int64 {
	if m != nil {
		return m.TcpMaxConn
	}
	return 0
}

func (m *NetstatMetric) GetTcpActiveOpens() uint64 {
	if m != nil {
		return m.TcpActiveOpens
	}
	return 0
}

func (m *NetstatMetric) GetTcpPassiveOpens() uint64 {
	if m != nil {
		return m.TcpPassiveOpens
	}
	return 0
}

func (m *NetstatMetric) GetTcpAttemptFails() uint64 {
	if m != nil {
		return m.TcpAttemptFails
	}
	return 0
}

func (m *NetstatMetric) GetTcpEstabResets() uint64 {
	if m != nil {
		return m.TcpEstabResets
	}
	return 0
}

func (m *NetstatMetric) GetTcpCurrEstab() uint64 {
	if m != nil {
		return m.TcpCurrEstab
	}
	return 0
}

func (m *NetstatMetric) GetTcpInSegs() uint64 {
	if m != nil {
		return m.TcpInSegs
	}
	return 0
}

func (m *NetstatMetric) GetTcpOutSegs() uint64 {
	if m != nil {
		return m.TcpOutSegs
	}
	return 0
}

func (m *NetstatMetric) GetTcpRetransSegs() uint64 {
	if m != nil {
		return m.TcpRetransSegs
	}
	return 0
}

func (m *NetstatMetric) GetTcpInErrs() uint64 {
	if m != nil {
		return m.TcpInErrs
	}
	return 0
}

func (m *NetstatMetric) GetTcpOutRsts() uint64 {
	if m != nil {
		return m.TcpOutRsts
	}
	return 0
}

func (m *NetstatMetric) GetTcpInCsumErrors() uint64 {
	if m != nil {
		return m.TcpInCsumErrors
	}
	return 0
}

func (m *NetstatMetric) GetTcpSyncookiesSent() uint64 {
	if m != nil {
		return m.TcpSyncookiesSent
	}
	return 0
}

func (m *NetstatMetric) GetTcpSyncookiesRecv() uint64 {
	if m != nil {
		return m.TcpSyncookiesRecv
	}
	return 0
}

func (m *NetstatMetric) GetTcpSyncookiesFailed() uint64 {
	if m != nil {
		return m.TcpSyncookiesFailed
	}
	return 0
}

func (m *NetstatMetric) GetTcpEmbryonicRsts() uint64 {
	if m != nil {
		return m.TcpEmbryonicRsts
	}
	return 0
}

func (m *NetstatMetric) GetTcpPruneCalled() uint64 {
	if m != nil {
		return m.TcpPruneCalled
	}
	return 0
}

func (m *NetstatMetric) GetTcpRcvPruned() uint64 {
	if m != nil {
		return m.TcpRcvPruned
	}
	return 0
}

func (m *NetstatMetric) GetTcpOfoPruned() uint64 {
	if m != nil {
		return m.TcpOfoPruned
	}
	return 0
}

func (m *NetstatMetric) GetTcpOutOfWindowIcmps() uint64 {
	if m != nil {
		return m.TcpOutOfWindowIcmps
	}
	return 0
}

func (m *NetstatMetric) GetTcpLockDroppedIcmps() uint64 {
	if m != nil {
		return m.TcpLockDroppedIcmps
	}
	return 0
}

func (m *NetstatMetric) GetTcpArpFilter() uint64 {
	if m != nil {
		return m.TcpArpFilter
	}
	return 0
}

func (m *NetstatMetric) GetTcpTw() uint64 {
	if m != nil {
		return m.TcpTw
	}
	return 0
}

func (m *NetstatMetric) GetTcpTwRecycled() uint64 {
	if m != nil {
		return m.TcpTwRecycled
	}
	return 0
}

func (m *NetstatMetric) GetTcpTwKilled() uint64 {
	if m != nil {
		return m.TcpTwKilled
	}
	return 0
}

func (m *NetstatMetric) GetTcpPawsActive() uint64 {
	if m != nil {
		return m.TcpPawsActive
	}
	return 0
}

func (m *NetstatMetric) GetTcpPawsEstab() uint64 {
	if m != nil {
		return m.TcpPawsEstab
	}
	return 0
}

func (m *NetstatMetric) GetTcpDelayedAcks() uint64 {
	if m != nil {
		return m.TcpDelayedAcks
	}
	return 0
}

func (m *NetstatMetric) GetTcpDelayedAckLocked() uint64 {
	if m != nil {
		return m.TcpDelayedAckLocked
	}
	return 0
}

func (m *NetstatMetric) GetTcpDelayedAckLost() uint64 {
	if m != nil {
		return m.TcpDelayedAckLost
	}
	return 0
}

func (m *NetstatMetric) GetTcpListenOverflows() uint64 {
	if m != nil {
		return m.TcpListenOverflows
	}
	return 0
}

func (m *NetstatMetric) GetTcpListenDrops() uint64 {
	if m != nil {
		return m.TcpListenDrops
	}
	return 0
}

func (m *NetstatMetric) GetTcpHpHits() uint64 {
	if m != nil {
		return m.TcpHpHits
	}
	return 0
}

func (m *NetstatMetric) GetTcpPureAcks() uint64 {
	if m != nil {
		return m.TcpPureAcks
	}
	return 0
}

func (m *NetstatMetric) GetTcpHpAcks() uint64 {
	if m != nil {
		return m.TcpHpAcks
	}
	return 0
}

func (m *NetstatMetric) GetTcpRenoRecovery() uint64 {
	if m != nil {
		return m.TcpRenoRecovery
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackRecovery() uint64 {
	if m != nil {
		return m.TcpSackRecovery
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackReneging() uint64 {
	if m != nil {
		return m.TcpSackReneging
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackReorder() uint64 {
	if m != nil {
		return m.TcpSackReorder
	}
	return 0
}

func (m *NetstatMetric) GetTcpRenoReorder() uint64 {
	if m != nil {
		return m.TcpRenoReorder
	}
	return 0
}

func (m *NetstatMetric) GetTcpTsReorder() uint64 {
	if m != nil {
		return m.TcpTsReorder
	}
	return 0
}

func (m *NetstatMetric) GetTcpFullUndo() uint64 {
	if m != nil {
		return m.TcpFullUndo
	}
	return 0
}

func (m *NetstatMetric) GetTcpPartialUndo() uint64 {
	if m != nil {
		return m.TcpPartialUndo
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackUndo() uint64 {
	if m != nil {
		return m.TcpDsackUndo
	}
	return 0
}

func (m *NetstatMetric) GetTcpLossUndo() uint64 {
	if m != nil {
		return m.TcpLossUndo
	}
	return 0
}

func (m *NetstatMetric) GetTcpLostRetransmit() uint64 {
	if m != nil {
		return m.TcpLostRetransmit
	}
	return 0
}

func (m *NetstatMetric) GetTcpRenoFailures() uint64 {
	if m != nil {
		return m.TcpRenoFailures
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackFailures() uint64 {
	if m != nil {
		return m.TcpSackFailures
	}
	return 0
}

func (m *NetstatMetric) GetTcpLossFailures() uint64 {
	if m != nil {
		return m.TcpLossFailures
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastRetrans() uint64 {
	if m != nil {
		return m.TcpFastRetrans
	}
	return 0
}

func (m *NetstatMetric) GetTcpSlowStartRetrans() uint64 {
	if m != nil {
		return m.TcpSlowStartRetrans
	}
	return 0
}

func (m *NetstatMetric) GetTcpTimeouts() uint64 {
	if m != nil {
		return m.TcpTimeouts
	}
	return 0
}

func (m *NetstatMetric) GetTcpLossProbes() uint64 {
	if m != nil {
		return m.TcpLossProbes
	}
	return 0
}

func (m *NetstatMetric) GetTcpLossProbeRecovery() uint64 {
	if m != nil {
		return m.TcpLossProbeRecovery
	}
	return 0
}

func (m *NetstatMetric) GetTcpRenoRecoveryFail() uint64 {
	if m != nil {
		return m.TcpRenoRecoveryFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackRecoveryFail() uint64 {
	if m != nil {
		return m.TcpSackRecoveryFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpRcvCollapsed() uint64 {
	if m != nil {
		return m.TcpRcvCollapsed
	}
	return 0
}

func (m *NetstatMetric) GetTcpBacklogCoalesce() uint64 {
	if m != nil {
		return m.TcpBacklogCoalesce
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackOldSent() uint64 {
	if m != nil {
		return m.TcpDsackOldSent
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackOfoSent() uint64 {
	if m != nil {
		return m.TcpDsackOfoSent
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackRecv() uint64 {
	if m != nil {
		return m.TcpDsackRecv
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackOfoRecv() uint64 {
	if m != nil {
		return m.TcpDsackOfoRecv
	}
	return 0
}

func (m *NetstatMetric) GetTcpAbortOnData() uint64 {
	if m != nil {
		return m.TcpAbortOnData
	}
	return 0
}

func (m *NetstatMetric) GetTcpAbortOnClose() uint64 {
	if m != nil {
		return m.TcpAbortOnClose
	}
	return 0
}

func (m *NetstatMetric) GetTcpAbortOnMemory() uint64 {
	if m != nil {
		return m.TcpAbortOnMemory
	}
	return 0
}

func (m *NetstatMetric) GetTcpAbortOnTimeout() uint64 {
	if m != nil {
		return m.TcpAbortOnTimeout
	}
	return 0
}

func (m *NetstatMetric) GetTcpAbortOnLinger() uint64 {
	if m != nil {
		return m.TcpAbortOnLinger
	}
	return 0
}

func (m *NetstatMetric) GetTcpAbortFailed() uint64 {
	if m != nil {
		return m.TcpAbortFailed
	}
	return 0
}

func (m *NetstatMetric) GetTcpMemoryPressures() uint64 {
	if m != nil {
		return m.TcpMemoryPressures
	}
	return 0
}

func (m *NetstatMetric) GetTcpMemoryPressuresChrono() uint64 {
	if m != nil {
		return m.TcpMemoryPressuresChrono
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackDiscard() uint64 {
	if m != nil {
		return m.TcpSackDiscard
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackIgnoredOld() uint64 {
	if m != nil {
		return m.TcpDsackIgnoredOld
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackIgnoredNoUndo() uint64 {
	if m != nil {
		return m.TcpDsackIgnoredNoUndo
	}
	return 0
}

func (m *NetstatMetric) GetTcpSpuriousRtos() uint64 {
	if m != nil {
		return m.TcpSpuriousRtos
	}
	return 0
}

func (m *NetstatMetric) GetTcpMd5NotFound() uint64 {
	if m != nil {
		return m.TcpMd5NotFound
	}
	return 0
}

func (m *NetstatMetric) GetTcpMd5Unexpected() uint64 {
	if m != nil {
		return m.TcpMd5Unexpected
	}
	return 0
}

func (m *NetstatMetric) GetTcpMd5Failure() uint64 {
	if m != nil {
		return m.TcpMd5Failure
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackShifted() uint64 {
	if m != nil {
		return m.TcpSackShifted
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackMerged() uint64 {
	if m != nil {
		return m.TcpSackMerged
	}
	return 0
}

func (m *NetstatMetric) GetTcpSackShiftFallback() uint64 {
	if m != nil {
		return m.TcpSackShiftFallback
	}
	return 0
}

func (m *NetstatMetric) GetTcpBacklogDrop() uint64 {
	if m != nil {
		return m.TcpBacklogDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpPfMemallocDrop() uint64 {
	if m != nil {
		return m.TcpPfMemallocDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpMinTtlDrop() uint64 {
	if m != nil {
		return m.TcpMinTtlDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpDeferAcceptDrop() uint64 {
	if m != nil {
		return m.TcpDeferAcceptDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpIpReversePathFilter() uint64 {
	if m != nil {
		return m.TcpIpReversePathFilter
	}
	return 0
}

func (m *NetstatMetric) GetTcpTimeWaitOverflow() uint64 {
	if m != nil {
		return m.TcpTimeWaitOverflow
	}
	return 0
}

func (m *NetstatMetric) GetTcpReqQFullDoCookies() uint64 {
	if m != nil {
		return m.TcpReqQFullDoCookies
	}
	return 0
}

func (m *NetstatMetric) GetTcpReqQFullDrop() uint64 {
	if m != nil {
		return m.TcpReqQFullDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpRetransFail() uint64 {
	if m != nil {
		return m.TcpRetransFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpRcvCoalesce() uint64 {
	if m != nil {
		return m.TcpRcvCoalesce
	}
	return 0
}

func (m *NetstatMetric) GetTcpOfoQueue() uint64 {
	if m != nil {
		return m.TcpOfoQueue
	}
	return 0
}

func (m *NetstatMetric) GetTcpOfoDrop() uint64 {
	if m != nil {
		return m.TcpOfoDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpOfoMerge() uint64 {
	if m != nil {
		return m.TcpOfoMerge
	}
	return 0
}

func (m *NetstatMetric) GetTcpChallengeAck() uint64 {
	if m != nil {
		return m.TcpChallengeAck
	}
	return 0
}

func (m *NetstatMetric) GetTcpSynChallenge() uint64 {
	if m != nil {
		return m.TcpSynChallenge
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenActive() uint64 {
	if m != nil {
		return m.TcpFastOpenActive
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenActiveFail() uint64 {
	if m != nil {
		return m.TcpFastOpenActiveFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenPassive() uint64 {
	if m != nil {
		return m.TcpFastOpenPassive
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenPassiveFail() uint64 {
	if m != nil {
		return m.TcpFastOpenPassiveFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenListenOverflow() uint64 {
	if m != nil {
		return m.TcpFastOpenListenOverflow
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenCookieReqd() uint64 {
	if m != nil {
		return m.TcpFastOpenCookieReqd
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenBlackhole() uint64 {
	if m != nil {
		return m.TcpFastOpenBlackhole
	}
	return 0
}

func (m *NetstatMetric) GetTcpSpuriousRtxHostQueues() uint64 {
	if m != nil {
		return m.TcpSpuriousRtxHostQueues
	}
	return 0
}

func (m *NetstatMetric) GetTcpBusyPollRxPackets() uint64 {
	if m != nil {
		return m.TcpBusyPollRxPackets
	}
	return 0
}

func (m *NetstatMetric) GetTcpAutoCorking() uint64 {
	if m != nil {
		return m.TcpAutoCorking
	}
	return 0
}

func (m *NetstatMetric) GetTcpFromZeroWindowAdv() uint64 {
	if m != nil {
		return m.TcpFromZeroWindowAdv
	}
	return 0
}

func (m *NetstatMetric) GetTcpToZeroWindowAdv() uint64 {
	if m != nil {
		return m.TcpToZeroWindowAdv
	}
	return 0
}

func (m *NetstatMetric) GetTcpWantZeroWindowAdv() uint64 {
	if m != nil {
		return m.TcpWantZeroWindowAdv
	}
	return 0
}

func (m *NetstatMetric) GetTcpSynRetrans() uint64 {
	if m != nil {
		return m.TcpSynRetrans
	}
	return 0
}

func (m *NetstatMetric) GetTcpOrigDataSent() uint64 {
	if m != nil {
		return m.TcpOrigDataSent
	}
	return 0
}

func (m *NetstatMetric) GetTcpHystartTrainDetect() uint64 {
	if m != nil {
		return m.TcpHystartTrainDetect
	}
	return 0
}

func (m *NetstatMetric) GetTcpHystartTrainCwnd() uint64 {
	if m != nil {
		return m.TcpHystartTrainCwnd
	}
	return 0
}

func (m *NetstatMetric) GetTcpHystartDelayDetect() uint64 {
	if m != nil {
		return m.TcpHystartDelayDetect
	}
	return 0
}

func (m *NetstatMetric) GetTcpHystartDelayCwnd() uint64 {
	if m != nil {
		return m.TcpHystartDelayCwnd
	}
	return 0
}

func (m *NetstatMetric) GetTcpAckSkippedSynRecv() uint64 {
	if m != nil {
		return m.TcpAckSkippedSynRecv
	}
	return 0
}

func (m *NetstatMetric) GetTcpAckSkippedPaws() uint64 {
	if m != nil {
		return m.TcpAckSkippedPaws
	}
	return 0
}

func (m *NetstatMetric) GetTcpAckSkippedSeq() uint64 {
	if m != nil {
		return m.TcpAckSkippedSeq
	}
	return 0
}

func (m *NetstatMetric) GetTcpAckSkippedFinWait2() uint64 {
	if m != nil {
		return m.TcpAckSkippedFinWait2
	}
	return 0
}

func (m *NetstatMetric) GetTcpAckSkippedTimeWait() uint64 {
	if m != nil {
		return m.TcpAckSkippedTimeWait
	}
	return 0
}

func (m *NetstatMetric) GetTcpAckSkippedChallenge() uint64 {
	if m != nil {
		return m.TcpAckSkippedChallenge
	}
	return 0
}

func (m *NetstatMetric) GetTcpWinProbe() uint64 {
	if m != nil {
		return m.TcpWinProbe
	}
	return 0
}

func (m *NetstatMetric) GetTcpKeepAlive() uint64 {
	if m != nil {
		return m.TcpKeepAlive
	}
	return 0
}

func (m *NetstatMetric) GetTcpMtupFail() uint64 {
	if m != nil {
		return m.TcpMtupFail
	}
	return 0
}

func (m *NetstatMetric) GetTcpMtupSuccess() uint64 {
	if m != nil {
		return m.TcpMtupSuccess
	}
	return 0
}

func (m *NetstatMetric) GetTcpDelivered() uint64 {
	if m != nil {
		return m.TcpDelivered
	}
	return 0
}

func (m *NetstatMetric) GetTcpDeliveredCe() uint64 {
	if m != nil {
		return m.TcpDeliveredCe
	}
	return 0
}

func (m *NetstatMetric) GetTcpAckCompressed() uint64 {
	if m != nil {
		return m.TcpAckCompressed
	}
	return 0
}

func (m *NetstatMetric) GetTcpZeroWindowDrop() uint64 {
	if m != nil {
		return m.TcpZeroWindowDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpRcvQDrop() uint64 {
	if m != nil {
		return m.TcpRcvQDrop
	}
	return 0
}

func (m *NetstatMetric) GetTcpWqueueTooBig() uint64 {
	if m != nil {
		return m.TcpWqueueTooBig
	}
	return 0
}

func (m *NetstatMetric) GetTcpFastOpenPassiveAltKey() uint64 {
	if m != nil {
		return m.TcpFastOpenPassiveAltKey
	}
	return 0
}

func (m *NetstatMetric) GetTcpTimeoutRehash() uint64 {
	if m != nil {
		return m.TcpTimeoutRehash
	}
	return 0
}

func (m *NetstatMetric) GetTcpDuplicateDataRehash() uint64 {
	if m != nil {
		return m.TcpDuplicateDataRehash
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackRecvSegs() uint64 {
	if m != nil {
		return m.TcpDsackRecvSegs
	}
	return 0
}

func (m *NetstatMetric) GetTcpDsackIgnoredDubious() uint64 {
	if m != nil {
		return m.TcpDsackIgnoredDubious
	}
	return 0
}

func (m *NetstatMetric) GetTcpMigrateReqSuccess() uint64 {
	if m != nil {
		return m.TcpMigrateReqSuccess
	}
	return 0
}

func (m *NetstatMetric) GetTcpMigrateReqFailure() uint64 {
	if m != nil {
		return m.TcpMigrateReqFailure
	}
	return 0
}

func (m *NetstatMetric) GetTcpPlbRehash() uint64 {
	if m != nil {
		return m.TcpPlbRehash
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInMsgs() uint64 {
	if m != nil {
		return m.IcmpInMsgs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInErrors() uint64 {
	if m != nil {
		return m.IcmpInErrors
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInCsumErrors() uint64 {
	if m != nil {
		return m.IcmpInCsumErrors
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInDestUnreachs() uint64 {
	if m != nil {
		return m.IcmpInDestUnreachs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInTimeExcds() uint64 {
	if m != nil {
		return m.IcmpInTimeExcds
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInParmProbs() uint64 {
	if m != nil {
		return m.IcmpInParmProbs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInSrcQuenchs() uint64 {
	if m != nil {
		return m.IcmpInSrcQuenchs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInRedirects() uint64 {
	if m != nil {
		return m.IcmpInRedirects
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInEchos() uint64 {
	if m != nil {
		return m.IcmpInEchos
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInEchoReps() uint64 {
	if m != nil {
		return m.IcmpInEchoReps
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInTimestamps() uint64 {
	if m != nil {
		return m.IcmpInTimestamps
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInTimestampReps() uint64 {
	if m != nil {
		return m.IcmpInTimestampReps
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInAddrMasks() uint64 {
	if m != nil {
		return m.IcmpInAddrMasks
	}
	return 0
}

func (m *NetstatMetric) GetIcmpInAddrMaskReps() uint64 {
	if m != nil {
		return m.IcmpInAddrMaskReps
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutMsgs() uint64 {
	if m != nil {
		return m.IcmpOutMsgs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutErrors() uint64 {
	if m != nil {
		return m.IcmpOutErrors
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutRateLimitGlobal() uint64 {
	if m != nil {
		return m.IcmpOutRateLimitGlobal
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutRateLimitHost() uint64 {
	if m != nil {
		return m.IcmpOutRateLimitHost
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutDestUnreachs() uint64 {
	if m != nil {
		return m.IcmpOutDestUnreachs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutTimeExcds() uint64 {
	if m != nil {
		return m.IcmpOutTimeExcds
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutParmProbs() uint64 {
	if m != nil {
		return m.IcmpOutParmProbs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutSrcQuenchs() uint64 {
	if m != nil {
		return m.IcmpOutSrcQuenchs
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutRedirects() uint64 {
	if m != nil {
		return m.IcmpOutRedirects
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutEchos() uint64 {
	if m != nil {
		return m.IcmpOutEchos
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutEchoReps() uint64 {
	if m != nil {
		return m.IcmpOutEchoReps
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutTimestamps() uint64 {
	if m != nil {
		return m.IcmpOutTimestamps
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutTimestampReps() uint64 {
	if m != nil {
		return m.IcmpOutTimestampReps
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutAddrMasks() uint64 {
	if m != nil {
		return m.IcmpOutAddrMasks
	}
	return 0
}

func (m *NetstatMetric) GetIcmpOutAddrMaskReps() uint64 {
	if m != nil {
		return m.IcmpOutAddrMaskReps
	}
	return 0
}

func init() {
	proto.RegisterEnum("MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("SocketState", SocketState_name, SocketState_value)
	proto.RegisterType((*Metric)(nil), "Metric")
	proto.RegisterType((*SocketMemoryUsage)(nil), "SocketMemoryUsage")
	proto.RegisterType((*TimerInfo)(nil), "TimerInfo")
	proto.RegisterType((*ProcessInfo)(nil), "ProcessInfo")
	proto.RegisterType((*SocketMetric)(nil), "SocketMetric")
	proto.RegisterType((*TcpMetric)(nil), "TcpMetric")
	proto.RegisterType((*IfaceMetric)(nil), "IfaceMetric")
	proto.RegisterType((*NicMetric)(nil), "NicMetric")
	proto.RegisterType((*NetstatMetric)(nil), "NetstatMetric")
}

func init() { proto.RegisterFile("tcpmon.proto", fileDescriptor_59f30c3258032903) }

var fileDescriptor_59f30c3258032903 = []byte{
	// 5068 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x5a, 0x67, 0x74, 0x24, 0xc7,
	0x71, 0x26, 0x0e, 0x0b, 0xdc, 0xa1, 0x11, 0x0e, 0x9c, 0x3b, 0x92, 0x4d, 0x85, 0x13, 0x09, 0x51,
	0xe2, 0xe9, 0x44, 0x81, 0xe4, 0x51, 0x27, 0xcb, 0xd2, 0x7b, 0xb6, 0x71, 0x0b, 0x40, 0x87, 0xc7,
	0x43, 0xe0, 0x00, 0xe7, 0x7b, 0xf6, 0x9f, 0x79, 0x83, 0x9e, 0xde, 0xc5, 0x78, 0x67, 0xa7, 0x07,
	0xdd, 0x3d, 0xbb, 0x80, 0x7f, 0x39, 0x67, 0xbf, 0x27, 0xcb, 0x39, 0xe7, 0xac, 0x9c, 0x25, 0x2b,
	0x47, 0x2a, 0x53, 0x99, 0xca, 0x14, 0xa9, 0x68, 0x59, 0xce, 0x39, 0xbf, 0xaa, 0xee, 0x9e, 0x9e,
	0x59, 0x40, 0xbf, 0xf4, 0x6f, 0xe7, 0xab, 0xaf, 0xaa, 0xba, 0xab, 0xab, 0xab, 0xab, 0x67, 0x96,
	0xcc, 0x68, 0x56, 0xf4, 0x45, 0xbe, 0x58, 0x48, 0xa1, 0xc5, 0x82, 0x26, 0x93, 0xeb, 0x5c, 0xcb,
	0x94, 0x05, 0xe7, 0xc8, 0xb8, 0x66, 0x05, 0x1d, 0xbb, 0x6d, 0xec, 0xfc, 0xf4, 0x45, 0xb2, 0xb8,
	0xc3, 0x0a, 0x23, 0xb8, 0x72, 0x43, 0x08, 0x02, 0x90, 0xe7, 0x29, 0xa3, 0x27, 0xac, 0x7c, 0x23,
	0x65, 0x5e, 0x9e, 0xa7, 0x2c, 0x58, 0x20, 0xe3, 0x39, 0xd7, 0x74, 0x1c, 0xe5, 0x73, 0x8b, 0x1b,
	0x5c, 0x2b, 0x1d, 0xeb, 0x1a, 0x87, 0xeb, 0xcb, 0x93, 0xa4, 0xb5, 0x2b, 0x92, 0xc3, 0x85, 0x17,
	0x9c, 0x20, 0x37, 0x6e, 0x0b, 0xd6, 0xe3, 0x7a, 0x9d, 0xf7, 0x85, 0x3c, 0xbc, 0xa6, 0xe2, 0x2e,
	0x0f, 0x9e, 0x48, 0x88, 0xec, 0xf3, 0x7e, 0x14, 0x67, 0x99, 0x60, 0x38, 0x90, 0xd9, 0x70, 0x0a,
	0x90, 0x25, 0x00, 0x82, 0x5b, 0xc8, 0x49, 0xc9, 0x06, 0xd1, 0x6e, 0xd9, 0xc1, 0x41, 0xcc, 0x86,
	0x93, 0x92, 0x0d, 0x2e, 0x97, 0x1d, 0xd0, 0x1b, 0x7a, 0xbd, 0x71, 0xa3, 0x37, 0xac, 0xeb, 0xa9,
	0x3c, 0x41, 0xbd, 0x96, 0xd1, 0x53, 0x79, 0x02, 0x7a, 0x8f, 0x27, 0x53, 0x9d, 0x61, 0x62, 0xd5,
	0x26, 0x50, 0x74, 0xaa, 0x33, 0x4c, 0x8c, 0xd6, 0x93, 0xc8, 0x34, 0x1a, 0xdd, 0x2f, 0x79, 0xc9,
	0x13, 0x3a, 0x89, 0x62, 0xf4, 0xf3, 0x00, 0x22, 0x60, 0x56, 0x14, 0x3a, 0xea, 0xf3, 0x3e, 0x3d,
	0x69, 0xcc, 0x8a, 0x02, 0xa6, 0x13, 0xdc, 0x4a, 0x4e, 0xed, 0xc6, 0xac, 0x17, 0x65, 0xa2, 0x4b,
	0x4f, 0xa1, 0xe4, 0x24, 0x3c, 0x5f, 0x15, 0x5d, 0xf0, 0xa8, 0x04, 0xeb, 0x45, 0x89, 0x14, 0x05,
	0x9d, 0x32, 0x1e, 0x01, 0x58, 0x96, 0xa2, 0x58, 0x88, 0xc8, 0xd4, 0x4e, 0xda, 0xe7, 0x72, 0x2d,
	0xef, 0x88, 0x20, 0x20, 0xad, 0x3c, 0xee, 0x73, 0x8c, 0xc2, 0x54, 0x88, 0xbf, 0x83, 0x3b, 0xc8,
	0x1c, 0x3f, 0x28, 0x52, 0xc9, 0x23, 0x9d, 0xf6, 0x79, 0x54, 0x2a, 0x8c, 0x43, 0x2b, 0x9c, 0x31,
	0x28, 0x28, 0x5f, 0x53, 0x01, 0x25, 0x27, 0x25, 0xd7, 0x32, 0xce, 0x95, 0x0d, 0x85, 0x7b, 0x5c,
	0x68, 0x93, 0xe9, 0x2d, 0x29, 0x18, 0x57, 0xea, 0x5b, 0xba, 0x98, 0x27, 0xe3, 0x45, 0x9a, 0xd8,
	0xf8, 0xc2, 0xcf, 0x60, 0x8e, 0x9c, 0xe8, 0x24, 0xd6, 0xd2, 0x89, 0x4e, 0xb2, 0xf0, 0x4d, 0x42,
	0x66, 0xdc, 0xd2, 0x61, 0xde, 0x2c, 0x90, 0x09, 0x58, 0x68, 0x8e, 0x9c, 0xb9, 0x8b, 0x33, 0x8b,
	0x46, 0xba, 0x0d, 0x58, 0x68, 0x44, 0xc1, 0x4d, 0x64, 0x52, 0x72, 0x36, 0x88, 0xf6, 0xed, 0x0a,
	0x4c, 0xc0, 0xd3, 0x03, 0x00, 0x2b, 0x9e, 0x27, 0xd1, 0x3e, 0x46, 0x7f, 0x3c, 0x9c, 0x80, 0xa7,
	0x07, 0x60, 0x3d, 0x33, 0xc1, 0xe2, 0x2c, 0x8a, 0x93, 0x44, 0x62, 0xe4, 0xa7, 0xc2, 0x29, 0x44,
	0x96, 0x92, 0x44, 0x42, 0x10, 0x0b, 0xce, 0xa5, 0x91, 0x9e, 0x44, 0xe9, 0x29, 0x00, 0x50, 0x78,
	0x81, 0x4c, 0x15, 0x66, 0x8e, 0x5c, 0xd1, 0x53, 0xb7, 0x8d, 0x9f, 0x9f, 0xbe, 0x38, 0xb3, 0x58,
	0x9b, 0x75, 0xe8, 0xc5, 0xc1, 0x02, 0x99, 0x84, 0x40, 0x4a, 0x45, 0xa7, 0x90, 0x48, 0x16, 0xab,
	0xf8, 0x87, 0x56, 0x12, 0x9c, 0x27, 0x13, 0xaa, 0x07, 0x6b, 0x4c, 0x30, 0xaf, 0x83, 0xc5, 0x23,
	0x69, 0x1b, 0x1a, 0x02, 0x04, 0x4a, 0x2b, 0x3a, 0x7d, 0xdb, 0xd8, 0xf9, 0x53, 0xe1, 0x09, 0xad,
	0x20, 0xbc, 0x2a, 0x66, 0x3d, 0x3a, 0x83, 0x08, 0xfe, 0x0e, 0xce, 0x92, 0x09, 0x56, 0xee, 0xa6,
	0x8c, 0xce, 0x22, 0x68, 0x1e, 0x20, 0xd5, 0xe2, 0xa2, 0x88, 0xb2, 0xb4, 0x9f, 0x6a, 0x9e, 0xd0,
	0x39, 0x94, 0x91, 0xb8, 0x28, 0xae, 0x1a, 0x04, 0x08, 0x45, 0xcc, 0xd2, 0xbc, 0x1b, 0x49, 0x08,
	0xf4, 0xe9, 0xdb, 0xc6, 0xce, 0x8f, 0x85, 0xc4, 0x40, 0x21, 0xc4, 0xf7, 0xc9, 0x64, 0x36, 0xe1,
	0x59, 0x3a, 0xe0, 0xf2, 0xd0, 0x50, 0xe6, 0x91, 0x32, 0xe3, 0x40, 0x24, 0xc1, 0x80, 0x78, 0x9e,
	0xd0, 0x1b, 0x51, 0x86, 0xbf, 0x21, 0xd4, 0xb0, 0x37, 0x86, 0x8a, 0xc5, 0x19, 0xa7, 0x81, 0xd9,
	0x3a, 0x2a, 0x4f, 0xae, 0x23, 0x80, 0x3b, 0x92, 0x0d, 0x9c, 0xf8, 0x8c, 0xdd, 0x91, 0x6c, 0x60,
	0xc5, 0xf3, 0x64, 0x5c, 0x6a, 0x41, 0xcf, 0xa2, 0x41, 0xf8, 0x69, 0x10, 0x4d, 0x6f, 0x72, 0x88,
	0x0e, 0x6e, 0x26, 0x93, 0x52, 0xeb, 0x41, 0x2c, 0xe9, 0xcd, 0x08, 0xda, 0x27, 0xc0, 0xfb, 0x69,
	0x0e, 0xe4, 0x5b, 0x0c, 0x6e, 0x9e, 0xdc, 0x2e, 0x07, 0x01, 0xb5, 0x0a, 0x6c, 0x10, 0x6a, 0x0d,
	0x41, 0xb0, 0x89, 0x1c, 0xe5, 0x62, 0x48, 0x6f, 0x35, 0x1b, 0xd2, 0x42, 0x1b, 0x62, 0x08, 0x41,
	0x70, 0x04, 0x2d, 0x74, 0x9c, 0xd1, 0xc7, 0x21, 0x65, 0xc6, 0x82, 0x3b, 0x80, 0xc1, 0x00, 0x63,
	0x2d, 0xe8, 0x39, 0x33, 0xc0, 0xd8, 0x0c, 0xb9, 0xaf, 0x14, 0x7d, 0x92, 0x49, 0xf9, 0xbe, 0xc2,
	0x95, 0x2b, 0xfa, 0xba, 0xa4, 0xb7, 0x21, 0x84, 0xbf, 0x71, 0x1a, 0x6c, 0x00, 0xc4, 0xdb, 0xab,
	0xda, 0x03, 0xdc, 0x9b, 0xc9, 0x64, 0x9c, 0x20, 0xbe, 0x60, 0x70, 0xf3, 0x04, 0x36, 0xd8, 0x30,
	0x4f, 0xe8, 0x93, 0x8d, 0x0d, 0xf8, 0xed, 0x0a, 0x11, 0xc0, 0x77, 0x54, 0x85, 0xe8, 0xba, 0x59,
	0x85, 0xdd, 0x43, 0xcd, 0x55, 0xa4, 0x78, 0xae, 0xe9, 0x53, 0x4c, 0x98, 0x11, 0xd9, 0xe6, 0x39,
	0xce, 0xdc, 0x88, 0x63, 0xd6, 0xe3, 0x09, 0x7d, 0x2a, 0x6e, 0x7a, 0xa3, 0xb1, 0x04, 0x48, 0xf0,
	0x14, 0x32, 0x67, 0x08, 0x92, 0x33, 0x9e, 0x0e, 0x78, 0x42, 0xef, 0x44, 0xce, 0x2c, 0xa2, 0xa1,
	0x05, 0xa1, 0x30, 0x29, 0xde, 0x55, 0x91, 0x28, 0x35, 0x3d, 0x6f, 0x4a, 0x03, 0x3c, 0x6f, 0x96,
	0x18, 0x75, 0x14, 0xa5, 0x39, 0x7d, 0x9a, 0x1d, 0x1a, 0xef, 0xaa, 0xb5, 0x1c, 0xaa, 0x49, 0x16,
	0x2b, 0xad, 0xf2, 0x84, 0x5e, 0x30, 0x2a, 0xf6, 0xd1, 0x49, 0x24, 0x1b, 0xd0, 0xa7, 0x7b, 0x89,
	0x64, 0x03, 0x27, 0x81, 0xe4, 0xbf, 0xcb, 0x4b, 0x20, 0xff, 0x9f, 0x40, 0xa6, 0x6c, 0x4a, 0xf2,
	0x84, 0x3e, 0xc3, 0xcc, 0xb3, 0x02, 0x60, 0x10, 0xbb, 0xa5, 0x3a, 0x8c, 0xfa, 0x8a, 0x2e, 0x9a,
	0x41, 0xc0, 0xe3, 0xba, 0x82, 0x1d, 0x0f, 0x39, 0xa1, 0x8a, 0x98, 0x71, 0x7a, 0xb7, 0x29, 0x9b,
	0x92, 0x0d, 0xb6, 0xe1, 0x39, 0xb8, 0x9d, 0xcc, 0xa0, 0x50, 0xe9, 0x3d, 0xc9, 0xd5, 0x1e, 0xbd,
	0x07, 0xe5, 0xd3, 0x20, 0xb7, 0x50, 0xb0, 0x40, 0x66, 0x93, 0x58, 0xc7, 0x51, 0x35, 0xfb, 0x7b,
	0x0d, 0x07, 0xc0, 0x6d, 0x1b, 0x81, 0xdb, 0xc8, 0x8c, 0xe7, 0xa4, 0x39, 0xbd, 0x68, 0xf2, 0xcb,
	0x51, 0xd6, 0x72, 0x74, 0x34, 0xcc, 0x93, 0x6a, 0x9f, 0xde, 0x67, 0x1d, 0x0d, 0xf3, 0xc4, 0x6d,
	0xd4, 0xa7, 0x90, 0x39, 0x95, 0x27, 0xbb, 0x65, 0xa7, 0x22, 0x3d, 0x13, 0x49, 0xb3, 0x06, 0x75,
	0xb4, 0x79, 0x32, 0xce, 0x59, 0x4e, 0x2f, 0xe1, 0x46, 0x87, 0x9f, 0x10, 0x32, 0xce, 0x72, 0xc5,
	0x79, 0x4e, 0x9f, 0x85, 0xa8, 0x7b, 0x5c, 0x50, 0x64, 0xaa, 0x3a, 0x8a, 0x21, 0x7e, 0x50, 0x97,
	0x94, 0x8e, 0xfb, 0xe6, 0xa4, 0x1e, 0x0f, 0x3d, 0x10, 0x3c, 0x89, 0xb4, 0xf4, 0x61, 0xc1, 0xb1,
	0x7a, 0xcf, 0x5d, 0x9c, 0x5e, 0x34, 0x4a, 0x3b, 0x87, 0x05, 0x0f, 0x51, 0x10, 0xdc, 0x49, 0x4e,
	0x2a, 0x2c, 0x5f, 0x70, 0x34, 0x40, 0xc5, 0x9b, 0x5d, 0xac, 0x97, 0xf2, 0xd0, 0x49, 0x17, 0x5e,
	0x7f, 0x82, 0x4c, 0xaf, 0x75, 0x62, 0xc6, 0xad, 0xdf, 0xe3, 0x8e, 0x0a, 0x58, 0x94, 0x83, 0x88,
	0x4b, 0x29, 0xa4, 0x3b, 0x88, 0x4e, 0xc9, 0x83, 0x15, 0x7c, 0xc6, 0xc2, 0x71, 0x80, 0xc7, 0x5c,
	0xc1, 0xcd, 0xe9, 0xd1, 0x0a, 0xa7, 0xe4, 0xc1, 0xb2, 0x01, 0x70, 0x2f, 0x1f, 0x44, 0x62, 0xc0,
	0xa5, 0x2c, 0x73, 0x85, 0x87, 0x42, 0x2b, 0x24, 0xf2, 0x60, 0xd3, 0x22, 0x90, 0xaa, 0xf2, 0x20,
	0xea, 0x48, 0x70, 0x3a, 0x81, 0xd2, 0x93, 0xf2, 0x60, 0x55, 0x5a, 0xbf, 0xba, 0xf2, 0x3b, 0x69,
	0xfc, 0xea, 0x9a, 0x5f, 0xed, 0xfd, 0x9e, 0x34, 0x7e, 0x75, 0xdd, 0xaf, 0xae, 0xf9, 0x3d, 0x65,
	0xfc, 0x6a, 0xef, 0xd7, 0xe8, 0xb3, 0x58, 0xca, 0x94, 0x4b, 0x3c, 0xa1, 0x51, 0xbf, 0x6d, 0x00,
	0x28, 0x31, 0x20, 0x16, 0x59, 0x96, 0xaa, 0x54, 0xe4, 0x0a, 0x4f, 0x85, 0x56, 0x38, 0xa3, 0x0f,
	0xda, 0x15, 0xb6, 0x50, 0x90, 0xa9, 0xaa, 0x39, 0xfa, 0x76, 0x57, 0xec, 0x0e, 0x32, 0x99, 0xc2,
	0x3a, 0xb8, 0x05, 0x9b, 0x59, 0xac, 0x2d, 0x4b, 0x68, 0x65, 0x0b, 0x0f, 0xae, 0x93, 0xd9, 0x46,
	0xbf, 0xf5, 0xed, 0xba, 0x7d, 0x32, 0x99, 0x4d, 0x8b, 0xa8, 0x23, 0xe4, 0x30, 0x96, 0x49, 0x9a,
	0x77, 0x69, 0x62, 0xe6, 0x99, 0x16, 0xab, 0x15, 0x06, 0xed, 0x48, 0x5a, 0x44, 0x09, 0xef, 0xc4,
	0x65, 0xa6, 0x23, 0xad, 0x33, 0xca, 0x1d, 0x6b, 0xd9, 0x80, 0x3b, 0x3a, 0xb3, 0xac, 0x34, 0x77,
	0xb5, 0x49, 0xd1, 0x8e, 0x63, 0xad, 0xe5, 0xb6, 0x34, 0xa9, 0xe0, 0x4e, 0x32, 0x6f, 0x58, 0x7b,
	0x89, 0x74, 0x6b, 0xdb, 0x35, 0x35, 0x0c, 0x78, 0x57, 0x12, 0x69, 0x17, 0xf8, 0x69, 0xe4, 0x46,
	0x43, 0x84, 0xd3, 0xdf, 0x31, 0xf7, 0x90, 0x39, 0x07, 0x4c, 0x68, 0x02, 0x2c, 0xf5, 0x02, 0x52,
	0x61, 0x12, 0x11, 0xec, 0xe2, 0xae, 0x8c, 0xfb, 0x8a, 0xa6, 0x48, 0x3d, 0x6d, 0x26, 0xb2, 0xec,
	0xe0, 0xe0, 0x6e, 0x72, 0xd6, 0x98, 0x2d, 0xf3, 0x5e, 0x2e, 0x86, 0x79, 0x84, 0xdd, 0xb1, 0xa2,
	0x3f, 0x80, 0xf4, 0x1b, 0xc1, 0xf2, 0x35, 0x23, 0xd9, 0x42, 0x81, 0x9f, 0x56, 0x92, 0x2a, 0x16,
	0xcb, 0x44, 0xd1, 0x9e, 0x9f, 0xd6, 0xb2, 0xc5, 0x6a, 0x2c, 0x53, 0xe4, 0x14, 0xcd, 0x6a, 0x2c,
	0x8b, 0x05, 0x4f, 0x25, 0xa7, 0xd3, 0x02, 0xea, 0x52, 0x24, 0xf9, 0x7e, 0xc9, 0x95, 0x56, 0xb4,
	0xef, 0xe6, 0xbe, 0x59, 0xea, 0xd0, 0x82, 0x35, 0x5e, 0xe5, 0x34, 0xaf, 0xf1, 0x2a, 0xaf, 0x26,
	0x98, 0xc0, 0xcb, 0x45, 0x24, 0x45, 0xa9, 0xb9, 0xa2, 0xa2, 0x46, 0xdc, 0x10, 0x21, 0x82, 0xc1,
	0x79, 0x24, 0x4a, 0x1e, 0xab, 0x3e, 0xb6, 0x94, 0x50, 0x1a, 0x0b, 0x17, 0xcb, 0x10, 0xe0, 0x1d,
	0x83, 0xda, 0x89, 0x18, 0xa6, 0xe4, 0xfb, 0x89, 0xa2, 0xfb, 0x6e, 0x22, 0xc8, 0x0b, 0x01, 0x83,
	0x1a, 0x5a, 0xb1, 0x44, 0x4f, 0x51, 0x69, 0xf6, 0x97, 0xe5, 0x6c, 0xf6, 0x54, 0xc3, 0x4e, 0x27,
	0x4e, 0x33, 0x45, 0x55, 0xc3, 0xce, 0x2a, 0x60, 0xc1, 0x39, 0x32, 0x0d, 0x2b, 0x27, 0xe3, 0x2e,
	0x9a, 0xd1, 0x66, 0x1b, 0xa6, 0xc5, 0xaa, 0x8c, 0xbb, 0x60, 0x65, 0xc1, 0xa4, 0x27, 0xc8, 0x8d,
	0x91, 0x12, 0x19, 0xd3, 0x86, 0x61, 0x6c, 0x98, 0x60, 0x21, 0x87, 0x49, 0x1e, 0x43, 0x0c, 0x06,
	0x2e, 0x06, 0xc0, 0x6a, 0x1b, 0xd0, 0xf2, 0xd2, 0xbc, 0x16, 0xab, 0x87, 0x5b, 0x7e, 0x91, 0xaa,
	0x58, 0xdd, 0xe3, 0x32, 0x44, 0xcb, 0x32, 0x67, 0xb1, 0xe6, 0x49, 0x54, 0xf4, 0xb4, 0xa2, 0x9f,
	0x6a, 0xf9, 0x14, 0xd9, 0x71, 0xa2, 0xad, 0x9e, 0x76, 0xd1, 0x4d, 0xf3, 0xa8, 0xcf, 0x62, 0xa5,
	0x0d, 0xfb, 0xd3, 0x2d, 0x9f, 0xd4, 0xeb, 0x00, 0x23, 0xd3, 0x64, 0x2a, 0x2c, 0x58, 0x8d, 0xfa,
	0x99, 0x96, 0x5b, 0x89, 0xcd, 0x52, 0x7b, 0x6e, 0x65, 0x75, 0xd7, 0x53, 0x3f, 0x5b, 0xb3, 0x7a,
	0xf9, 0x18, 0xab, 0x35, 0xea, 0xe7, 0xea, 0x56, 0x3d, 0xf7, 0x76, 0x5c, 0xb9, 0x34, 0x8f, 0x04,
	0xd3, 0x70, 0x3c, 0x7c, 0xbe, 0xe5, 0x96, 0x6e, 0x2d, 0xdf, 0x44, 0xc8, 0xd6, 0x04, 0x30, 0x67,
	0x39, 0x5f, 0x68, 0xb9, 0xa8, 0x6f, 0x96, 0xda, 0x92, 0xee, 0x22, 0x41, 0x7d, 0xce, 0x96, 0xf9,
	0x48, 0xcb, 0xed, 0x3a, 0x3b, 0x6b, 0xcb, 0x5e, 0x24, 0x67, 0x1a, 0xf3, 0xb6, 0xf4, 0x2f, 0x1a,
	0xfa, 0xbc, 0x9f, 0xf9, 0xa8, 0xf5, 0xdd, 0x3a, 0xfd, 0xd1, 0x9a, 0xf5, 0xcb, 0xc7, 0x5a, 0x6f,
	0xd0, 0x1f, 0xab, 0x5b, 0xaf, 0xf3, 0x2f, 0xb8, 0xd2, 0xc2, 0x54, 0xd9, 0x77, 0xa5, 0xe5, 0x4b,
	0x2d, 0x5f, 0x5b, 0xda, 0xaa, 0xec, 0x8f, 0x96, 0xa1, 0x5c, 0x44, 0x9c, 0xd9, 0xd8, 0x7e, 0xb9,
	0xb6, 0x0c, 0x1b, 0x62, 0x85, 0x99, 0xd0, 0x56, 0x09, 0xc6, 0x99, 0xbe, 0xd7, 0x10, 0xbf, 0x52,
	0x4b, 0xb0, 0x15, 0xa6, 0xef, 0x3d, 0xc2, 0xbb, 0xc7, 0xf0, 0xbe, 0xda, 0xe4, 0xdd, 0x83, 0x3c,
	0x93, 0xfc, 0x30, 0x4c, 0x6e, 0x58, 0x5f, 0xab, 0xad, 0x55, 0x9b, 0x23, 0xe7, 0xe9, 0x38, 0x3c,
	0xbb, 0x11, 0x07, 0x5c, 0x66, 0x71, 0xa1, 0xe8, 0xd7, 0xab, 0x38, 0x99, 0xed, 0x68, 0xf1, 0xe0,
	0x69, 0x64, 0xbe, 0x4c, 0x4c, 0x95, 0xaa, 0xca, 0xe4, 0x83, 0x63, 0x66, 0xda, 0x65, 0x02, 0x85,
	0xaa, 0x2a, 0x93, 0xb7, 0x93, 0x19, 0xa0, 0xe6, 0x22, 0x2a, 0x84, 0xd4, 0x8a, 0xbe, 0xc7, 0xd0,
	0x48, 0x99, 0x14, 0x1b, 0x62, 0x0b, 0x20, 0x48, 0x13, 0x6b, 0xcd, 0x46, 0xf0, 0xbd, 0x86, 0x33,
	0x8d, 0xa6, 0x6c, 0xf8, 0x9e, 0x4e, 0x6e, 0x04, 0x12, 0x96, 0xb2, 0xca, 0xe7, 0xfb, 0x0c, 0xf1,
	0x74, 0x99, 0x60, 0x35, 0xab, 0x9c, 0x5a, 0xb2, 0x64, 0x03, 0x68, 0xac, 0xac, 0xd5, 0xf7, 0x7b,
	0x72, 0x88, 0x82, 0xa6, 0x65, 0xdb, 0x85, 0x59, 0xf2, 0x07, 0x3c, 0x79, 0x1b, 0x05, 0x96, 0x7c,
	0x17, 0x09, 0xec, 0x58, 0xeb, 0x4b, 0xfe, 0x41, 0xcf, 0x6e, 0xac, 0xb9, 0x35, 0x9d, 0x76, 0x73,
	0x21, 0x79, 0x12, 0xf5, 0xcb, 0x4c, 0xa7, 0xf4, 0x43, 0x35, 0xb2, 0x11, 0xac, 0x03, 0x0e, 0x9d,
	0x20, 0x90, 0xfb, 0xbc, 0x32, 0xfb, 0x90, 0x61, 0x42, 0x00, 0xd7, 0x79, 0xcd, 0xa6, 0x66, 0x45,
	0x24, 0xb5, 0x88, 0xe2, 0xac, 0x2b, 0x64, 0xaa, 0xf7, 0xfa, 0xf4, 0x85, 0xa6, 0x9b, 0x3a, 0xad,
	0x59, 0x11, 0x6a, 0xb1, 0xe4, 0x70, 0xec, 0x5e, 0x2c, 0xb9, 0x9f, 0xe6, 0xf4, 0x45, 0x27, 0x6c,
	0x7b, 0x82, 0xb4, 0xf5, 0x34, 0x6f, 0x10, 0xe2, 0x03, 0xfa, 0xe2, 0x26, 0x21, 0x3e, 0x80, 0xf5,
	0x03, 0x42, 0x3f, 0x86, 0x26, 0x26, 0xcf, 0xe9, 0x4b, 0x4e, 0x60, 0x6b, 0x40, 0x34, 0x2b, 0xd6,
	0xe3, 0x83, 0xb6, 0xc8, 0x73, 0xc8, 0x06, 0xa0, 0xc4, 0x4c, 0xa7, 0x03, 0x1e, 0x89, 0x82, 0xe7,
	0x8a, 0xbe, 0xd4, 0x18, 0x9a, 0xd3, 0xac, 0x58, 0x42, 0x7c, 0x13, 0x60, 0x37, 0xf8, 0x22, 0x56,
	0xca, 0x73, 0x5f, 0xe6, 0x07, 0xbf, 0x65, 0x04, 0x0d, 0x72, 0xac, 0x35, 0xef, 0x17, 0xda, 0xd6,
	0xed, 0x97, 0x7b, 0xf2, 0x92, 0x11, 0x98, 0xe2, 0x6d, 0x07, 0x01, 0xed, 0xca, 0x6e, 0x24, 0xb9,
	0x82, 0x7d, 0xfb, 0x0a, 0x3f, 0x88, 0x15, 0xc0, 0x43, 0x84, 0x21, 0xd0, 0x40, 0x65, 0xa5, 0x94,
	0x86, 0x4f, 0x5f, 0x69, 0xdf, 0x8a, 0x68, 0x56, 0xb4, 0x4b, 0x29, 0x91, 0xec, 0x42, 0x93, 0xe6,
	0xd8, 0xe0, 0xd3, 0x57, 0xf9, 0xd0, 0xac, 0xe5, 0xd0, 0xdf, 0xbb, 0xd0, 0x40, 0x4a, 0x22, 0xe3,
	0xd5, 0x27, 0x6c, 0x73, 0xc8, 0x20, 0x1b, 0x91, 0x62, 0x47, 0xe5, 0x2e, 0x99, 0x48, 0x7b, 0x8d,
	0x1f, 0x55, 0x68, 0x70, 0xa4, 0x7a, 0x77, 0x5c, 0x4a, 0x45, 0x5f, 0x5b, 0x77, 0xb7, 0x22, 0x65,
	0xc3, 0x9d, 0x84, 0x03, 0xff, 0x75, 0x0d, 0x77, 0xa1, 0x32, 0xd5, 0xce, 0xda, 0xa8, 0x67, 0xe7,
	0xeb, 0x7d, 0xc8, 0x1a, 0xd9, 0x79, 0x37, 0x39, 0x03, 0x6c, 0x75, 0x98, 0x33, 0x21, 0x7a, 0xa9,
	0xbb, 0x4c, 0x3e, 0xdf, 0xf4, 0xde, 0x10, 0xfb, 0xed, 0x4a, 0x84, 0xb7, 0xca, 0xa3, 0x0a, 0x92,
	0xb3, 0x01, 0xfd, 0x85, 0xe3, 0x14, 0x42, 0xce, 0x06, 0xc1, 0x7d, 0xe4, 0xa6, 0x11, 0x05, 0x58,
	0x44, 0x9e, 0xd0, 0x17, 0x18, 0x95, 0x33, 0x0d, 0x95, 0x55, 0x94, 0x05, 0xcf, 0x30, 0x93, 0xe0,
	0xfd, 0x5d, 0x79, 0x28, 0xf2, 0x94, 0x99, 0xd9, 0xfe, 0xa2, 0xd1, 0x80, 0x70, 0xae, 0x38, 0x09,
	0xce, 0xd9, 0x86, 0xb8, 0x90, 0x65, 0xce, 0x23, 0x16, 0x67, 0x60, 0xfe, 0x97, 0xc6, 0xab, 0x10,
	0x6f, 0x01, 0xde, 0x46, 0xd8, 0x2d, 0x3c, 0xdc, 0xfd, 0x90, 0x9e, 0xd0, 0x5f, 0x1e, 0xaf, 0x16,
	0x3e, 0x64, 0x03, 0xe4, 0x56, 0x34, 0xd1, 0x11, 0x8e, 0xf6, 0x2b, 0x9e, 0xb6, 0xd9, 0x11, 0x96,
	0x76, 0x89, 0xdc, 0xe2, 0xd6, 0x43, 0x74, 0xa2, 0x61, 0x9a, 0x27, 0x62, 0x18, 0xa5, 0xac, 0x5f,
	0x28, 0xfa, 0xab, 0x7e, 0x7a, 0x70, 0xd0, 0x75, 0xae, 0xa3, 0x70, 0x0d, 0x64, 0xc1, 0x33, 0xc9,
	0xcd, 0xa0, 0x96, 0xb9, 0x97, 0x7a, 0x05, 0x4f, 0xac, 0xd6, 0xaf, 0x79, 0xad, 0xab, 0xf6, 0x0d,
	0x5f, 0xc1, 0x13, 0xa3, 0x65, 0xc7, 0x14, 0xcb, 0x22, 0xea, 0xa4, 0x99, 0xe6, 0x92, 0xfe, 0xba,
	0x1f, 0xd3, 0x92, 0x2c, 0x56, 0x11, 0x0c, 0x6e, 0x26, 0x93, 0x40, 0xd3, 0x43, 0xfa, 0x1b, 0x46,
	0x3c, 0xa1, 0x59, 0xb1, 0x33, 0x0c, 0xee, 0x24, 0xa7, 0x0d, 0x0e, 0x2b, 0x76, 0xc8, 0x20, 0x46,
	0xbf, 0x69, 0x08, 0xb3, 0x48, 0x08, 0x2d, 0x8a, 0xd7, 0x15, 0x43, 0xec, 0xa5, 0x18, 0xca, 0xdf,
	0x32, 0xb4, 0x69, 0xa4, 0xdd, 0x8f, 0x98, 0xb3, 0x56, 0xc4, 0x43, 0x65, 0x77, 0x3d, 0xfd, 0x6d,
	0x6f, 0x6d, 0x2b, 0x1e, 0x2a, 0xb3, 0xe7, 0xdd, 0xa8, 0x91, 0x68, 0x76, 0xda, 0xef, 0xf8, 0x51,
	0x03, 0xcf, 0xec, 0x34, 0xbb, 0x84, 0x09, 0xcf, 0xe2, 0x43, 0x9e, 0x44, 0x31, 0xeb, 0x29, 0xfa,
	0xbb, 0x7e, 0x09, 0x97, 0x0d, 0xbe, 0xc4, 0x7a, 0x55, 0xf4, 0x6a, 0x54, 0x8c, 0x24, 0x4f, 0xe8,
	0xef, 0xf9, 0xe8, 0x79, 0x85, 0xab, 0x28, 0x83, 0x4e, 0xec, 0xa8, 0x96, 0xd2, 0xf4, 0xf7, 0x7d,
	0xe6, 0xd6, 0x75, 0x94, 0x0e, 0xee, 0x35, 0x1a, 0x59, 0xaa, 0x34, 0xcf, 0xf1, 0x40, 0xec, 0x64,
	0x62, 0xa8, 0xe8, 0x1f, 0x18, 0x0d, 0xc8, 0xd0, 0xab, 0x28, 0xdb, 0x74, 0x22, 0x37, 0x0b, 0xab,
	0x02, 0x4b, 0xab, 0xe8, 0x1f, 0xfa, 0x59, 0x18, 0x3a, 0x2c, 0x6a, 0xb5, 0xd7, 0xf7, 0x8a, 0x68,
	0x2f, 0xd5, 0x8a, 0xfe, 0xd1, 0x78, 0xb5, 0xd7, 0xaf, 0x14, 0x57, 0x52, 0x73, 0x24, 0x62, 0xe0,
	0x4a, 0xc9, 0x4d, 0x38, 0xfe, 0xd8, 0x2f, 0xc3, 0x56, 0x29, 0x39, 0xc6, 0xc2, 0x5b, 0x41, 0xca,
	0x9f, 0xd4, 0xad, 0x20, 0xc1, 0x1d, 0x15, 0x1c, 0x1a, 0x55, 0xce, 0x60, 0x16, 0x87, 0xf4, 0x4f,
	0xc7, 0xfd, 0x51, 0xc1, 0x73, 0x11, 0x5a, 0xdc, 0x91, 0x15, 0x04, 0xa7, 0x22, 0xff, 0x99, 0x27,
	0x6f, 0xc7, 0xac, 0xf7, 0x2d, 0xc8, 0x39, 0xef, 0xc2, 0x8d, 0xef, 0xcf, 0x47, 0xc9, 0x06, 0x77,
	0x81, 0xb1, 0x64, 0x21, 0x13, 0x2e, 0xe9, 0x5f, 0xf8, 0xc0, 0x18, 0x2e, 0xc2, 0xbe, 0x5e, 0xe2,
	0x88, 0x0d, 0xf5, 0x2f, 0xc7, 0x6b, 0xf5, 0x12, 0x06, 0x6c, 0xa8, 0x36, 0xb7, 0xb4, 0xaa, 0x88,
	0x2f, 0xf4, 0xb9, 0xb5, 0xa3, 0x1c, 0xcd, 0x46, 0xb2, 0x53, 0x66, 0x59, 0x54, 0xe6, 0x89, 0xa0,
	0x2f, 0xf2, 0x91, 0x5c, 0x2d, 0xb3, 0xec, 0x5a, 0x9e, 0x88, 0xaa, 0x86, 0xc4, 0x52, 0xa7, 0xb1,
	0xe5, 0xbd, 0xb8, 0x56, 0x43, 0x0c, 0x8e, 0x54, 0xeb, 0x36, 0xc1, 0xd9, 0x20, 0xf1, 0x25, 0xde,
	0xed, 0x32, 0xa0, 0x48, 0xb3, 0x6e, 0x33, 0xa1, 0x94, 0x61, 0xbd, 0xd4, 0xbb, 0xbd, 0x2a, 0x94,
	0x42, 0x92, 0xad, 0xa7, 0x90, 0x8a, 0xee, 0x88, 0xe8, 0xa7, 0x9a, 0xbe, 0xcc, 0x67, 0x25, 0xe4,
	0x62, 0x58, 0x49, 0x1a, 0x0b, 0x0a, 0x95, 0xb4, 0x94, 0x5c, 0xd1, 0x97, 0x37, 0x17, 0x74, 0xd5,
	0xe2, 0x8d, 0x35, 0xaa, 0xc8, 0xaf, 0x68, 0xae, 0xd1, 0x28, 0x19, 0xc7, 0x5b, 0x91, 0x5f, 0xe9,
	0xc9, 0x30, 0xe6, 0x8a, 0x6c, 0xc3, 0xd5, 0x89, 0xfd, 0xb8, 0xe9, 0xab, 0x7c, 0xb8, 0x56, 0xe3,
	0x6a, 0xd0, 0x6e, 0xbf, 0xaa, 0x4c, 0x0c, 0x23, 0xa5, 0x63, 0xe9, 0x15, 0x5e, 0x5d, 0x3b, 0x02,
	0x32, 0x31, 0xdc, 0x06, 0xa1, 0xd3, 0x5a, 0x30, 0x47, 0x9d, 0xbd, 0x60, 0x2a, 0xfa, 0x9a, 0x5a,
	0x11, 0xb2, 0x98, 0x2b, 0x42, 0x38, 0xe2, 0x42, 0x8a, 0x5d, 0xae, 0xe8, 0x6b, 0x7d, 0x11, 0x82,
	0xf1, 0x6e, 0x21, 0x1a, 0x3c, 0xcb, 0xd4, 0x69, 0x4f, 0xf4, 0xe9, 0xfd, 0x3a, 0xa3, 0x70, 0xb6,
	0xae, 0x50, 0xe5, 0xb8, 0x1d, 0x7a, 0x63, 0xf7, 0x60, 0x6c, 0xe8, 0xeb, 0xfd, 0xd0, 0xeb, 0x5b,
	0x08, 0xe2, 0x53, 0x4d, 0xb8, 0xbe, 0x8d, 0x8c, 0xd6, 0x5f, 0xd5, 0x26, 0x5c, 0xdb, 0x4b, 0xa8,
	0xe5, 0x16, 0x96, 0x0d, 0xf0, 0x55, 0x51, 0x5c, 0x28, 0x9e, 0xd0, 0x37, 0xd4, 0x16, 0x96, 0x0d,
	0xda, 0x0e, 0x77, 0xb5, 0x69, 0x37, 0x66, 0xbd, 0x4c, 0x74, 0x23, 0x26, 0xe2, 0x8c, 0x2b, 0xc6,
	0xe9, 0x1b, 0x7d, 0x6d, 0xba, 0x6c, 0x64, 0x6d, 0x2b, 0x72, 0x8d, 0x81, 0xc9, 0x5a, 0x91, 0x25,
	0xe6, 0xa4, 0x7f, 0x93, 0x77, 0x80, 0x99, 0xbb, 0x99, 0x25, 0x78, 0xce, 0x37, 0xd9, 0x1d, 0x61,
	0xd8, 0x6f, 0x1e, 0x65, 0x77, 0x04, 0xb2, 0x1b, 0x3b, 0x02, 0x1b, 0x82, 0xb7, 0x8c, 0xec, 0x08,
	0xec, 0x05, 0x8e, 0x18, 0x45, 0xea, 0x5b, 0x8f, 0x1a, 0x45, 0xf6, 0x05, 0xdb, 0xfb, 0xed, 0x0a,
	0xa9, 0x23, 0x61, 0xee, 0x19, 0xf4, 0x6d, 0x3e, 0xc7, 0x96, 0x40, 0xb0, 0x89, 0xf7, 0x0c, 0x67,
	0xb9, 0xe2, 0xb2, 0x4c, 0x28, 0x4e, 0xdf, 0xee, 0x2d, 0x5b, 0x72, 0x1b, 0x70, 0xb8, 0xe3, 0x35,
	0xd8, 0x7d, 0xfc, 0x2e, 0x43, 0xdf, 0xe1, 0xfb, 0x0b, 0x4b, 0x37, 0x1f, 0x6c, 0xdc, 0xd9, 0x51,
	0xf1, 0xdd, 0x5b, 0x8f, 0x77, 0xfa, 0x5d, 0x6a, 0x15, 0xdc, 0x9b, 0x8f, 0x51, 0x0f, 0x59, 0x9a,
	0x77, 0xb9, 0xa4, 0xef, 0x3a, 0xe2, 0xe1, 0x2a, 0x0a, 0xaa, 0xfe, 0x19, 0xf9, 0xb6, 0x41, 0x7a,
	0xf7, 0xc8, 0x54, 0x6d, 0x6f, 0x64, 0x97, 0xde, 0x8c, 0x39, 0x2a, 0x24, 0x57, 0x0a, 0x77, 0xea,
	0x83, 0x7e, 0xe9, 0xcd, 0xb0, 0xb7, 0x9c, 0x28, 0xf8, 0x2e, 0xf2, 0xf8, 0xe3, 0x54, 0x22, 0xb6,
	0x27, 0x45, 0x2e, 0xe8, 0x7b, 0x8c, 0x26, 0x3d, 0xaa, 0xd9, 0x46, 0x42, 0xa3, 0x7a, 0xdb, 0x97,
	0x48, 0xf4, 0xbd, 0xcd, 0xea, 0x6d, 0x5f, 0x23, 0x05, 0x17, 0x4d, 0xbb, 0x67, 0x96, 0xd8, 0x5d,
	0x7a, 0x44, 0x96, 0xd0, 0xf7, 0xf9, 0xe1, 0xe1, 0x2a, 0xdb, 0x7b, 0xcf, 0x66, 0x96, 0x04, 0xdf,
	0x49, 0x6e, 0x3d, 0xaa, 0x93, 0x0b, 0x53, 0x34, 0xdf, 0x6f, 0xf4, 0x6e, 0x1a, 0xd1, 0xdb, 0x10,
	0x58, 0x3e, 0x5d, 0x81, 0x2b, 0x4a, 0x99, 0x8a, 0x52, 0xc1, 0x25, 0x46, 0xd1, 0x0f, 0xd4, 0x0a,
	0x9c, 0x15, 0x84, 0x5a, 0x28, 0x97, 0x50, 0xfd, 0xe4, 0x52, 0x94, 0x0b, 0x1d, 0x75, 0x44, 0x99,
	0x27, 0xf4, 0x83, 0x7e, 0x1e, 0xeb, 0xc9, 0xa5, 0x0d, 0xa1, 0x57, 0x01, 0x76, 0x1d, 0x28, 0x70,
	0xcb, 0x9c, 0x1f, 0x14, 0x9c, 0x69, 0x9e, 0xd0, 0x0f, 0xf9, 0xf5, 0x5b, 0x4f, 0x2e, 0x5d, 0xab,
	0x04, 0xae, 0x12, 0x01, 0xdd, 0x96, 0x4e, 0xfa, 0x90, 0xaf, 0x44, 0xeb, 0xc9, 0x25, 0x5b, 0x38,
	0x1b, 0xa1, 0x54, 0x7b, 0x69, 0x07, 0xac, 0x7e, 0xb8, 0x19, 0xca, 0x6d, 0x03, 0x3b, 0x9b, 0x48,
	0xed, 0x73, 0xd9, 0xe5, 0x09, 0xfd, 0x88, 0xb7, 0x09, 0xcc, 0x75, 0x44, 0x5d, 0x75, 0xf3, 0x36,
	0xa3, 0x4e, 0x9c, 0x65, 0x50, 0x1b, 0xe8, 0x47, 0x7d, 0x75, 0xab, 0x4c, 0xaf, 0x5a, 0xa1, 0x1b,
	0x8b, 0x2b, 0x22, 0xf8, 0x79, 0xf9, 0x63, 0x7e, 0x2c, 0xb6, 0x80, 0x40, 0xbb, 0xe2, 0x76, 0x40,
	0xd1, 0x81, 0x24, 0xc2, 0x4f, 0xdf, 0x86, 0xfe, 0x71, 0xbf, 0x03, 0xb6, 0x3a, 0xeb, 0x56, 0x84,
	0x1a, 0xe7, 0x8d, 0xf1, 0x7e, 0x9a, 0x47, 0x5a, 0x67, 0x86, 0xfd, 0x89, 0x5a, 0x48, 0xd2, 0x7c,
	0x47, 0x67, 0xc8, 0x74, 0x29, 0xc3, 0x3b, 0x5c, 0x46, 0x31, 0x63, 0xbc, 0xd0, 0x86, 0xfe, 0xc9,
	0x5a, 0xca, 0x80, 0x70, 0x09, 0x65, 0xa8, 0xf3, 0x5c, 0xf2, 0x38, 0xbc, 0xe5, 0x40, 0x6d, 0x1e,
	0x70, 0xa9, 0x78, 0x54, 0xc4, 0x7a, 0xcf, 0xf5, 0xc5, 0x0f, 0x1b, 0x45, 0xa8, 0xc2, 0x6b, 0x45,
	0x68, 0x08, 0x5b, 0xb1, 0xde, 0xb3, 0x1d, 0xb2, 0xad, 0xcf, 0xf8, 0x39, 0x7c, 0x18, 0xa7, 0xba,
	0xea, 0xed, 0xe8, 0xa7, 0x7c, 0x7d, 0x86, 0x9d, 0x7c, 0x3d, 0x4e, 0xb5, 0x6b, 0xee, 0x82, 0x67,
	0x9b, 0x2c, 0x95, 0x7c, 0x3f, 0xda, 0x37, 0xbd, 0x44, 0x22, 0x22, 0x7b, 0x6d, 0xa1, 0x9f, 0xf6,
	0x71, 0x0e, 0xf9, 0xfe, 0x03, 0xd0, 0x55, 0x2c, 0x8b, 0xb6, 0x11, 0x06, 0xcf, 0x30, 0xc5, 0xa0,
	0xae, 0x09, 0xd3, 0xfb, 0x4c, 0xfd, 0xd0, 0xb6, 0x3a, 0x30, 0xb7, 0x91, 0x0b, 0x23, 0x1e, 0x1c,
	0x9f, 0x1d, 0x1f, 0xbd, 0x30, 0xe2, 0x99, 0xe1, 0xa8, 0x78, 0x66, 0xd8, 0x23, 0xe0, 0x73, 0x35,
	0x2a, 0x1c, 0x19, 0xb6, 0xfc, 0xdb, 0x6e, 0x04, 0xaa, 0x2e, 0xfe, 0x39, 0x81, 0x7e, 0xde, 0x1f,
	0xa8, 0x9b, 0x1d, 0x81, 0x7f, 0x4f, 0xa8, 0xee, 0x97, 0x1d, 0x61, 0x86, 0xf8, 0x85, 0x71, 0x7f,
	0xbf, 0xec, 0x08, 0x1c, 0x5d, 0xcd, 0x0e, 0x26, 0x25, 0x7d, 0xa4, 0x61, 0x07, 0x53, 0xd2, 0x6d,
	0x4b, 0xb6, 0x07, 0x97, 0xae, 0xbc, 0x8b, 0x0d, 0x2c, 0xfd, 0xa2, 0x9f, 0x6f, 0xdb, 0x09, 0x96,
	0x58, 0xaf, 0xda, 0xc3, 0x87, 0xb9, 0x57, 0xa0, 0x8f, 0xd6, 0xf6, 0xf0, 0x61, 0x5e, 0xf1, 0x5d,
	0x22, 0x62, 0xdf, 0x21, 0x0a, 0x9e, 0xbb, 0xcb, 0xc7, 0x63, 0x3e, 0x11, 0xa1, 0xf7, 0xd8, 0x2c,
	0x78, 0x6e, 0x2f, 0x20, 0xb6, 0xba, 0x8c, 0x6a, 0x98, 0xb8, 0x7e, 0xc9, 0x57, 0x97, 0xa6, 0x1a,
	0x86, 0xd7, 0x66, 0xa6, 0x57, 0xb5, 0x2f, 0x2d, 0xe8, 0x97, 0x7d, 0x66, 0x3a, 0x35, 0xfb, 0xda,
	0xc2, 0x65, 0xe6, 0x11, 0x1d, 0xe3, 0xef, 0x2b, 0x3e, 0x33, 0x47, 0x14, 0xd1, 0xe1, 0x12, 0x79,
	0x62, 0x53, 0x79, 0xe4, 0xf2, 0x41, 0xbf, 0x6a, 0xf4, 0x6f, 0xad, 0xe9, 0x37, 0xef, 0x20, 0x47,
	0xa7, 0x6b, 0x52, 0x14, 0xdf, 0xbf, 0xd3, 0xaf, 0x1d, 0x9d, 0xae, 0x49, 0xd2, 0x90, 0xef, 0x57,
	0x75, 0xc4, 0xab, 0xee, 0x66, 0x31, 0xeb, 0xed, 0x89, 0x8c, 0xd3, 0xaf, 0xfb, 0xfc, 0x76, 0x8a,
	0x97, 0x9d, 0x30, 0xf8, 0x6e, 0xf2, 0x84, 0x91, 0x22, 0x7c, 0x10, 0xed, 0x41, 0x43, 0x8b, 0x89,
	0xa6, 0xe8, 0x5f, 0xfb, 0xf3, 0xc5, 0xd7, 0xe3, 0x83, 0x2b, 0x42, 0x69, 0xcc, 0x3a, 0x15, 0x7c,
	0x07, 0xa1, 0x58, 0x88, 0x4a, 0x75, 0x18, 0x15, 0x22, 0xcb, 0x22, 0x79, 0x10, 0x15, 0xb1, 0xf9,
	0xe4, 0xf8, 0x0d, 0xef, 0xf9, 0x72, 0xa9, 0x0e, 0xb7, 0x44, 0x96, 0x85, 0x07, 0x5b, 0x46, 0x58,
	0x1d, 0x9b, 0xa5, 0x86, 0xad, 0x28, 0x7b, 0x70, 0x05, 0xf9, 0x9b, 0xda, 0xb1, 0x59, 0x6a, 0xd1,
	0x36, 0xb0, 0xf3, 0xd1, 0x91, 0xa2, 0x1f, 0xfd, 0x20, 0x97, 0xc2, 0xdd, 0xd6, 0xe3, 0x64, 0x40,
	0xbf, 0x59, 0x9b, 0x9d, 0x14, 0xfd, 0xef, 0xe7, 0x52, 0x98, 0xeb, 0xfa, 0x52, 0x32, 0x08, 0xee,
	0xb3, 0xd5, 0x42, 0x1c, 0x51, 0xfb, 0x5b, 0x9f, 0x05, 0x3b, 0xa2, 0xa9, 0x64, 0xbd, 0x0d, 0xe3,
	0x5c, 0x1f, 0x51, 0xfb, 0x3b, 0xef, 0xed, 0x7a, 0x9c, 0xeb, 0xa6, 0xa2, 0x2b, 0xfa, 0x87, 0x79,
	0xd5, 0x25, 0xff, 0x7d, 0xad, 0xe8, 0x1f, 0xe6, 0xae, 0x3f, 0xb6, 0x1d, 0x8f, 0x90, 0x69, 0x37,
	0xb2, 0x9f, 0xa0, 0x73, 0x4d, 0xff, 0xc1, 0x6f, 0x9b, 0x4d, 0x99, 0x76, 0x97, 0xf1, 0x3b, 0x74,
	0xae, 0x83, 0x67, 0x9b, 0xf1, 0xec, 0x1d, 0x9a, 0x06, 0x5c, 0xcb, 0x18, 0x3f, 0x2f, 0x69, 0xce,
	0x34, 0xfd, 0x47, 0x9f, 0x14, 0x57, 0x8c, 0x7c, 0x07, 0xc4, 0xcb, 0x28, 0x75, 0xc5, 0xb2, 0xa9,
	0x89, 0x7f, 0x52, 0xf8, 0x27, 0x5f, 0x2c, 0xeb, 0x7a, 0xed, 0x61, 0x9e, 0x8c, 0xfa, 0xc3, 0x5b,
	0xb7, 0xf3, 0xf7, 0xcf, 0x47, 0xfc, 0xe1, 0xc5, 0xfb, 0x78, 0x7f, 0x46, 0x13, 0xfd, 0xfd, 0xcb,
	0x11, 0x7f, 0xa8, 0x87, 0xfe, 0x6c, 0xbc, 0xf1, 0x04, 0xec, 0xa5, 0xf8, 0x42, 0xc5, 0x84, 0x90,
	0x0d, 0xe8, 0xbf, 0xfa, 0x78, 0x2f, 0xb1, 0xde, 0xb6, 0x11, 0x63, 0x24, 0xd9, 0xa0, 0x6a, 0xed,
	0x6a, 0x8a, 0x45, 0x3c, 0x54, 0xf4, 0xdf, 0x6a, 0xad, 0x5d, 0xa5, 0xb4, 0x15, 0x0f, 0x55, 0xd5,
	0xda, 0xd5, 0x5d, 0xf1, 0x7d, 0xfa, 0xef, 0xb5, 0xd6, 0xce, 0x7b, 0xe1, 0xfb, 0x6e, 0x43, 0xd6,
	0xf9, 0x9d, 0x34, 0xc7, 0x83, 0xe7, 0x22, 0xfd, 0x0f, 0x1f, 0x0b, 0xaf, 0xb5, 0x9a, 0xe6, 0x70,
	0xf2, 0x5c, 0x3c, 0x4e, 0xb5, 0x3a, 0xb4, 0xe8, 0x7f, 0x1e, 0xa7, 0xea, 0x4e, 0xad, 0xe0, 0x39,
	0x47, 0x55, 0x7d, 0x71, 0xfd, 0x2f, 0x5f, 0x85, 0xbc, 0xaa, 0xaf, 0xb1, 0xb6, 0xc4, 0x0f, 0xd3,
	0xdc, 0x5c, 0x96, 0xe8, 0x7f, 0xfb, 0x12, 0x7f, 0x3d, 0xcd, 0xf1, 0x8a, 0xe4, 0x5a, 0xfe, 0x1e,
	0xe7, 0x45, 0x14, 0x67, 0x50, 0x14, 0xff, 0xc7, 0xb7, 0xfc, 0xf7, 0x73, 0x5e, 0x2c, 0x01, 0xe8,
	0x6c, 0xf5, 0x75, 0x59, 0x98, 0x0a, 0xf8, 0xbf, 0xde, 0xd6, 0xba, 0x2e, 0x8b, 0xfa, 0x31, 0x86,
	0x24, 0x55, 0x32, 0xc6, 0x95, 0xa2, 0xff, 0x57, 0xeb, 0xcb, 0x74, 0x59, 0x6c, 0x1b, 0x38, 0xb8,
	0xc3, 0xd8, 0xf3, 0xff, 0x07, 0xf9, 0xa1, 0x96, 0xbf, 0x68, 0x54, 0xff, 0x09, 0xf1, 0x6f, 0x93,
	0x0c, 0x10, 0x31, 0x4e, 0x7f, 0xb8, 0x55, 0x7f, 0x9b, 0x64, 0xf0, 0x36, 0x77, 0x8d, 0x1e, 0x04,
	0x8a, 0x89, 0x3e, 0xf6, 0xc6, 0x3c, 0xa1, 0x3f, 0xd2, 0xaa, 0xaf, 0x66, 0xbb, 0x12, 0xb8, 0x7c,
	0xa9, 0xef, 0x69, 0x3c, 0x29, 0x7f, 0xb4, 0x55, 0xe5, 0x8b, 0xdf, 0xd0, 0x78, 0x60, 0xde, 0xe1,
	0xdf, 0x38, 0xee, 0x1b, 0xee, 0x8f, 0xb5, 0xaa, 0x10, 0x84, 0x6c, 0xf0, 0x00, 0xb2, 0xec, 0x76,
	0x1e, 0x62, 0xc9, 0x8c, 0xb4, 0x10, 0xd1, 0x6e, 0xda, 0xa5, 0x3f, 0xde, 0xaa, 0xb6, 0xf3, 0x75,
	0x94, 0xec, 0x08, 0x71, 0x39, 0xed, 0x06, 0xdf, 0x33, 0x7a, 0x4e, 0xb8, 0x43, 0x26, 0xce, 0x74,
	0xd4, 0xe3, 0x87, 0xf4, 0x27, 0x5a, 0x55, 0xc9, 0x1d, 0x39, 0x67, 0x96, 0x32, 0x7d, 0x3f, 0x3f,
	0x74, 0xd3, 0xb6, 0x37, 0x99, 0x48, 0xf2, 0xbd, 0x58, 0xed, 0xd1, 0x9f, 0xf4, 0xd3, 0xb6, 0x37,
	0x99, 0x10, 0x05, 0x2e, 0x9d, 0x92, 0xb2, 0xc8, 0x52, 0x16, 0x6b, 0x6e, 0x4a, 0x8e, 0xd5, 0xfa,
	0xa9, 0x56, 0x95, 0x4e, 0xcb, 0x8e, 0x00, 0x95, 0xc7, 0xea, 0xda, 0x0d, 0xe3, 0x2f, 0x87, 0xe6,
	0x1d, 0xf8, 0x4f, 0x7b, 0x5f, 0xd5, 0x0d, 0x11, 0xdf, 0x82, 0x3f, 0xe7, 0xb8, 0xeb, 0x40, 0x52,
	0xee, 0xc2, 0xb9, 0x41, 0x7f, 0xa6, 0xe6, 0xab, 0x76, 0x1d, 0x58, 0x36, 0x62, 0x77, 0x84, 0xf5,
	0xd3, 0xae, 0x84, 0x51, 0x42, 0xcb, 0xe5, 0x12, 0xea, 0x67, 0x5b, 0x55, 0x19, 0x58, 0x37, 0xe2,
	0x90, 0xef, 0xbb, 0xb4, 0x3a, 0x46, 0xcf, 0xf5, 0xf1, 0x3f, 0x77, 0x9c, 0x9e, 0x6b, 0xe7, 0xdd,
	0xdb, 0xcd, 0x6c, 0xd7, 0x05, 0xe3, 0xe7, 0x7d, 0x3e, 0x6e, 0x65, 0xbb, 0x36, 0x04, 0xb7, 0x93,
	0x99, 0x94, 0xf5, 0xcd, 0x27, 0x4e, 0xd5, 0x55, 0xf4, 0x0d, 0x13, 0xf6, 0xe3, 0x1b, 0xeb, 0x17,
	0x6b, 0xf9, 0xba, 0xea, 0xe2, 0xdb, 0x5d, 0x47, 0xb1, 0xef, 0xec, 0xdf, 0x38, 0x61, 0xbf, 0xe3,
	0x21, 0xc9, 0xbe, 0xb0, 0x5f, 0x24, 0x67, 0x1c, 0xad, 0xfe, 0x7e, 0xff, 0x4d, 0x13, 0xf6, 0xf3,
	0x24, 0x72, 0x6b, 0x2f, 0xf8, 0x2f, 0x92, 0x9b, 0x1c, 0x3f, 0xe1, 0x4a, 0x47, 0x65, 0x2e, 0x79,
	0xcc, 0xf6, 0x14, 0x7d, 0xb3, 0xd1, 0x08, 0x8c, 0xc6, 0x32, 0x57, 0xfa, 0x9a, 0x15, 0xe1, 0x07,
	0x53, 0xab, 0x83, 0xe5, 0x86, 0x1f, 0xb0, 0x44, 0xd1, 0xb7, 0x4c, 0xd8, 0x0f, 0x81, 0xa8, 0x00,
	0xe9, 0xb1, 0x02, 0x78, 0x9d, 0x5d, 0xc4, 0xb2, 0x8f, 0x25, 0x43, 0xd1, 0xb7, 0x36, 0xd8, 0x5b,
	0xb1, 0xec, 0x43, 0xd9, 0x68, 0x8c, 0x5f, 0x49, 0x06, 0x1d, 0x42, 0x0e, 0xa3, 0x79, 0x5b, 0x63,
	0xfc, 0xdb, 0x92, 0x3d, 0x60, 0x04, 0xf8, 0x4d, 0xd2, 0xf2, 0x25, 0x4f, 0x52, 0xc9, 0x99, 0x56,
	0xf4, 0xed, 0x0d, 0xe3, 0xa1, 0xc3, 0xf1, 0x63, 0xb3, 0x8b, 0x21, 0xdb, 0x13, 0x8a, 0xbe, 0x63,
	0xc2, 0x7e, 0x6c, 0x36, 0x21, 0x04, 0x0c, 0x3f, 0xd8, 0xd6, 0x48, 0x91, 0xe4, 0x85, 0xa2, 0xef,
	0x9c, 0xb0, 0x1f, 0x6c, 0x2b, 0x62, 0xc8, 0x0b, 0xe8, 0xdc, 0x1b, 0x91, 0xc0, 0xff, 0xc1, 0x28,
	0xfa, 0xae, 0xc6, 0x60, 0x77, 0x2a, 0x01, 0x9c, 0x5d, 0x47, 0xe8, 0xc6, 0xfe, 0xbb, 0x8d, 0xca,
	0x99, 0x11, 0x15, 0x74, 0x52, 0x0b, 0x20, 0xfe, 0x3d, 0xa5, 0x1f, 0xab, 0x9e, 0xa2, 0x0f, 0x36,
	0xe6, 0xb8, 0x94, 0x24, 0x72, 0x1d, 0x70, 0x68, 0x47, 0x8e, 0xb0, 0x8d, 0x8f, 0xf7, 0x34, 0x56,
	0xd4, 0x69, 0xa0, 0x0b, 0x17, 0x18, 0xfc, 0x68, 0x0e, 0x09, 0xf8, 0xde, 0x5a, 0x60, 0x36, 0x4b,
	0x8d, 0x19, 0x78, 0x27, 0x39, 0x5d, 0x91, 0x6c, 0x5a, 0xbd, 0x6f, 0xc2, 0x7e, 0x9b, 0x36, 0x34,
	0x9b, 0x53, 0xcf, 0x25, 0x8f, 0xab, 0x88, 0xb8, 0x5d, 0xf0, 0x6f, 0x6b, 0x51, 0x37, 0x13, 0xbb,
	0x71, 0x46, 0xdf, 0x6f, 0x74, 0x6e, 0xb6, 0x3a, 0x61, 0xac, 0x39, 0xfe, 0x83, 0xed, 0x79, 0x28,
	0x86, 0x93, 0xfa, 0x38, 0x65, 0xe8, 0x17, 0xe9, 0x07, 0x8c, 0xea, 0xd9, 0x51, 0x55, 0x68, 0x15,
	0xab, 0xe0, 0xe2, 0xe7, 0xdf, 0x46, 0x2a, 0x7f, 0xb0, 0x16, 0xdc, 0xcd, 0x52, 0x37, 0x72, 0xd9,
	0xe5, 0x1b, 0x68, 0xd5, 0x92, 0xf9, 0x43, 0xb5, 0x25, 0xdc, 0x2c, 0xb5, 0xcf, 0xe6, 0x3a, 0xbf,
	0x96, 0xce, 0x0f, 0x35, 0xf9, 0x3e, 0x9f, 0xef, 0x21, 0x67, 0x2b, 0x7e, 0x3d, 0xa1, 0x3f, 0x3c,
	0x61, 0xff, 0xe0, 0x61, 0x14, 0x6a, 0x19, 0xed, 0x72, 0xca, 0x94, 0x5d, 0x97, 0xd2, 0x1f, 0x69,
	0x3a, 0xf0, 0x39, 0xed, 0xea, 0x02, 0xae, 0x0a, 0x26, 0xf5, 0x47, 0x6b, 0x75, 0x01, 0x16, 0x05,
	0xb3, 0xfa, 0xae, 0x9a, 0x55, 0x9f, 0xd6, 0x1f, 0xab, 0x25, 0x91, 0xa5, 0x62, 0x3e, 0xdc, 0x3d,
	0x12, 0x15, 0x9b, 0xd8, 0x1f, 0x6f, 0x0e, 0xba, 0x96, 0xd9, 0xcf, 0x22, 0xb7, 0x1c, 0x55, 0x30,
	0x3e, 0x3e, 0xd1, 0x5c, 0xb4, 0x66, 0x6e, 0xd7, 0xc3, 0x59, 0x4b, 0xee, 0x4f, 0x36, 0x67, 0xeb,
	0xb3, 0xfb, 0x52, 0xcd, 0xcf, 0x48, 0x7a, 0x3f, 0xdc, 0x5c, 0xe5, 0x7a, 0x7e, 0x5f, 0xb8, 0x93,
	0x10, 0xff, 0x6f, 0xb4, 0xe0, 0x24, 0x19, 0xdf, 0x69, 0x6f, 0xcd, 0xdf, 0x00, 0x3f, 0x36, 0xd6,
	0xda, 0xf3, 0x63, 0xf8, 0x63, 0x65, 0x67, 0xfe, 0xc4, 0x85, 0x6f, 0x8c, 0x91, 0xe9, 0xda, 0x3f,
	0xcd, 0x83, 0x33, 0xe4, 0xf4, 0x4e, 0x7b, 0x2b, 0x5a, 0xd9, 0xde, 0x59, 0xba, 0x7c, 0x75, 0x6d,
	0xfb, 0xca, 0xca, 0xf2, 0xfc, 0x0d, 0xc1, 0x3c, 0x99, 0x01, 0x70, 0xfb, 0xfb, 0x36, 0xa2, 0xed,
	0x95, 0x8d, 0x9d, 0xf9, 0xb1, 0x3a, 0x12, 0xae, 0xb4, 0xbf, 0x77, 0xfe, 0x44, 0x70, 0x23, 0x99,
	0x05, 0x64, 0x75, 0x6d, 0x23, 0xba, 0xbe, 0xb4, 0xb6, 0x73, 0xef, 0xfc, 0xf8, 0x28, 0x74, 0x71,
	0xbe, 0xe5, 0xa0, 0x9d, 0xb5, 0xf5, 0x15, 0xc4, 0xe6, 0x27, 0x82, 0x59, 0x32, 0x05, 0x50, 0xfb,
	0xea, 0xe6, 0xf6, 0xca, 0xfc, 0x64, 0x10, 0x90, 0xb9, 0xea, 0xd1, 0x50, 0x4e, 0x3a, 0x6f, 0x57,
	0x97, 0xb6, 0x77, 0xa2, 0xa5, 0xf6, 0xfd, 0xf3, 0xa7, 0x82, 0x39, 0x42, 0x10, 0x59, 0xdb, 0xde,
	0x59, 0xd9, 0x98, 0x9f, 0x0a, 0x4e, 0x93, 0x69, 0xa7, 0xb5, 0xb6, 0xf1, 0xbc, 0x79, 0x12, 0x9c,
	0x25, 0xf3, 0x00, 0x6c, 0xac, 0x5c, 0xf7, 0x83, 0x9c, 0xbe, 0x4c, 0x1f, 0x7c, 0xf4, 0xdc, 0xd8,
	0x43, 0x8f, 0x9e, 0x1b, 0x7b, 0xe4, 0xd1, 0x73, 0x63, 0xcf, 0x7f, 0xec, 0xdc, 0x0d, 0x0f, 0x3d,
	0x76, 0xee, 0x86, 0x87, 0x1f, 0x3b, 0x77, 0xc3, 0xee, 0x24, 0xfe, 0x53, 0xed, 0xbe, 0xff, 0x0f,
	0x00, 0x00, 0xff, 0xff, 0xe8, 0x56, 0x2d, 0xe2, 0xd7, 0x31, 0x00, 0x00,
}

func (m *Metric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size := m.Body.Size()
			i -= size
			if _, err := m.Body.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Metric_Tcp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Tcp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcp != nil {
		{
			size, err := m.Tcp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Metric_Nic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Nic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Nic != nil {
		{
			size, err := m.Nic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Metric_Net) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metric_Net) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Net != nil {
		{
			size, err := m.Net.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SocketMemoryUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocketMemoryUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocketMemoryUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SockDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SockDrop))
		i--
		dAtA[i] = 0x48
	}
	if m.BackLog != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BackLog))
		i--
		dAtA[i] = 0x40
	}
	if m.OptMem != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.OptMem))
		i--
		dAtA[i] = 0x38
	}
	if m.WmemQueued != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.WmemQueued))
		i--
		dAtA[i] = 0x30
	}
	if m.FwdAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.FwdAlloc))
		i--
		dAtA[i] = 0x28
	}
	if m.SndBuf != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndBuf))
		i--
		dAtA[i] = 0x20
	}
	if m.WmemAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.WmemAlloc))
		i--
		dAtA[i] = 0x18
	}
	if m.RcvBuf != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvBuf))
		i--
		dAtA[i] = 0x10
	}
	if m.RmemAlloc != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RmemAlloc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retrans != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Retrans))
		i--
		dAtA[i] = 0x18
	}
	if m.ExpireTimeUs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.ExpireTimeUs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Fd))
		i--
		dAtA[i] = 0x18
	}
	if m.Pid != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SocketMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocketMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocketMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecnseen {
		i--
		if m.Ecnseen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.Ecn {
		i--
		if m.Ecn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa8
	}
	if m.SndbufLimited != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndbufLimited))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.RwndLimited != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RwndLimited))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.DataSegsIn != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.DataSegsIn))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.DataSegsOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.DataSegsOut))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.RcvSsthresh != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvSsthresh))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.RcvSpace != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvSpace))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.BusyMs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BusyMs))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.Delivered != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Delivered))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.Lastack != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastack))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.Lastrcv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastrcv))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.Lastsnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Lastsnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.SegsIn != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SegsIn))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.SegsOut != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SegsOut))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.BytesReceived != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesReceived))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.BytesAcked != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesAcked))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.BytesSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.BytesSent))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.SndWnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndWnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.Cwnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Cwnd))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.Advmss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Advmss))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.Rcvmss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Rcvmss))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.Pmtu != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Pmtu))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.Mss != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Mss))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.Ato != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ato))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf1
	}
	if m.RetransTotal != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RetransTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.RetransNow != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RetransNow))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.RcvRtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RcvRtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if m.Minrtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Minrtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb9
	}
	if m.Rttvar != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rttvar))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb1
	}
	if m.Rtt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rtt))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa9
	}
	if m.Rto != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rto))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.RcvWscale != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RcvWscale))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SndWscale != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SndWscale))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Send != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Send))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.DeliveryRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeliveryRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.PacingRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PacingRate))))
		i--
		dAtA[i] = 0x79
	}
	if m.AppLimited {
		i--
		if m.AppLimited {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Cubic {
		i--
		if m.Cubic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Sack {
		i--
		if m.Sack {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Ts {
		i--
		if m.Ts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Skmem != nil {
		{
			size, err := m.Skmem.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTcpmon(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Timers) > 0 {
		for iNdEx := len(m.Timers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Timers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Processes) > 0 {
		for iNdEx := len(m.Processes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PeerAddr) > 0 {
		i -= len(m.PeerAddr)
		copy(dAtA[i:], m.PeerAddr)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.PeerAddr)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LocalAddr) > 0 {
		i -= len(m.LocalAddr)
		copy(dAtA[i:], m.LocalAddr)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.LocalAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.SendQ != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.SendQ))
		i--
		dAtA[i] = 0x28
	}
	if m.RecvQ != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RecvQ))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *TcpMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TcpMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sockets) > 0 {
		for iNdEx := len(m.Sockets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sockets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IfaceMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IfaceMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IfaceMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxCollisions != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxCollisions))
		i--
		dAtA[i] = 0x50
	}
	if m.TxCarrier != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxCarrier))
		i--
		dAtA[i] = 0x48
	}
	if m.TxOverruns != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxOverruns))
		i--
		dAtA[i] = 0x40
	}
	if m.TxDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxDropped))
		i--
		dAtA[i] = 0x38
	}
	if m.TxErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TxErrors))
		i--
		dAtA[i] = 0x30
	}
	if m.RxFrame != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxFrame))
		i--
		dAtA[i] = 0x28
	}
	if m.RxOverruns != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxOverruns))
		i--
		dAtA[i] = 0x20
	}
	if m.RxDropped != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxDropped))
		i--
		dAtA[i] = 0x18
	}
	if m.RxErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.RxErrors))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTcpmon(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NicMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NicMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NicMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ifaces) > 0 {
		for iNdEx := len(m.Ifaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ifaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTcpmon(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetstatMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetstatMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetstatMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IcmpOutAddrMaskReps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutAddrMaskReps))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0xc0
	}
	if m.IcmpOutAddrMasks != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutAddrMasks))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0xb8
	}
	if m.IcmpOutTimestampReps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutTimestampReps))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0xb0
	}
	if m.IcmpOutTimestamps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutTimestamps))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0xa8
	}
	if m.IcmpOutEchoReps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutEchoReps))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0xa0
	}
	if m.IcmpOutEchos != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutEchos))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0x98
	}
	if m.IcmpOutRedirects != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutRedirects))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0x90
	}
	if m.IcmpOutSrcQuenchs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutSrcQuenchs))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0x88
	}
	if m.IcmpOutParmProbs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutParmProbs))
		i--
		dAtA[i] = 0x2d
		i--
		dAtA[i] = 0x80
	}
	if m.IcmpOutTimeExcds != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutTimeExcds))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xf8
	}
	if m.IcmpOutDestUnreachs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutDestUnreachs))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xf0
	}
	if m.IcmpOutRateLimitHost != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutRateLimitHost))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xe8
	}
	if m.IcmpOutRateLimitGlobal != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutRateLimitGlobal))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xe0
	}
	if m.IcmpOutErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutErrors))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xd8
	}
	if m.IcmpOutMsgs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpOutMsgs))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xd0
	}
	if m.IcmpInAddrMaskReps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInAddrMaskReps))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xc8
	}
	if m.IcmpInAddrMasks != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInAddrMasks))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xc0
	}
	if m.IcmpInTimestampReps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInTimestampReps))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xb8
	}
	if m.IcmpInTimestamps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInTimestamps))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xb0
	}
	if m.IcmpInEchoReps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInEchoReps))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xa8
	}
	if m.IcmpInEchos != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInEchos))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xa0
	}
	if m.IcmpInRedirects != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInRedirects))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x98
	}
	if m.IcmpInSrcQuenchs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInSrcQuenchs))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x90
	}
	if m.IcmpInParmProbs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInParmProbs))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x88
	}
	if m.IcmpInTimeExcds != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInTimeExcds))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0x80
	}
	if m.IcmpInDestUnreachs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInDestUnreachs))
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf8
	}
	if m.IcmpInCsumErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInCsumErrors))
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xf0
	}
	if m.IcmpInErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInErrors))
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xe8
	}
	if m.IcmpInMsgs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IcmpInMsgs))
		i--
		dAtA[i] = 0x2b
		i--
		dAtA[i] = 0xe0
	}
	if m.IpReasmOverlaps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpReasmOverlaps))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0xc8
	}
	if m.IpInCePkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInCePkts))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0xc0
	}
	if m.IpInEct0Pkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInEct0Pkts))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0xb8
	}
	if m.IpInEct1Pkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInEct1Pkts))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0xb0
	}
	if m.IpInNoEctPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInNoEctPkts))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0xa8
	}
	if m.IpInCsumErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInCsumErrors))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0xa0
	}
	if m.IpOutBcastOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutBcastOctets))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0x98
	}
	if m.IpInBcastOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInBcastOctets))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0x90
	}
	if m.IpOutMcastOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutMcastOctets))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0x88
	}
	if m.IpInMcastOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInMcastOctets))
		i--
		dAtA[i] = 0x26
		i--
		dAtA[i] = 0x80
	}
	if m.IpOutOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutOctets))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xf8
	}
	if m.IpInOctets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInOctets))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xf0
	}
	if m.IpOutBcastPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutBcastPkts))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xe8
	}
	if m.IpInBcastPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInBcastPkts))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xe0
	}
	if m.IpOutMcastPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutMcastPkts))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xd8
	}
	if m.IpInMcastPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInMcastPkts))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xd0
	}
	if m.IpInTruncatedPkts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInTruncatedPkts))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xc8
	}
	if m.IpInNoRoutes != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInNoRoutes))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpPlbRehash != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPlbRehash))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpMigrateReqFailure != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMigrateReqFailure))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpMigrateReqSuccess != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMigrateReqSuccess))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpDsackIgnoredDubious != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackIgnoredDubious))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpDsackRecvSegs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackRecvSegs))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpDuplicateDataRehash != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDuplicateDataRehash))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpTimeoutRehash != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpTimeoutRehash))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpFastOpenPassiveAltKey != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenPassiveAltKey))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpWqueueTooBig != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpWqueueTooBig))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpRcvQDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRcvQDrop))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpZeroWindowDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpZeroWindowDrop))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0x98
	}
	if m.TcpAckCompressed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAckCompressed))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0x90
	}
	if m.TcpDeliveredCe != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDeliveredCe))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0x88
	}
	if m.TcpDelivered != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDelivered))
		i--
		dAtA[i] = 0x20
		i--
		dAtA[i] = 0x80
	}
	if m.TcpMtupSuccess != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMtupSuccess))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpMtupFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMtupFail))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpKeepAlive != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpKeepAlive))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpWinProbe != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpWinProbe))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpAckSkippedChallenge != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAckSkippedChallenge))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpAckSkippedTimeWait != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAckSkippedTimeWait))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpAckSkippedFinWait2 != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAckSkippedFinWait2))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpAckSkippedSeq != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAckSkippedSeq))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpAckSkippedPaws != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAckSkippedPaws))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpAckSkippedSynRecv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAckSkippedSynRecv))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpHystartDelayCwnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpHystartDelayCwnd))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpHystartDelayDetect != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpHystartDelayDetect))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpHystartTrainCwnd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpHystartTrainCwnd))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0x98
	}
	if m.TcpHystartTrainDetect != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpHystartTrainDetect))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0x90
	}
	if m.TcpOrigDataSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOrigDataSent))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0x88
	}
	if m.TcpSynRetrans != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSynRetrans))
		i--
		dAtA[i] = 0x1f
		i--
		dAtA[i] = 0x80
	}
	if m.TcpWantZeroWindowAdv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpWantZeroWindowAdv))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpToZeroWindowAdv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpToZeroWindowAdv))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpFromZeroWindowAdv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFromZeroWindowAdv))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpAutoCorking != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAutoCorking))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpBusyPollRxPackets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpBusyPollRxPackets))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpSpuriousRtxHostQueues != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSpuriousRtxHostQueues))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpFastOpenBlackhole != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenBlackhole))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpFastOpenCookieReqd != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenCookieReqd))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpFastOpenListenOverflow != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenListenOverflow))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpFastOpenPassiveFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenPassiveFail))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpFastOpenPassive != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenPassive))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpFastOpenActiveFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenActiveFail))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpFastOpenActive != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastOpenActive))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0x98
	}
	if m.TcpSynChallenge != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSynChallenge))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0x90
	}
	if m.TcpChallengeAck != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpChallengeAck))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0x88
	}
	if m.TcpOfoMerge != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOfoMerge))
		i--
		dAtA[i] = 0x1e
		i--
		dAtA[i] = 0x80
	}
	if m.TcpOfoDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOfoDrop))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpOfoQueue != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOfoQueue))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpRcvCoalesce != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRcvCoalesce))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpRetransFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRetransFail))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpReqQFullDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpReqQFullDrop))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpReqQFullDoCookies != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpReqQFullDoCookies))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpTimeWaitOverflow != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpTimeWaitOverflow))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpIpReversePathFilter != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpIpReversePathFilter))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpDeferAcceptDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDeferAcceptDrop))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpMinTtlDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMinTtlDrop))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpPfMemallocDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPfMemallocDrop))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpBacklogDrop != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpBacklogDrop))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpSackShiftFallback != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackShiftFallback))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0x98
	}
	if m.TcpSackMerged != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackMerged))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0x90
	}
	if m.TcpSackShifted != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackShifted))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0x88
	}
	if m.TcpMd5Failure != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMd5Failure))
		i--
		dAtA[i] = 0x1d
		i--
		dAtA[i] = 0x80
	}
	if m.TcpMd5Unexpected != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMd5Unexpected))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpMd5NotFound != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMd5NotFound))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpSpuriousRtos != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSpuriousRtos))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpDsackIgnoredNoUndo != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackIgnoredNoUndo))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpDsackIgnoredOld != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackIgnoredOld))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpSackDiscard != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackDiscard))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpMemoryPressuresChrono != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMemoryPressuresChrono))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpMemoryPressures != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMemoryPressures))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpAbortFailed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAbortFailed))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpAbortOnLinger != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAbortOnLinger))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpAbortOnTimeout != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAbortOnTimeout))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpAbortOnMemory != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAbortOnMemory))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpAbortOnClose != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAbortOnClose))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0x98
	}
	if m.TcpAbortOnData != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAbortOnData))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0x90
	}
	if m.TcpDsackOfoRecv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackOfoRecv))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0x88
	}
	if m.TcpDsackRecv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackRecv))
		i--
		dAtA[i] = 0x1c
		i--
		dAtA[i] = 0x80
	}
	if m.TcpDsackOfoSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackOfoSent))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpDsackOldSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackOldSent))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpBacklogCoalesce != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpBacklogCoalesce))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpRcvCollapsed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRcvCollapsed))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpSackRecoveryFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackRecoveryFail))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpRenoRecoveryFail != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRenoRecoveryFail))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpLossProbeRecovery != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpLossProbeRecovery))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpLossProbes != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpLossProbes))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpTimeouts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpTimeouts))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpSlowStartRetrans != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSlowStartRetrans))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpFastRetrans != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFastRetrans))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpLossFailures != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpLossFailures))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpSackFailures != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackFailures))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0x98
	}
	if m.TcpRenoFailures != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRenoFailures))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0x90
	}
	if m.TcpLostRetransmit != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpLostRetransmit))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0x88
	}
	if m.TcpLossUndo != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpLossUndo))
		i--
		dAtA[i] = 0x1b
		i--
		dAtA[i] = 0x80
	}
	if m.TcpDsackUndo != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDsackUndo))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpPartialUndo != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPartialUndo))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpFullUndo != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpFullUndo))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpTsReorder != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpTsReorder))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpRenoReorder != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRenoReorder))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpSackReorder != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackReorder))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpSackReneging != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackReneging))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpSackRecovery != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSackRecovery))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpRenoRecovery != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRenoRecovery))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpHpAcks != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpHpAcks))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpPureAcks != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPureAcks))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpHpHits != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpHpHits))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpListenDrops != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpListenDrops))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x98
	}
	if m.TcpListenOverflows != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpListenOverflows))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x90
	}
	if m.TcpDelayedAckLost != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDelayedAckLost))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x88
	}
	if m.TcpDelayedAckLocked != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDelayedAckLocked))
		i--
		dAtA[i] = 0x1a
		i--
		dAtA[i] = 0x80
	}
	if m.TcpDelayedAcks != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpDelayedAcks))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpPawsEstab != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPawsEstab))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpPawsActive != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPawsActive))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpTwKilled != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpTwKilled))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xe0
	}
	if m.TcpTwRecycled != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpTwRecycled))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd8
	}
	if m.TcpTw != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpTw))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpArpFilter != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpArpFilter))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpLockDroppedIcmps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpLockDroppedIcmps))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpOutOfWindowIcmps != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOutOfWindowIcmps))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpOfoPruned != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOfoPruned))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpRcvPruned != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRcvPruned))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpPruneCalled != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPruneCalled))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpEmbryonicRsts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpEmbryonicRsts))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x98
	}
	if m.TcpSyncookiesFailed != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSyncookiesFailed))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x90
	}
	if m.TcpSyncookiesRecv != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSyncookiesRecv))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x88
	}
	if m.TcpSyncookiesSent != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpSyncookiesSent))
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x80
	}
	if m.TcpInCsumErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpInCsumErrors))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0xd0
	}
	if m.TcpOutRsts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOutRsts))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0xc8
	}
	if m.TcpInErrs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpInErrs))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0xc0
	}
	if m.TcpRetransSegs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRetransSegs))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0xb8
	}
	if m.TcpOutSegs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpOutSegs))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0xb0
	}
	if m.TcpInSegs != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpInSegs))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0xa8
	}
	if m.TcpCurrEstab != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpCurrEstab))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0xa0
	}
	if m.TcpEstabResets != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpEstabResets))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x98
	}
	if m.TcpAttemptFails != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpAttemptFails))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x90
	}
	if m.TcpPassiveOpens != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpPassiveOpens))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x88
	}
	if m.TcpActiveOpens != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpActiveOpens))
		i--
		dAtA[i] = 0x13
		i--
		dAtA[i] = 0x80
	}
	if m.TcpMaxConn != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpMaxConn))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xf8
	}
	if m.TcpRtoMax != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRtoMax))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xf0
	}
	if m.TcpRtoMin != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRtoMin))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xe8
	}
	if m.TcpRtoAlgorithm != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.TcpRtoAlgorithm))
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xe0
	}
	if m.UdpMemErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpMemErrors))
		i--
		dAtA[i] = 0xd
		i--
		dAtA[i] = 0x80
	}
	if m.UdpIgnoredMulti != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpIgnoredMulti))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf8
	}
	if m.UdpInCsumErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpInCsumErrors))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xf0
	}
	if m.UdpSndbufErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpSndbufErrors))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe8
	}
	if m.UdpRcvbufErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpRcvbufErrors))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xe0
	}
	if m.UdpOutDatagrams != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpOutDatagrams))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd8
	}
	if m.UdpInErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpInErrors))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd0
	}
	if m.UdpNoPorts != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpNoPorts))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc8
	}
	if m.UdpInDatagrams != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.UdpInDatagrams))
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xc0
	}
	if m.IpFragCreates != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpFragCreates))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xb0
	}
	if m.IpFragFails != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpFragFails))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa8
	}
	if m.IpFragOks != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpFragOks))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa0
	}
	if m.IpReasmFails != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpReasmFails))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x98
	}
	if m.IpReasmOks != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpReasmOks))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x90
	}
	if m.IpReasmReqds != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpReasmReqds))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x88
	}
	if m.IpReasmTimeout != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpReasmTimeout))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x80
	}
	if m.IpOutNoRoutes != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutNoRoutes))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf8
	}
	if m.IpOutDiscards != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutDiscards))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf0
	}
	if m.IpOutRequests != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpOutRequests))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe8
	}
	if m.IpInDelivers != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInDelivers))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe0
	}
	if m.IpInDiscards != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInDiscards))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd8
	}
	if m.IpInUnknownProtos != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInUnknownProtos))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd0
	}
	if m.IpForwDatagrams != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpForwDatagrams))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc8
	}
	if m.IpInAddrErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInAddrErrors))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc0
	}
	if m.IpInHdrErrors != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInHdrErrors))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if m.IpInReceives != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpInReceives))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.IpDefaultTtl != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpDefaultTtl))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.IpForwarding != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.IpForwarding))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Type != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintTcpmon(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTcpmon(dAtA []byte, offset int, v uint64) int {
	offset -= sovTcpmon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	return n
}

func (m *Metric_Tcp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcp != nil {
		l = m.Tcp.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *Metric_Nic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nic != nil {
		l = m.Nic.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *Metric_Net) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Net != nil {
		l = m.Net.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	return n
}
func (m *SocketMemoryUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RmemAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.RmemAlloc))
	}
	if m.RcvBuf != 0 {
		n += 1 + sovTcpmon(uint64(m.RcvBuf))
	}
	if m.WmemAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.WmemAlloc))
	}
	if m.SndBuf != 0 {
		n += 1 + sovTcpmon(uint64(m.SndBuf))
	}
	if m.FwdAlloc != 0 {
		n += 1 + sovTcpmon(uint64(m.FwdAlloc))
	}
	if m.WmemQueued != 0 {
		n += 1 + sovTcpmon(uint64(m.WmemQueued))
	}
	if m.OptMem != 0 {
		n += 1 + sovTcpmon(uint64(m.OptMem))
	}
	if m.BackLog != 0 {
		n += 1 + sovTcpmon(uint64(m.BackLog))
	}
	if m.SockDrop != 0 {
		n += 1 + sovTcpmon(uint64(m.SockDrop))
	}
	return n
}

func (m *TimerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.ExpireTimeUs != 0 {
		n += 1 + sovTcpmon(uint64(m.ExpireTimeUs))
	}
	if m.Retrans != 0 {
		n += 1 + sovTcpmon(uint64(m.Retrans))
	}
	return n
}

func (m *ProcessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovTcpmon(uint64(m.Pid))
	}
	if m.Fd != 0 {
		n += 1 + sovTcpmon(uint64(m.Fd))
	}
	return n
}

func (m *SocketMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovTcpmon(uint64(m.State))
	}
	if m.RecvQ != 0 {
		n += 1 + sovTcpmon(uint64(m.RecvQ))
	}
	if m.SendQ != 0 {
		n += 1 + sovTcpmon(uint64(m.SendQ))
	}
	l = len(m.LocalAddr)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	l = len(m.PeerAddr)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	if len(m.Timers) > 0 {
		for _, e := range m.Timers {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	if m.Skmem != nil {
		l = m.Skmem.Size()
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.Ts {
		n += 2
	}
	if m.Sack {
		n += 2
	}
	if m.Cubic {
		n += 2
	}
	if m.AppLimited {
		n += 2
	}
	if m.PacingRate != 0 {
		n += 9
	}
	if m.DeliveryRate != 0 {
		n += 10
	}
	if m.Send != 0 {
		n += 10
	}
	if m.SndWscale != 0 {
		n += 2 + sovTcpmon(uint64(m.SndWscale))
	}
	if m.RcvWscale != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvWscale))
	}
	if m.Rto != 0 {
		n += 10
	}
	if m.Rtt != 0 {
		n += 10
	}
	if m.Rttvar != 0 {
		n += 10
	}
	if m.Minrtt != 0 {
		n += 10
	}
	if m.RcvRtt != 0 {
		n += 10
	}
	if m.RetransNow != 0 {
		n += 2 + sovTcpmon(uint64(m.RetransNow))
	}
	if m.RetransTotal != 0 {
		n += 2 + sovTcpmon(uint64(m.RetransTotal))
	}
	if m.Ato != 0 {
		n += 10
	}
	if m.Mss != 0 {
		n += 2 + sovTcpmon(uint64(m.Mss))
	}
	if m.Pmtu != 0 {
		n += 2 + sovTcpmon(uint64(m.Pmtu))
	}
	if m.Rcvmss != 0 {
		n += 2 + sovTcpmon(uint64(m.Rcvmss))
	}
	if m.Advmss != 0 {
		n += 2 + sovTcpmon(uint64(m.Advmss))
	}
	if m.Cwnd != 0 {
		n += 2 + sovTcpmon(uint64(m.Cwnd))
	}
	if m.SndWnd != 0 {
		n += 2 + sovTcpmon(uint64(m.SndWnd))
	}
	if m.BytesSent != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesSent))
	}
	if m.BytesAcked != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesAcked))
	}
	if m.BytesReceived != 0 {
		n += 2 + sovTcpmon(uint64(m.BytesReceived))
	}
	if m.SegsOut != 0 {
		n += 2 + sovTcpmon(uint64(m.SegsOut))
	}
	if m.SegsIn != 0 {
		n += 2 + sovTcpmon(uint64(m.SegsIn))
	}
	if m.Lastsnd != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastsnd))
	}
	if m.Lastrcv != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastrcv))
	}
	if m.Lastack != 0 {
		n += 2 + sovTcpmon(uint64(m.Lastack))
	}
	if m.Delivered != 0 {
		n += 2 + sovTcpmon(uint64(m.Delivered))
	}
	if m.BusyMs != 0 {
		n += 2 + sovTcpmon(uint64(m.BusyMs))
	}
	if m.RcvSpace != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvSpace))
	}
	if m.RcvSsthresh != 0 {
		n += 2 + sovTcpmon(uint64(m.RcvSsthresh))
	}
	if m.DataSegsOut != 0 {
		n += 2 + sovTcpmon(uint64(m.DataSegsOut))
	}
	if m.DataSegsIn != 0 {
		n += 2 + sovTcpmon(uint64(m.DataSegsIn))
	}
	if m.RwndLimited != 0 {
		n += 2 + sovTcpmon(uint64(m.RwndLimited))
	}
	if m.SndbufLimited != 0 {
		n += 2 + sovTcpmon(uint64(m.SndbufLimited))
	}
	if m.Ecn {
		n += 3
	}
	if m.Ecnseen {
		n += 3
	}
	return n
}

func (m *TcpMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if len(m.Sockets) > 0 {
		for _, e := range m.Sockets {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	return n
}

func (m *IfaceMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTcpmon(uint64(l))
	}
	if m.RxErrors != 0 {
		n += 1 + sovTcpmon(uint64(m.RxErrors))
	}
	if m.RxDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.RxDropped))
	}
	if m.RxOverruns != 0 {
		n += 1 + sovTcpmon(uint64(m.RxOverruns))
	}
	if m.RxFrame != 0 {
		n += 1 + sovTcpmon(uint64(m.RxFrame))
	}
	if m.TxErrors != 0 {
		n += 1 + sovTcpmon(uint64(m.TxErrors))
	}
	if m.TxDropped != 0 {
		n += 1 + sovTcpmon(uint64(m.TxDropped))
	}
	if m.TxOverruns != 0 {
		n += 1 + sovTcpmon(uint64(m.TxOverruns))
	}
	if m.TxCarrier != 0 {
		n += 1 + sovTcpmon(uint64(m.TxCarrier))
	}
	if m.TxCollisions != 0 {
		n += 1 + sovTcpmon(uint64(m.TxCollisions))
	}
	return n
}

func (m *NicMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if len(m.Ifaces) > 0 {
		for _, e := range m.Ifaces {
			l = e.Size()
			n += 1 + l + sovTcpmon(uint64(l))
		}
	}
	return n
}

func (m *NetstatMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTcpmon(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovTcpmon(uint64(m.Type))
	}
	if m.IpForwarding != 0 {
		n += 2 + sovTcpmon(uint64(m.IpForwarding))
	}
	if m.IpDefaultTtl != 0 {
		n += 2 + sovTcpmon(uint64(m.IpDefaultTtl))
	}
	if m.IpInReceives != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInReceives))
	}
	if m.IpInHdrErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInHdrErrors))
	}
	if m.IpInAddrErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInAddrErrors))
	}
	if m.IpForwDatagrams != 0 {
		n += 2 + sovTcpmon(uint64(m.IpForwDatagrams))
	}
	if m.IpInUnknownProtos != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInUnknownProtos))
	}
	if m.IpInDiscards != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInDiscards))
	}
	if m.IpInDelivers != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInDelivers))
	}
	if m.IpOutRequests != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutRequests))
	}
	if m.IpOutDiscards != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutDiscards))
	}
	if m.IpOutNoRoutes != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutNoRoutes))
	}
	if m.IpReasmTimeout != 0 {
		n += 2 + sovTcpmon(uint64(m.IpReasmTimeout))
	}
	if m.IpReasmReqds != 0 {
		n += 2 + sovTcpmon(uint64(m.IpReasmReqds))
	}
	if m.IpReasmOks != 0 {
		n += 2 + sovTcpmon(uint64(m.IpReasmOks))
	}
	if m.IpReasmFails != 0 {
		n += 2 + sovTcpmon(uint64(m.IpReasmFails))
	}
	if m.IpFragOks != 0 {
		n += 2 + sovTcpmon(uint64(m.IpFragOks))
	}
	if m.IpFragFails != 0 {
		n += 2 + sovTcpmon(uint64(m.IpFragFails))
	}
	if m.IpFragCreates != 0 {
		n += 2 + sovTcpmon(uint64(m.IpFragCreates))
	}
	if m.UdpInDatagrams != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpInDatagrams))
	}
	if m.UdpNoPorts != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpNoPorts))
	}
	if m.UdpInErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpInErrors))
	}
	if m.UdpOutDatagrams != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpOutDatagrams))
	}
	if m.UdpRcvbufErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpRcvbufErrors))
	}
	if m.UdpSndbufErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpSndbufErrors))
	}
	if m.UdpInCsumErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpInCsumErrors))
	}
	if m.UdpIgnoredMulti != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpIgnoredMulti))
	}
	if m.UdpMemErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.UdpMemErrors))
	}
	if m.TcpRtoAlgorithm != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRtoAlgorithm))
	}
	if m.TcpRtoMin != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRtoMin))
	}
	if m.TcpRtoMax != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRtoMax))
	}
	if m.TcpMaxConn != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMaxConn))
	}
	if m.TcpActiveOpens != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpActiveOpens))
	}
	if m.TcpPassiveOpens != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPassiveOpens))
	}
	if m.TcpAttemptFails != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAttemptFails))
	}
	if m.TcpEstabResets != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpEstabResets))
	}
	if m.TcpCurrEstab != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpCurrEstab))
	}
	if m.TcpInSegs != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpInSegs))
	}
	if m.TcpOutSegs != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOutSegs))
	}
	if m.TcpRetransSegs != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRetransSegs))
	}
	if m.TcpInErrs != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpInErrs))
	}
	if m.TcpOutRsts != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOutRsts))
	}
	if m.TcpInCsumErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpInCsumErrors))
	}
	if m.TcpSyncookiesSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSyncookiesSent))
	}
	if m.TcpSyncookiesRecv != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSyncookiesRecv))
	}
	if m.TcpSyncookiesFailed != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSyncookiesFailed))
	}
	if m.TcpEmbryonicRsts != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpEmbryonicRsts))
	}
	if m.TcpPruneCalled != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPruneCalled))
	}
	if m.TcpRcvPruned != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRcvPruned))
	}
	if m.TcpOfoPruned != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOfoPruned))
	}
	if m.TcpOutOfWindowIcmps != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOutOfWindowIcmps))
	}
	if m.TcpLockDroppedIcmps != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpLockDroppedIcmps))
	}
	if m.TcpArpFilter != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpArpFilter))
	}
	if m.TcpTw != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpTw))
	}
	if m.TcpTwRecycled != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpTwRecycled))
	}
	if m.TcpTwKilled != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpTwKilled))
	}
	if m.TcpPawsActive != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPawsActive))
	}
	if m.TcpPawsEstab != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPawsEstab))
	}
	if m.TcpDelayedAcks != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDelayedAcks))
	}
	if m.TcpDelayedAckLocked != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDelayedAckLocked))
	}
	if m.TcpDelayedAckLost != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDelayedAckLost))
	}
	if m.TcpListenOverflows != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpListenOverflows))
	}
	if m.TcpListenDrops != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpListenDrops))
	}
	if m.TcpHpHits != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpHpHits))
	}
	if m.TcpPureAcks != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPureAcks))
	}
	if m.TcpHpAcks != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpHpAcks))
	}
	if m.TcpRenoRecovery != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRenoRecovery))
	}
	if m.TcpSackRecovery != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackRecovery))
	}
	if m.TcpSackReneging != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackReneging))
	}
	if m.TcpSackReorder != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackReorder))
	}
	if m.TcpRenoReorder != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRenoReorder))
	}
	if m.TcpTsReorder != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpTsReorder))
	}
	if m.TcpFullUndo != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFullUndo))
	}
	if m.TcpPartialUndo != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPartialUndo))
	}
	if m.TcpDsackUndo != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackUndo))
	}
	if m.TcpLossUndo != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpLossUndo))
	}
	if m.TcpLostRetransmit != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpLostRetransmit))
	}
	if m.TcpRenoFailures != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRenoFailures))
	}
	if m.TcpSackFailures != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackFailures))
	}
	if m.TcpLossFailures != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpLossFailures))
	}
	if m.TcpFastRetrans != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastRetrans))
	}
	if m.TcpSlowStartRetrans != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSlowStartRetrans))
	}
	if m.TcpTimeouts != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpTimeouts))
	}
	if m.TcpLossProbes != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpLossProbes))
	}
	if m.TcpLossProbeRecovery != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpLossProbeRecovery))
	}
	if m.TcpRenoRecoveryFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRenoRecoveryFail))
	}
	if m.TcpSackRecoveryFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackRecoveryFail))
	}
	if m.TcpRcvCollapsed != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRcvCollapsed))
	}
	if m.TcpBacklogCoalesce != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpBacklogCoalesce))
	}
	if m.TcpDsackOldSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackOldSent))
	}
	if m.TcpDsackOfoSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackOfoSent))
	}
	if m.TcpDsackRecv != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackRecv))
	}
	if m.TcpDsackOfoRecv != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackOfoRecv))
	}
	if m.TcpAbortOnData != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAbortOnData))
	}
	if m.TcpAbortOnClose != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAbortOnClose))
	}
	if m.TcpAbortOnMemory != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAbortOnMemory))
	}
	if m.TcpAbortOnTimeout != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAbortOnTimeout))
	}
	if m.TcpAbortOnLinger != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAbortOnLinger))
	}
	if m.TcpAbortFailed != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAbortFailed))
	}
	if m.TcpMemoryPressures != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMemoryPressures))
	}
	if m.TcpMemoryPressuresChrono != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMemoryPressuresChrono))
	}
	if m.TcpSackDiscard != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackDiscard))
	}
	if m.TcpDsackIgnoredOld != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackIgnoredOld))
	}
	if m.TcpDsackIgnoredNoUndo != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackIgnoredNoUndo))
	}
	if m.TcpSpuriousRtos != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSpuriousRtos))
	}
	if m.TcpMd5NotFound != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMd5NotFound))
	}
	if m.TcpMd5Unexpected != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMd5Unexpected))
	}
	if m.TcpMd5Failure != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMd5Failure))
	}
	if m.TcpSackShifted != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackShifted))
	}
	if m.TcpSackMerged != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackMerged))
	}
	if m.TcpSackShiftFallback != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSackShiftFallback))
	}
	if m.TcpBacklogDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpBacklogDrop))
	}
	if m.TcpPfMemallocDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPfMemallocDrop))
	}
	if m.TcpMinTtlDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMinTtlDrop))
	}
	if m.TcpDeferAcceptDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDeferAcceptDrop))
	}
	if m.TcpIpReversePathFilter != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpIpReversePathFilter))
	}
	if m.TcpTimeWaitOverflow != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpTimeWaitOverflow))
	}
	if m.TcpReqQFullDoCookies != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpReqQFullDoCookies))
	}
	if m.TcpReqQFullDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpReqQFullDrop))
	}
	if m.TcpRetransFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRetransFail))
	}
	if m.TcpRcvCoalesce != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRcvCoalesce))
	}
	if m.TcpOfoQueue != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOfoQueue))
	}
	if m.TcpOfoDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOfoDrop))
	}
	if m.TcpOfoMerge != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOfoMerge))
	}
	if m.TcpChallengeAck != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpChallengeAck))
	}
	if m.TcpSynChallenge != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSynChallenge))
	}
	if m.TcpFastOpenActive != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenActive))
	}
	if m.TcpFastOpenActiveFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenActiveFail))
	}
	if m.TcpFastOpenPassive != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenPassive))
	}
	if m.TcpFastOpenPassiveFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenPassiveFail))
	}
	if m.TcpFastOpenListenOverflow != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenListenOverflow))
	}
	if m.TcpFastOpenCookieReqd != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenCookieReqd))
	}
	if m.TcpFastOpenBlackhole != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenBlackhole))
	}
	if m.TcpSpuriousRtxHostQueues != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSpuriousRtxHostQueues))
	}
	if m.TcpBusyPollRxPackets != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpBusyPollRxPackets))
	}
	if m.TcpAutoCorking != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAutoCorking))
	}
	if m.TcpFromZeroWindowAdv != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFromZeroWindowAdv))
	}
	if m.TcpToZeroWindowAdv != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpToZeroWindowAdv))
	}
	if m.TcpWantZeroWindowAdv != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpWantZeroWindowAdv))
	}
	if m.TcpSynRetrans != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpSynRetrans))
	}
	if m.TcpOrigDataSent != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpOrigDataSent))
	}
	if m.TcpHystartTrainDetect != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpHystartTrainDetect))
	}
	if m.TcpHystartTrainCwnd != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpHystartTrainCwnd))
	}
	if m.TcpHystartDelayDetect != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpHystartDelayDetect))
	}
	if m.TcpHystartDelayCwnd != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpHystartDelayCwnd))
	}
	if m.TcpAckSkippedSynRecv != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAckSkippedSynRecv))
	}
	if m.TcpAckSkippedPaws != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAckSkippedPaws))
	}
	if m.TcpAckSkippedSeq != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAckSkippedSeq))
	}
	if m.TcpAckSkippedFinWait2 != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAckSkippedFinWait2))
	}
	if m.TcpAckSkippedTimeWait != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAckSkippedTimeWait))
	}
	if m.TcpAckSkippedChallenge != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAckSkippedChallenge))
	}
	if m.TcpWinProbe != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpWinProbe))
	}
	if m.TcpKeepAlive != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpKeepAlive))
	}
	if m.TcpMtupFail != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMtupFail))
	}
	if m.TcpMtupSuccess != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMtupSuccess))
	}
	if m.TcpDelivered != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDelivered))
	}
	if m.TcpDeliveredCe != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDeliveredCe))
	}
	if m.TcpAckCompressed != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpAckCompressed))
	}
	if m.TcpZeroWindowDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpZeroWindowDrop))
	}
	if m.TcpRcvQDrop != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpRcvQDrop))
	}
	if m.TcpWqueueTooBig != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpWqueueTooBig))
	}
	if m.TcpFastOpenPassiveAltKey != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpFastOpenPassiveAltKey))
	}
	if m.TcpTimeoutRehash != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpTimeoutRehash))
	}
	if m.TcpDuplicateDataRehash != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDuplicateDataRehash))
	}
	if m.TcpDsackRecvSegs != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackRecvSegs))
	}
	if m.TcpDsackIgnoredDubious != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpDsackIgnoredDubious))
	}
	if m.TcpMigrateReqSuccess != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMigrateReqSuccess))
	}
	if m.TcpMigrateReqFailure != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpMigrateReqFailure))
	}
	if m.TcpPlbRehash != 0 {
		n += 2 + sovTcpmon(uint64(m.TcpPlbRehash))
	}
	if m.IpInNoRoutes != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInNoRoutes))
	}
	if m.IpInTruncatedPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInTruncatedPkts))
	}
	if m.IpInMcastPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInMcastPkts))
	}
	if m.IpOutMcastPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutMcastPkts))
	}
	if m.IpInBcastPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInBcastPkts))
	}
	if m.IpOutBcastPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutBcastPkts))
	}
	if m.IpInOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInOctets))
	}
	if m.IpOutOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutOctets))
	}
	if m.IpInMcastOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInMcastOctets))
	}
	if m.IpOutMcastOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutMcastOctets))
	}
	if m.IpInBcastOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInBcastOctets))
	}
	if m.IpOutBcastOctets != 0 {
		n += 2 + sovTcpmon(uint64(m.IpOutBcastOctets))
	}
	if m.IpInCsumErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInCsumErrors))
	}
	if m.IpInNoEctPkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInNoEctPkts))
	}
	if m.IpInEct1Pkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInEct1Pkts))
	}
	if m.IpInEct0Pkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInEct0Pkts))
	}
	if m.IpInCePkts != 0 {
		n += 2 + sovTcpmon(uint64(m.IpInCePkts))
	}
	if m.IpReasmOverlaps != 0 {
		n += 2 + sovTcpmon(uint64(m.IpReasmOverlaps))
	}
	if m.IcmpInMsgs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInMsgs))
	}
	if m.IcmpInErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInErrors))
	}
	if m.IcmpInCsumErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInCsumErrors))
	}
	if m.IcmpInDestUnreachs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInDestUnreachs))
	}
	if m.IcmpInTimeExcds != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInTimeExcds))
	}
	if m.IcmpInParmProbs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInParmProbs))
	}
	if m.IcmpInSrcQuenchs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInSrcQuenchs))
	}
	if m.IcmpInRedirects != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInRedirects))
	}
	if m.IcmpInEchos != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInEchos))
	}
	if m.IcmpInEchoReps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInEchoReps))
	}
	if m.IcmpInTimestamps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInTimestamps))
	}
	if m.IcmpInTimestampReps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInTimestampReps))
	}
	if m.IcmpInAddrMasks != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInAddrMasks))
	}
	if m.IcmpInAddrMaskReps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpInAddrMaskReps))
	}
	if m.IcmpOutMsgs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutMsgs))
	}
	if m.IcmpOutErrors != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutErrors))
	}
	if m.IcmpOutRateLimitGlobal != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutRateLimitGlobal))
	}
	if m.IcmpOutRateLimitHost != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutRateLimitHost))
	}
	if m.IcmpOutDestUnreachs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutDestUnreachs))
	}
	if m.IcmpOutTimeExcds != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutTimeExcds))
	}
	if m.IcmpOutParmProbs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutParmProbs))
	}
	if m.IcmpOutSrcQuenchs != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutSrcQuenchs))
	}
	if m.IcmpOutRedirects != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutRedirects))
	}
	if m.IcmpOutEchos != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutEchos))
	}
	if m.IcmpOutEchoReps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutEchoReps))
	}
	if m.IcmpOutTimestamps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutTimestamps))
	}
	if m.IcmpOutTimestampReps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutTimestampReps))
	}
	if m.IcmpOutAddrMasks != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutAddrMasks))
	}
	if m.IcmpOutAddrMaskReps != 0 {
		n += 2 + sovTcpmon(uint64(m.IcmpOutAddrMaskReps))
	}
	return n
}

func sovTcpmon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTcpmon(x uint64) (n int) {
	return sovTcpmon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TcpMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Tcp{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NicMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Nic{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Net", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetstatMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Metric_Net{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocketMemoryUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocketMemoryUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocketMemoryUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RmemAlloc", wireType)
			}
			m.RmemAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RmemAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvBuf", wireType)
			}
			m.RcvBuf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvBuf |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WmemAlloc", wireType)
			}
			m.WmemAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WmemAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndBuf", wireType)
			}
			m.SndBuf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndBuf |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdAlloc", wireType)
			}
			m.FwdAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FwdAlloc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WmemQueued", wireType)
			}
			m.WmemQueued = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WmemQueued |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptMem", wireType)
			}
			m.OptMem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptMem |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackLog", wireType)
			}
			m.BackLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackLog |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SockDrop", wireType)
			}
			m.SockDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SockDrop |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTimeUs", wireType)
			}
			m.ExpireTimeUs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireTimeUs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retrans", wireType)
			}
			m.Retrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retrans |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fd", wireType)
			}
			m.Fd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocketMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocketMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocketMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SocketState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvQ", wireType)
			}
			m.RecvQ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvQ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendQ", wireType)
			}
			m.SendQ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendQ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &ProcessInfo{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timers = append(m.Timers, &TimerInfo{})
			if err := m.Timers[len(m.Timers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skmem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skmem == nil {
				m.Skmem = &SocketMemoryUsage{}
			}
			if err := m.Skmem.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ts = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sack = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cubic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cubic = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppLimited", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppLimited = bool(v != 0)
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacingRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PacingRate = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeliveryRate = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Send = float64(math.Float64frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWscale", wireType)
			}
			m.SndWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvWscale", wireType)
			}
			m.RcvWscale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvWscale |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rto", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rto = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rtt = float64(math.Float64frombits(v))
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rttvar", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rttvar = float64(math.Float64frombits(v))
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minrtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Minrtt = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvRtt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RcvRtt = float64(math.Float64frombits(v))
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransNow", wireType)
			}
			m.RetransNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransNow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransTotal", wireType)
			}
			m.RetransTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetransTotal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ato", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ato = float64(math.Float64frombits(v))
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mss", wireType)
			}
			m.Mss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmtu", wireType)
			}
			m.Pmtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rcvmss", wireType)
			}
			m.Rcvmss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rcvmss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advmss", wireType)
			}
			m.Advmss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Advmss |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwnd", wireType)
			}
			m.Cwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cwnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndWnd", wireType)
			}
			m.SndWnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndWnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesSent", wireType)
			}
			m.BytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesSent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesAcked", wireType)
			}
			m.BytesAcked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesAcked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesReceived", wireType)
			}
			m.BytesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesReceived |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegsOut", wireType)
			}
			m.SegsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegsIn", wireType)
			}
			m.SegsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegsIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastsnd", wireType)
			}
			m.Lastsnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastsnd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastrcv", wireType)
			}
			m.Lastrcv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastrcv |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastack", wireType)
			}
			m.Lastack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lastack |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delivered", wireType)
			}
			m.Delivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delivered |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusyMs", wireType)
			}
			m.BusyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusyMs |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvSpace", wireType)
			}
			m.RcvSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvSpace |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvSsthresh", wireType)
			}
			m.RcvSsthresh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvSsthresh |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSegsOut", wireType)
			}
			m.DataSegsOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSegsOut |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSegsIn", wireType)
			}
			m.DataSegsIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSegsIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwndLimited", wireType)
			}
			m.RwndLimited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RwndLimited |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndbufLimited", wireType)
			}
			m.SndbufLimited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SndbufLimited |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ecn = bool(v != 0)
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecnseen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ecnseen = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sockets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sockets = append(m.Sockets, &SocketMetric{})
			if err := m.Sockets[len(m.Sockets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IfaceMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IfaceMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IfaceMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxErrors", wireType)
			}
			m.RxErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxDropped", wireType)
			}
			m.RxDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOverruns", wireType)
			}
			m.RxOverruns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOverruns |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxFrame", wireType)
			}
			m.RxFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxFrame |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxErrors", wireType)
			}
			m.TxErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDropped", wireType)
			}
			m.TxDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxDropped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOverruns", wireType)
			}
			m.TxOverruns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOverruns |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCarrier", wireType)
			}
			m.TxCarrier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCarrier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCollisions", wireType)
			}
			m.TxCollisions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCollisions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NicMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NicMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NicMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTcpmon
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTcpmon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifaces = append(m.Ifaces, &IfaceMetric{})
			if err := m.Ifaces[len(m.Ifaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetstatMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetstatMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetstatMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetricType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpForwarding", wireType)
			}
			m.IpForwarding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpForwarding |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpDefaultTtl", wireType)
			}
			m.IpDefaultTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpDefaultTtl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInReceives", wireType)
			}
			m.IpInReceives = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInReceives |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInHdrErrors", wireType)
			}
			m.IpInHdrErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInHdrErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInAddrErrors", wireType)
			}
			m.IpInAddrErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInAddrErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpForwDatagrams", wireType)
			}
			m.IpForwDatagrams = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpForwDatagrams |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInUnknownProtos", wireType)
			}
			m.IpInUnknownProtos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInUnknownProtos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 107:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInDiscards", wireType)
			}
			m.IpInDiscards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInDiscards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 108:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInDelivers", wireType)
			}
			m.IpInDelivers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInDelivers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 109:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutRequests", wireType)
			}
			m.IpOutRequests = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutRequests |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 110:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutDiscards", wireType)
			}
			m.IpOutDiscards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutDiscards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutNoRoutes", wireType)
			}
			m.IpOutNoRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutNoRoutes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 112:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReasmTimeout", wireType)
			}
			m.IpReasmTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpReasmTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 113:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReasmReqds", wireType)
			}
			m.IpReasmReqds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpReasmReqds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 114:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReasmOks", wireType)
			}
			m.IpReasmOks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpReasmOks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 115:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReasmFails", wireType)
			}
			m.IpReasmFails = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpReasmFails |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFragOks", wireType)
			}
			m.IpFragOks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpFragOks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFragFails", wireType)
			}
			m.IpFragFails = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpFragFails |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 118:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFragCreates", wireType)
			}
			m.IpFragCreates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpFragCreates |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpInDatagrams", wireType)
			}
			m.UdpInDatagrams = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpInDatagrams |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpNoPorts", wireType)
			}
			m.UdpNoPorts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpNoPorts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 202:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpInErrors", wireType)
			}
			m.UdpInErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpInErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 203:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpOutDatagrams", wireType)
			}
			m.UdpOutDatagrams = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpOutDatagrams |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 204:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpRcvbufErrors", wireType)
			}
			m.UdpRcvbufErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpRcvbufErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 205:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSndbufErrors", wireType)
			}
			m.UdpSndbufErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpSndbufErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 206:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpInCsumErrors", wireType)
			}
			m.UdpInCsumErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpInCsumErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 207:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpIgnoredMulti", wireType)
			}
			m.UdpIgnoredMulti = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpIgnoredMulti |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 208:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpMemErrors", wireType)
			}
			m.UdpMemErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UdpMemErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 300:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRtoAlgorithm", wireType)
			}
			m.TcpRtoAlgorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRtoAlgorithm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 301:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRtoMin", wireType)
			}
			m.TcpRtoMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRtoMin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 302:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRtoMax", wireType)
			}
			m.TcpRtoMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRtoMax |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 303:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMaxConn", wireType)
			}
			m.TcpMaxConn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMaxConn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 304:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpActiveOpens", wireType)
			}
			m.TcpActiveOpens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpActiveOpens |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 305:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPassiveOpens", wireType)
			}
			m.TcpPassiveOpens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPassiveOpens |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 306:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAttemptFails", wireType)
			}
			m.TcpAttemptFails = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAttemptFails |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 307:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpEstabResets", wireType)
			}
			m.TcpEstabResets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpEstabResets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 308:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpCurrEstab", wireType)
			}
			m.TcpCurrEstab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpCurrEstab |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 309:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpInSegs", wireType)
			}
			m.TcpInSegs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpInSegs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 310:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOutSegs", wireType)
			}
			m.TcpOutSegs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOutSegs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 311:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRetransSegs", wireType)
			}
			m.TcpRetransSegs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRetransSegs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 312:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpInErrs", wireType)
			}
			m.TcpInErrs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpInErrs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 313:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOutRsts", wireType)
			}
			m.TcpOutRsts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOutRsts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 314:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpInCsumErrors", wireType)
			}
			m.TcpInCsumErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpInCsumErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 400:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSyncookiesSent", wireType)
			}
			m.TcpSyncookiesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSyncookiesSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 401:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSyncookiesRecv", wireType)
			}
			m.TcpSyncookiesRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSyncookiesRecv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 402:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSyncookiesFailed", wireType)
			}
			m.TcpSyncookiesFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSyncookiesFailed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 403:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpEmbryonicRsts", wireType)
			}
			m.TcpEmbryonicRsts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpEmbryonicRsts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 404:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPruneCalled", wireType)
			}
			m.TcpPruneCalled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPruneCalled |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 405:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRcvPruned", wireType)
			}
			m.TcpRcvPruned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRcvPruned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 406:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOfoPruned", wireType)
			}
			m.TcpOfoPruned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOfoPruned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 407:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOutOfWindowIcmps", wireType)
			}
			m.TcpOutOfWindowIcmps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOutOfWindowIcmps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 408:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLockDroppedIcmps", wireType)
			}
			m.TcpLockDroppedIcmps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpLockDroppedIcmps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 409:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpArpFilter", wireType)
			}
			m.TcpArpFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpArpFilter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 410:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTw", wireType)
			}
			m.TcpTw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTw |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 411:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTwRecycled", wireType)
			}
			m.TcpTwRecycled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTwRecycled |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 412:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTwKilled", wireType)
			}
			m.TcpTwKilled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTwKilled |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 413:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPawsActive", wireType)
			}
			m.TcpPawsActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPawsActive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 414:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPawsEstab", wireType)
			}
			m.TcpPawsEstab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPawsEstab |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 415:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDelayedAcks", wireType)
			}
			m.TcpDelayedAcks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDelayedAcks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 416:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDelayedAckLocked", wireType)
			}
			m.TcpDelayedAckLocked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDelayedAckLocked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 417:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDelayedAckLost", wireType)
			}
			m.TcpDelayedAckLost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDelayedAckLost |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 418:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpListenOverflows", wireType)
			}
			m.TcpListenOverflows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpListenOverflows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 419:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpListenDrops", wireType)
			}
			m.TcpListenDrops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpListenDrops |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 420:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHpHits", wireType)
			}
			m.TcpHpHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHpHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 421:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPureAcks", wireType)
			}
			m.TcpPureAcks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPureAcks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 422:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHpAcks", wireType)
			}
			m.TcpHpAcks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHpAcks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 423:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRenoRecovery", wireType)
			}
			m.TcpRenoRecovery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRenoRecovery |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 424:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackRecovery", wireType)
			}
			m.TcpSackRecovery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackRecovery |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 425:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackReneging", wireType)
			}
			m.TcpSackReneging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackReneging |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 426:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackReorder", wireType)
			}
			m.TcpSackReorder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackReorder |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 427:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRenoReorder", wireType)
			}
			m.TcpRenoReorder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRenoReorder |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 428:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTsReorder", wireType)
			}
			m.TcpTsReorder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTsReorder |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 429:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFullUndo", wireType)
			}
			m.TcpFullUndo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFullUndo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 430:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPartialUndo", wireType)
			}
			m.TcpPartialUndo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPartialUndo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 431:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackUndo", wireType)
			}
			m.TcpDsackUndo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackUndo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 432:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLossUndo", wireType)
			}
			m.TcpLossUndo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpLossUndo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 433:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLostRetransmit", wireType)
			}
			m.TcpLostRetransmit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpLostRetransmit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 434:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRenoFailures", wireType)
			}
			m.TcpRenoFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRenoFailures |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 435:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackFailures", wireType)
			}
			m.TcpSackFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackFailures |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 436:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLossFailures", wireType)
			}
			m.TcpLossFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpLossFailures |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 437:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastRetrans", wireType)
			}
			m.TcpFastRetrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastRetrans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 438:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSlowStartRetrans", wireType)
			}
			m.TcpSlowStartRetrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSlowStartRetrans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 439:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTimeouts", wireType)
			}
			m.TcpTimeouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTimeouts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 440:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLossProbes", wireType)
			}
			m.TcpLossProbes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpLossProbes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 441:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpLossProbeRecovery", wireType)
			}
			m.TcpLossProbeRecovery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpLossProbeRecovery |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 442:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRenoRecoveryFail", wireType)
			}
			m.TcpRenoRecoveryFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRenoRecoveryFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 443:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackRecoveryFail", wireType)
			}
			m.TcpSackRecoveryFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackRecoveryFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 444:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRcvCollapsed", wireType)
			}
			m.TcpRcvCollapsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRcvCollapsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 445:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpBacklogCoalesce", wireType)
			}
			m.TcpBacklogCoalesce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpBacklogCoalesce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 446:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackOldSent", wireType)
			}
			m.TcpDsackOldSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackOldSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 447:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackOfoSent", wireType)
			}
			m.TcpDsackOfoSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackOfoSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 448:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackRecv", wireType)
			}
			m.TcpDsackRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackRecv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 449:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackOfoRecv", wireType)
			}
			m.TcpDsackOfoRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackOfoRecv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 450:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAbortOnData", wireType)
			}
			m.TcpAbortOnData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAbortOnData |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 451:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAbortOnClose", wireType)
			}
			m.TcpAbortOnClose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAbortOnClose |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 452:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAbortOnMemory", wireType)
			}
			m.TcpAbortOnMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAbortOnMemory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 453:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAbortOnTimeout", wireType)
			}
			m.TcpAbortOnTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAbortOnTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 454:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAbortOnLinger", wireType)
			}
			m.TcpAbortOnLinger = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAbortOnLinger |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 455:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAbortFailed", wireType)
			}
			m.TcpAbortFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAbortFailed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 456:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMemoryPressures", wireType)
			}
			m.TcpMemoryPressures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMemoryPressures |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 457:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMemoryPressuresChrono", wireType)
			}
			m.TcpMemoryPressuresChrono = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMemoryPressuresChrono |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 458:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackDiscard", wireType)
			}
			m.TcpSackDiscard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackDiscard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 459:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackIgnoredOld", wireType)
			}
			m.TcpDsackIgnoredOld = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackIgnoredOld |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 460:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackIgnoredNoUndo", wireType)
			}
			m.TcpDsackIgnoredNoUndo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackIgnoredNoUndo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 461:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSpuriousRtos", wireType)
			}
			m.TcpSpuriousRtos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSpuriousRtos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 462:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMd5NotFound", wireType)
			}
			m.TcpMd5NotFound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMd5NotFound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 463:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMd5Unexpected", wireType)
			}
			m.TcpMd5Unexpected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMd5Unexpected |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 464:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMd5Failure", wireType)
			}
			m.TcpMd5Failure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMd5Failure |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 465:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackShifted", wireType)
			}
			m.TcpSackShifted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackShifted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 466:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackMerged", wireType)
			}
			m.TcpSackMerged = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackMerged |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 467:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSackShiftFallback", wireType)
			}
			m.TcpSackShiftFallback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSackShiftFallback |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 468:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpBacklogDrop", wireType)
			}
			m.TcpBacklogDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpBacklogDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 469:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPfMemallocDrop", wireType)
			}
			m.TcpPfMemallocDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPfMemallocDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 470:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMinTtlDrop", wireType)
			}
			m.TcpMinTtlDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMinTtlDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 471:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDeferAcceptDrop", wireType)
			}
			m.TcpDeferAcceptDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDeferAcceptDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 472:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpIpReversePathFilter", wireType)
			}
			m.TcpIpReversePathFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpIpReversePathFilter |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 473:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTimeWaitOverflow", wireType)
			}
			m.TcpTimeWaitOverflow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTimeWaitOverflow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 474:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpReqQFullDoCookies", wireType)
			}
			m.TcpReqQFullDoCookies = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpReqQFullDoCookies |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 475:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpReqQFullDrop", wireType)
			}
			m.TcpReqQFullDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpReqQFullDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 476:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRetransFail", wireType)
			}
			m.TcpRetransFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRetransFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 477:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRcvCoalesce", wireType)
			}
			m.TcpRcvCoalesce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRcvCoalesce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 478:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOfoQueue", wireType)
			}
			m.TcpOfoQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOfoQueue |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 479:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOfoDrop", wireType)
			}
			m.TcpOfoDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOfoDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 480:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOfoMerge", wireType)
			}
			m.TcpOfoMerge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOfoMerge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 481:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpChallengeAck", wireType)
			}
			m.TcpChallengeAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpChallengeAck |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 482:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynChallenge", wireType)
			}
			m.TcpSynChallenge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSynChallenge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 483:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenActive", wireType)
			}
			m.TcpFastOpenActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenActive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 484:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenActiveFail", wireType)
			}
			m.TcpFastOpenActiveFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenActiveFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 485:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenPassive", wireType)
			}
			m.TcpFastOpenPassive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenPassive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 486:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenPassiveFail", wireType)
			}
			m.TcpFastOpenPassiveFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenPassiveFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 487:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenListenOverflow", wireType)
			}
			m.TcpFastOpenListenOverflow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenListenOverflow |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 488:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenCookieReqd", wireType)
			}
			m.TcpFastOpenCookieReqd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenCookieReqd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 489:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenBlackhole", wireType)
			}
			m.TcpFastOpenBlackhole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenBlackhole |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 490:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSpuriousRtxHostQueues", wireType)
			}
			m.TcpSpuriousRtxHostQueues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSpuriousRtxHostQueues |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 491:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpBusyPollRxPackets", wireType)
			}
			m.TcpBusyPollRxPackets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpBusyPollRxPackets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 492:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAutoCorking", wireType)
			}
			m.TcpAutoCorking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAutoCorking |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 493:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFromZeroWindowAdv", wireType)
			}
			m.TcpFromZeroWindowAdv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFromZeroWindowAdv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 494:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpToZeroWindowAdv", wireType)
			}
			m.TcpToZeroWindowAdv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpToZeroWindowAdv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 495:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpWantZeroWindowAdv", wireType)
			}
			m.TcpWantZeroWindowAdv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpWantZeroWindowAdv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 496:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynRetrans", wireType)
			}
			m.TcpSynRetrans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpSynRetrans |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 497:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOrigDataSent", wireType)
			}
			m.TcpOrigDataSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpOrigDataSent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 498:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHystartTrainDetect", wireType)
			}
			m.TcpHystartTrainDetect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHystartTrainDetect |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 499:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHystartTrainCwnd", wireType)
			}
			m.TcpHystartTrainCwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHystartTrainCwnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 500:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHystartDelayDetect", wireType)
			}
			m.TcpHystartDelayDetect = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHystartDelayDetect |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 501:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpHystartDelayCwnd", wireType)
			}
			m.TcpHystartDelayCwnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpHystartDelayCwnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 502:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSkippedSynRecv", wireType)
			}
			m.TcpAckSkippedSynRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAckSkippedSynRecv |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 503:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSkippedPaws", wireType)
			}
			m.TcpAckSkippedPaws = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAckSkippedPaws |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 504:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSkippedSeq", wireType)
			}
			m.TcpAckSkippedSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAckSkippedSeq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 505:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSkippedFinWait2", wireType)
			}
			m.TcpAckSkippedFinWait2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAckSkippedFinWait2 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 506:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSkippedTimeWait", wireType)
			}
			m.TcpAckSkippedTimeWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAckSkippedTimeWait |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 507:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckSkippedChallenge", wireType)
			}
			m.TcpAckSkippedChallenge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAckSkippedChallenge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 508:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpWinProbe", wireType)
			}
			m.TcpWinProbe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpWinProbe |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 509:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpKeepAlive", wireType)
			}
			m.TcpKeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpKeepAlive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 510:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMtupFail", wireType)
			}
			m.TcpMtupFail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMtupFail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 511:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMtupSuccess", wireType)
			}
			m.TcpMtupSuccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMtupSuccess |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 512:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDelivered", wireType)
			}
			m.TcpDelivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDelivered |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 513:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDeliveredCe", wireType)
			}
			m.TcpDeliveredCe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDeliveredCe |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 514:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpAckCompressed", wireType)
			}
			m.TcpAckCompressed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpAckCompressed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 515:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpZeroWindowDrop", wireType)
			}
			m.TcpZeroWindowDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpZeroWindowDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 516:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpRcvQDrop", wireType)
			}
			m.TcpRcvQDrop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpRcvQDrop |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 517:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpWqueueTooBig", wireType)
			}
			m.TcpWqueueTooBig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpWqueueTooBig |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 518:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpFastOpenPassiveAltKey", wireType)
			}
			m.TcpFastOpenPassiveAltKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpFastOpenPassiveAltKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 519:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpTimeoutRehash", wireType)
			}
			m.TcpTimeoutRehash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpTimeoutRehash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 520:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDuplicateDataRehash", wireType)
			}
			m.TcpDuplicateDataRehash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDuplicateDataRehash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 521:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackRecvSegs", wireType)
			}
			m.TcpDsackRecvSegs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackRecvSegs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 522:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpDsackIgnoredDubious", wireType)
			}
			m.TcpDsackIgnoredDubious = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpDsackIgnoredDubious |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 523:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMigrateReqSuccess", wireType)
			}
			m.TcpMigrateReqSuccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMigrateReqSuccess |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 524:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpMigrateReqFailure", wireType)
			}
			m.TcpMigrateReqFailure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpMigrateReqFailure |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 525:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpPlbRehash", wireType)
			}
			m.TcpPlbRehash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpPlbRehash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 600:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInNoRoutes", wireType)
			}
			m.IpInNoRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInNoRoutes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 601:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInTruncatedPkts", wireType)
			}
			m.IpInTruncatedPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInTruncatedPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 602:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInMcastPkts", wireType)
			}
			m.IpInMcastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInMcastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 603:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutMcastPkts", wireType)
			}
			m.IpOutMcastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutMcastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 604:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInBcastPkts", wireType)
			}
			m.IpInBcastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInBcastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 605:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutBcastPkts", wireType)
			}
			m.IpOutBcastPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutBcastPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 606:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInOctets", wireType)
			}
			m.IpInOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 607:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutOctets", wireType)
			}
			m.IpOutOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 608:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInMcastOctets", wireType)
			}
			m.IpInMcastOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInMcastOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 609:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutMcastOctets", wireType)
			}
			m.IpOutMcastOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutMcastOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 610:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInBcastOctets", wireType)
			}
			m.IpInBcastOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInBcastOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 611:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpOutBcastOctets", wireType)
			}
			m.IpOutBcastOctets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpOutBcastOctets |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 612:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInCsumErrors", wireType)
			}
			m.IpInCsumErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInCsumErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 613:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInNoEctPkts", wireType)
			}
			m.IpInNoEctPkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInNoEctPkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 614:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInEct1Pkts", wireType)
			}
			m.IpInEct1Pkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInEct1Pkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 615:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInEct0Pkts", wireType)
			}
			m.IpInEct0Pkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInEct0Pkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 616:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpInCePkts", wireType)
			}
			m.IpInCePkts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpInCePkts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 617:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReasmOverlaps", wireType)
			}
			m.IpReasmOverlaps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpReasmOverlaps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 700:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInMsgs", wireType)
			}
			m.IcmpInMsgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInMsgs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 701:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInErrors", wireType)
			}
			m.IcmpInErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 702:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInCsumErrors", wireType)
			}
			m.IcmpInCsumErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInCsumErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 703:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInDestUnreachs", wireType)
			}
			m.IcmpInDestUnreachs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInDestUnreachs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 704:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInTimeExcds", wireType)
			}
			m.IcmpInTimeExcds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInTimeExcds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 705:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInParmProbs", wireType)
			}
			m.IcmpInParmProbs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInParmProbs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 706:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInSrcQuenchs", wireType)
			}
			m.IcmpInSrcQuenchs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInSrcQuenchs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 707:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInRedirects", wireType)
			}
			m.IcmpInRedirects = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInRedirects |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 708:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInEchos", wireType)
			}
			m.IcmpInEchos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInEchos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 709:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInEchoReps", wireType)
			}
			m.IcmpInEchoReps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInEchoReps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 710:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInTimestamps", wireType)
			}
			m.IcmpInTimestamps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInTimestamps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 711:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInTimestampReps", wireType)
			}
			m.IcmpInTimestampReps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInTimestampReps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 712:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInAddrMasks", wireType)
			}
			m.IcmpInAddrMasks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInAddrMasks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 713:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpInAddrMaskReps", wireType)
			}
			m.IcmpInAddrMaskReps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpInAddrMaskReps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 714:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutMsgs", wireType)
			}
			m.IcmpOutMsgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutMsgs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 715:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutErrors", wireType)
			}
			m.IcmpOutErrors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutErrors |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 716:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutRateLimitGlobal", wireType)
			}
			m.IcmpOutRateLimitGlobal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutRateLimitGlobal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 717:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutRateLimitHost", wireType)
			}
			m.IcmpOutRateLimitHost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutRateLimitHost |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 718:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutDestUnreachs", wireType)
			}
			m.IcmpOutDestUnreachs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutDestUnreachs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 719:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutTimeExcds", wireType)
			}
			m.IcmpOutTimeExcds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutTimeExcds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 720:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutParmProbs", wireType)
			}
			m.IcmpOutParmProbs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutParmProbs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 721:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutSrcQuenchs", wireType)
			}
			m.IcmpOutSrcQuenchs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutSrcQuenchs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 722:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutRedirects", wireType)
			}
			m.IcmpOutRedirects = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutRedirects |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 723:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutEchos", wireType)
			}
			m.IcmpOutEchos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutEchos |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 724:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutEchoReps", wireType)
			}
			m.IcmpOutEchoReps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutEchoReps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 725:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutTimestamps", wireType)
			}
			m.IcmpOutTimestamps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutTimestamps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 726:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutTimestampReps", wireType)
			}
			m.IcmpOutTimestampReps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutTimestampReps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 727:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutAddrMasks", wireType)
			}
			m.IcmpOutAddrMasks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutAddrMasks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 728:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpOutAddrMaskReps", wireType)
			}
			m.IcmpOutAddrMaskReps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IcmpOutAddrMaskReps |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTcpmon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTcpmon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTcpmon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTcpmon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTcpmon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTcpmon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTcpmon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTcpmon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTcpmon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTcpmon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTcpmon = fmt.Errorf("proto: unexpected end of group")
)
